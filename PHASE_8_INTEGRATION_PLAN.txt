================================================================================
  OPTIMIZATION 9: PHASE 8 - INTEGRATION PLAN
================================================================================

Date: October 21, 2025
Status: PLANNING

================================================================================
INTEGRATION POINTS
================================================================================

Current Flow (without fallback):
  process_one_work()
    ↓
    pipeline.run() [ResolverPipeline]
    ↓
    Returns: PipelineResult (success, outcome, resolver_name, ...)

Desired Flow (with fallback):
  process_one_work()
    ↓
    [Feature gate check: enable_fallback_strategy?]
    ↓
    YES: orchestrator.resolve_pdf() [FallbackOrchestrator]
    ↑
    NO: pipeline.run() [ResolverPipeline]

================================================================================
IMPLEMENTATION STRATEGY
================================================================================

Option 1: Serial (Fallback First, then Pipeline)
  Pro: Simple, can disable fallback entirely
  Pro: Fallback gets first attempt
  Con: Double attempts if both fail
  
Option 2: Fallback Alternative (Only if pipeline would fail)
  Pro: Maintains backward compatibility
  Pro: Uses fallback as "enhanced resolver"
  Con: Complex state coordination

Option 3: Integrated (Fallback wraps pipeline results)
  Pro: Single attempt coordination
  Pro: Comprehensive telemetry
  Con: Requires refactoring pipeline result handling

CHOSEN: Option 1 (Serial with feature gate)
  Rationale: Simplest, doesn't break existing code, allows A/B testing

================================================================================
IMPLEMENTATION STEPS
================================================================================

Step 1: Add CLI flag for enabling fallback
  File: args.py
  Add: --enable-fallback-strategy flag (default False for now)
  Add: --fallback-plan-path flag (path to fallback.yaml)

Step 2: Pass fallback config through DownloadConfig
  File: download.py / args.py
  Add: enable_fallback_strategy: bool field
  Add: fallback_plan: Optional[FallbackPlan] field

Step 3: Load fallback plan in runner
  File: runner.py
  Add: load fallback configuration if enabled
  Pass to orchestrator instance

Step 4: Create orchestrator in process_one_work
  File: download.py
  Add: Create FallbackOrchestrator if enabled
  Add: Call orchestrator.resolve_pdf() BEFORE pipeline.run()
  Add: If success, skip pipeline and return early
  Add: If not found, proceed with pipeline (fallback to existing)

Step 5: Adapter implementations
  File: fallback/adapters/*.py
  Add: Call to breaker.allow() for pre-flight checks
  Add: Call to request_with_retries() for HTTP requests
  Add: Proper error handling for all failure modes

Step 6: Telemetry correlation
  File: download.py / orchestrator.py
  Add: Pass run_id to orchestrator
  Add: Ensure fallback events include run_id and work_id
  Add: Manifest integration with fallback outcomes

================================================================================
FEATURE GATE DEFAULTS
================================================================================

Phase 8 (Integration Phase): Feature disabled by default
  --enable-fallback-strategy not set → Use existing pipeline
  Allows operators to opt-in for testing

Phase 9+ (Testing & Validation): 
  Comprehensive tests validate before changing default

Phase 10+ (Full Production):
  Consider making fallback the default with --disable-fallback option
  Or keep as opt-in based on deployment strategy

================================================================================
BACKWARD COMPATIBILITY
================================================================================

✅ No changes to existing DownloadOutcome or PipelineResult
✅ No changes to manifest schema
✅ No changes to resolver pipeline behavior
✅ Fallback is purely opt-in feature
✅ All existing code paths work unchanged
✅ Fallback telemetry separate from resolver attempts

Compatibility guarantees:
  • If fallback disabled: identical behavior to pre-Phase8
  • If fallback enabled but no PDF found: pipeline runs as fallback
  • Manifest schema unchanged
  • Telemetry backward compatible

================================================================================
ERROR HANDLING
================================================================================

Fallback orchestrator errors:
  • Adapter exceptions: Logged, attempt continues
  • Timeout exceeded: Returns "timeout" outcome
  • All adapters fail: Returns "no_pdf" outcome
  • Network errors: Handled by request_with_retries()

Pipeline errors (existing):
  • Unaffected by fallback
  • Falls back to existing behavior

Telemetry errors:
  • No-op implementations on non-SQLite sinks
  • Missing telemetry doesn't block resolution

================================================================================
TESTING STRATEGY
================================================================================

Phase 8 Integration Tests:
  1. Feature gate disabled → existing behavior
  2. Feature gate enabled, fallback succeeds → return early
  3. Feature gate enabled, fallback fails → pipeline runs
  4. Telemetry events logged correctly
  5. No regressions in existing pipeline

Phase 9 Comprehensive Tests:
  • All adapter scenarios
  • Budget enforcement
  • Concurrency limits
  • Health gates
  • Error handling

================================================================================
CONTEXT FOR ADAPTERS
================================================================================

Adapters receive context dict with:
  • work_id: str - Work identifier
  • artifact_id: str - Artifact identifier
  • doi: str - DOI if available
  • url: str - URL if available
  • offline: bool - Whether in offline mode
  • head_client: httpx.Client - Cached client
  • raw_client: httpx.Client - Raw client
  • breaker: Optional[BreakerRegistry] - Circuit breaker
  • rate: Optional[RateLimiter] - Rate limiter
  • email: str - Polite email for APIs

Adapters return AttemptResult with:
  • outcome: ResolutionOutcome
  • reason: str - Short reason code
  • elapsed_ms: int - Time taken
  • url: Optional[str] - PDF URL if success
  • status: Optional[int] - HTTP status
  • host: Optional[str] - Hostname
  • meta: Dict[str, Any] - Additional metadata

================================================================================
TIMELINE
================================================================================

Phase 8 (today): ~2 hours
  • Add CLI flags
  • Modify DownloadConfig
  • Integrate into process_one_work
  • Basic feature gate

Phase 9: ~6 hours
  • Comprehensive tests
  • Adapter implementation
  • Integration verification

Phase 10: ~2 hours
  • Documentation
  • AGENTS.md updates
  • Operational playbooks

Total: ~10 hours remaining

================================================================================
SUCCESS CRITERIA
================================================================================

Phase 8 Complete when:
  ✅ Fallback flag works and disables/enables feature
  ✅ With flag disabled, behavior identical to pre-Phase8
  ✅ With flag enabled, fallback orchestrator invoked
  ✅ Successful PDF from fallback returns without pipeline
  ✅ Failed fallback falls back to pipeline
  ✅ Telemetry events appear in SQLite
  ✅ No linting errors
  ✅ No test regressions

================================================================================
