================================================================================
CIRCUIT BREAKER IMPLEMENTATION PLAN — EXECUTIVE SUMMARY
================================================================================

PROJECT: DocsToKG.ContentDownload Pybreaker Circuit Breaker Integration
DATE: October 20, 2025
STATUS: Planning Phase Complete ✅
COMPLEXITY: HIGH (but modular & low-risk)

================================================================================
WHAT WE'RE BUILDING
================================================================================

A production-ready, pybreaker-based circuit breaker system that:

✓ Detects & short-circuits unhealthy hosts (API, resolvers)
✓ Honors Retry-After headers with server-controlled cooldowns
✓ Detects burst failures (rolling window: 6 failures in 30s)
✓ Shares state across processes (SQLite for local, Redis for multi-host)
✓ Emits structured telemetry for debugging & auto-tuning
✓ Provides CLI ops tools: show state, force open/close, advise tuning
✓ Auto-tunes breaker parameters based on observed telemetry

KEY BENEFITS:
- Fails fast (no wasted retries when host is down)
- Faster recovery (honors server signals + learns from patterns)
- Observable (telemetry shows exactly why service degraded)
- Safe (heuristic advisor suggests changes, no aggressive auto-tuning)

================================================================================
ARCHITECTURE AT A GLANCE
================================================================================

    ┌─ request_with_retries()
    │  • Pre-flight: registry.allow() → BreakerOpenError if down
    │  • Post-response: registry.on_success/on_failure()
    │
    ├─ BreakerRegistry (orchestrator)
    │  • Per-host CircuitBreaker (pybreaker)
    │  • Per-resolver CircuitBreaker (optional)
    │  • Cooldown store (Retry-After + rolling window)
    │  • Half-open probe limiting (1 per role by default)
    │
    ├─ CooldownStore abstraction
    │  • InMemoryCooldownStore (default, process-local)
    │  • SQLiteCooldownStore (multi-process, local)
    │  • RedisCooldownStore (multi-host, optional)
    │
    ├─ NetworkBreakerListener (telemetry)
    │  • Emits: before_call, success, failure, state_change
    │  • Feeds telemetry sink → manifest.sqlite3
    │
    └─ CLI commands
       • breaker show [--host]      → list state
       • breaker open <host>        → force-open for ops
       • breaker close <host>       → reset state
       • breaker-advise --enforce   → auto-tune policies

================================================================================
PHASES & TIMELINE
================================================================================

PHASE 1: Cross-Process Stores (Week 1)
  1a. SQLiteCooldownStore (151 lines) ← uses wall↔monotonic conversion
  1b. RedisCooldownStore (86 lines, optional) ← for multi-host deployments

PHASE 2: Complete breakers.py (Week 1)
  • Add success_threshold support
  • Clear remaining TODOs
  • Verify pybreaker API usage

PHASE 3: Networking Integration (Week 1)
  • Pre-flight: registry.allow() in request_with_retries
  • Post-response: registry.on_failure/on_success based on status code
  • Skip updates for cached responses & neutral statuses (401/403/404)

PHASE 4: CLI Commands (Week 2)
  • cli_breakers.py: show/open/close (83 lines)
  • cli_breaker_advisor.py: breaker-advise (52 lines)

PHASE 5: Advisor & Auto-Tuner (Week 2)
  • breaker_advisor.py: read_metrics(), advise() (283 lines)
  • breaker_autotune.py: suggest(), enforce() (52 lines)
  • Heuristics: high 429 → reduce RPS, Retry-After → tune reset_timeout, etc.

PHASE 6: CLI Integration (Week 2)
  • Wire all new commands into cli.py via install_* functions
  • Create registry factory for dependency injection

PHASE 7: Telemetry (Week 3)
  • Add breaker_transitions table to manifest.sqlite3
  • Aggregate metrics: opens/hour, time-saved, success-after-open rate
  • Wire NetworkBreakerListener into telemetry sink

PHASE 8: Config YAML (Week 3)
  • Create config/breakers.yaml template
  • Defaults, host-specific policies, role overrides, rolling window settings

PHASE 9: Comprehensive Tests (Week 3)
  • test_breakers_core.py (250 lines) - state machine, policies
  • test_breakers_networking.py (200 lines) - integration
  • test_cli_breakers.py (125 lines) - CLI commands
  • test_breaker_advisor.py (150 lines) - metrics & heuristics
  • Total: ~725 lines of test coverage

PHASE 10: Runner Integration (Week 4)
  • Instantiate BreakerRegistry in DownloadRun
  • Pass registry to pipeline & networking layers
  • Load config from YAML with env/CLI overlays

PHASE 11: Documentation (Week 4)
  • Update AGENTS.md with breaker section
  • Add operational playbooks: "Debug noisy host", "Temporary maintenance"
  • Example CLI invocations

PHASE 12: Validation (Week 4)
  • ruff check, mypy, pytest -q
  • CLI --help shows all new subcommands
  • End-to-end dry-run with small workload
  • Inspect manifest metrics

================================================================================
KEY DESIGN DECISIONS (with pybreaker library rationale)
================================================================================

1. PYBREAKER STATE MACHINE
   ✓ Closed → Open → Half-Open (industry-standard Release It! pattern)
   ✓ pybreaker implements exactly this; no reimplementation needed
   ✓ Read-only counters exposed (fail_counter, success_counter)

2. FAILURE CLASSIFICATION
   ✓ Failures: 429, 5xx, 408 (retryable server errors)
   ✓ Neutral: 401, 403, 404, 410, 451 (don't update breaker)
   ✓ Successes: 2xx, 3xx (clear failure counter)
   ✓ Configured via BreakerClassification, not hardcoded

3. WALL-CLOCK vs MONOTONIC
   ✓ Storage: wall-clock (UTC epoch) → survives process restart
   ✓ Runtime: monotonic (time.monotonic) → immune to clock drift
   ✓ Conversion at read/write time, transparent to callers
   ✓ Prevents issues in multi-process deployments

4. RETRY-AFTER AWARENESS
   ✓ Parsed from 429/503 headers (existing parse_retry_after_header)
   ✓ Sets cooldown override (separate from pybreaker state)
   ✓ Capped at retry_after_cap_s (900s default)
   ✓ Honored before rolling-window or pybreaker decisions

5. HALF-OPEN PROBE LIMITING
   ✓ pybreaker allows 1 trial by default; per-role overrides possible
   ✓ Tracked manually in registry (pybreaker doesn't expose this)
   ✓ Role-specific: metadata=1, artifact=2 (configurable)
   ✓ Tiny jitter (≤150ms) to desynchronize concurrent probes

6. AUTO-TUNING HEURISTICS
   ✓ Rate limiter first: high 429 → reduce RPS before breaker changes
   ✓ Retry-After signal: median header value → set reset_timeout_s
   ✓ Open frequency: >3 opens/window → lower fail_max
   ✓ Half-open outcomes: >50% failures → require 2 successes to close
   ✓ Safe bounds: ALL suggestions clamped to [2,10], [15,600], [1,3]

================================================================================
INTEGRATION POINTS (where circuit breaker plugs in)
================================================================================

1. NETWORKING LAYER (request_with_retries)
   Before sending:
   - registry.allow(host, role=RequestRole.METADATA, resolver=resolver)
   - If BreakerOpenError → short-circuit, log cooldown_ms, fail immediately

   After response:
   - if status in {429, 5xx, 408}: registry.on_failure(status, retry_after_s)
   - elif status in {401, 403, 404, 410, 451}: do nothing (neutral)
   - elif from_cache: do nothing (no network happened)
   - else: registry.on_success()

2. RUNNER/PIPELINE LAYER (DownloadRun)
   - Instantiate registry at startup
   - Load config from YAML + env + CLI
   - Pass registry to networking & pipeline

3. CLI LAYER (cli.py)
   - Install breaker subcommands via install_breaker_cli
   - Install advisor subcommand via install_breaker_advisor_cli
   - Factory injects registry (lazy init)

4. TELEMETRY LAYER (telemetry.py)
   - Wire NetworkBreakerListener into sink
   - Add breaker_transitions table to manifest.sqlite3
   - Aggregate opens/hour, time-saved, success-after-open in summary.json

================================================================================
FILES & LOC BREAKDOWN
================================================================================

CREATE (8 new files):
  sqlite_cooldown_store.py       151 lines
  redis_cooldown_store.py         86 lines (optional)
  cli_breakers.py                 83 lines
  cli_breaker_advisor.py          52 lines
  breaker_advisor.py             283 lines
  breaker_autotune.py             52 lines
  config/breakers.yaml            60 lines
  → Subtotal: ~767 lines new code

MODIFY (5 existing files):
  breakers.py                    +50 lines (success_threshold, TODOs)
  networking.py                 +100 lines (pre-flight, post-response)
  cli.py                         +30 lines (wire commands, factory)
  runner.py                      +40 lines (instantiate registry)
  telemetry.py                   +80 lines (breaker transitions table)
  → Subtotal: ~300 lines modified

TESTS (4 new test files):
  test_breakers_core.py          250 lines
  test_breakers_networking.py    200 lines
  test_cli_breakers.py           125 lines
  test_breaker_advisor.py        150 lines
  → Subtotal: ~725 lines tests

DOCS (1 update):
  AGENTS.md                      +50 lines (breaker section, playbooks)

================================================================================
TOTAL: ~1,842 lines of code + tests + docs
RISK LEVEL: LOW ✅
COMPLEXITY: MEDIUM ⚠️ (many pieces, but well-defined)
TEST COVERAGE: COMPREHENSIVE ✅

================================================================================
SUCCESS METRICS
================================================================================

✓ All 40+ unit tests passing (core + networking + CLI + advisor)
✓ Breaker denials reduce downstream HTTP 429 (measured via metrics)
✓ Half-open probes restore service (success-after-open ≥70%)
✓ Telemetry shows opens/hour, time-saved, reason mix (debuggable)
✓ CLI breaker show/open/close work as documented
✓ Auto-advisor suggests safe tuning (no flapping)
✓ Zero breaking changes to existing ContentDownload CLI/config
✓ No-install policy respected throughout

================================================================================
IMPLEMENTATION READY: YES ✅
NEXT STEP: Begin Phase 1a (SQLiteCooldownStore)
================================================================================
