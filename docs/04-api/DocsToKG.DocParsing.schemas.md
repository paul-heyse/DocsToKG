# 1. Module: schemas

This reference documents the DocsToKG module ``DocsToKG.DocParsing.schemas``.

DocParsing schema definitions and validation utilities.

This module centralises the Pydantic models used to validate document chunks
and embedding vectors generated by the DocsToKG processing pipeline. The
schemas enforce structural guarantees before data is persisted, ensuring that
downstream search, indexing, and processing stages receive consistent inputs.

Args:
    None: Modules do not accept runtime arguments.

Returns:
    None: This module exposes models rather than functions with return values.

Raises:
    None: Importing this module does not raise custom exceptions.

## 1. Functions

### `validate_chunk_row(row)`

Validate and parse a chunk JSONL row.

Args:
row: Raw dictionary from JSONL.

Returns:
Validated :class:`ChunkRow` instance.

Raises:
ValueError: If the row fails schema validation.

Examples:
>>> validate_chunk_row({
...     "doc_id": "doc",
...     "source_path": "path",
...     "chunk_id": 0,
...     "source_chunk_idxs": [0],
...     "num_tokens": 10,
...     "text": "hello",
... })
ChunkRow(doc_id='doc', source_path='path', chunk_id=0, source_chunk_idxs=[0], num_tokens=10, text='hello', doc_items_refs=[], page_nos=[], schema_version='docparse/1.1.0', provenance=None, uuid=None)

### `validate_vector_row(row)`

Validate and parse a vector JSONL row.

Args:
row: Raw dictionary from JSONL.

Returns:
Validated :class:`VectorRow` instance.

Raises:
ValueError: If the row fails schema validation.

Examples:
>>> validate_vector_row({
...     "UUID": "uuid",
...     "BM25": {"terms": [], "weights": [], "avgdl": 1.0, "N": 1},
...     "SPLADEv3": {"tokens": [], "weights": []},
...     "Qwen3-4B": {"model_id": "model", "vector": [0.1], "dimension": 1},
... })
VectorRow(UUID='uuid', BM25=BM25Vector(terms=[], weights=[], k1=1.5, b=0.75, avgdl=1.0, N=1), SPLADEv3=SPLADEVector(model_id='naver/splade-v3', tokens=[], weights=[]), Qwen3_4B=DenseVector(model_id='model', vector=[0.1], dimension=1), model_metadata={}, schema_version='embeddings/1.0.0')

### `get_docling_version()`

Detect installed Docling package version.

Args:
None: This helper does not accept arguments.

Returns:
Version string or ``"unknown"`` when docling is not installed.

Examples:
>>> isinstance(get_docling_version(), str)
True

Raises:
None: This helper does not raise exceptions.

### `validate_schema_version(version, compatible_versions)`

Check if schema version is compatible.

Args:
version: Schema version string from JSONL row.
compatible_versions: List of accepted version identifiers.

Returns:
``True`` when the version is recognised, ``False`` otherwise.

Examples:
>>> validate_schema_version("docparse/1.1.0", COMPATIBLE_CHUNK_VERSIONS)
True

Raises:
None: This validator does not raise exceptions.

### `validate_parse_engine(cls, value)`

Ensure the parse engine identifier references a supported parser.

Args:
value: Candidate parse engine label provided in the payload.

Returns:
Validated parse engine string.

Raises:
ValueError: If the parser name is not recognised.

### `validate_num_tokens(cls, value)`

Ensure token counts fall within the supported range.

Args:
value: Token count supplied in the payload.

Returns:
Validated token count.

Raises:
ValueError: If the token count is non-positive or exceeds bounds.

### `validate_page_nos(cls, value)`

Normalise and validate page numbering information.

Args:
value: Sequence of 1-based page identifiers.

Returns:
Sorted, de-duplicated list of page numbers.

Raises:
ValueError: If any page number is non-positive.

### `validate_parallel_lists(self)`

Verify that token and weight collections are aligned.

Args:
self: Instance whose term and weight lists require validation.

Returns:
The validated BM25 vector instance.

Raises:
ValueError: If the vector and weight lengths differ.

### `validate_parallel_lists(self)`

Ensure token and weight arrays stay in lock-step.

Args:
self: Instance whose tokens and weights are being validated.

Returns:
The validated SPLADE vector instance.

Raises:
ValueError: If list lengths differ or weights are negative.

### `validate_vector(cls, value)`

Ensure the dense vector contains values to embed.

Args:
value: Collection of embedding coefficients.

Returns:
The validated embedding vector.

Raises:
ValueError: If the supplied vector is empty.

### `validate_dimension(self)`

Confirm the vector length matches the declared dimension.

Args:
self: Instance whose vector dimensionality is being verified.

Returns:
The validated dense vector instance.

Raises:
ValueError: If the actual length differs from ``dimension``.

## 2. Classes

### `ProvenanceMetadata`

Stores provenance metadata extracted during chunk parsing.

Attributes:
parse_engine: Parser identifier such as ``"docling-html"`` or ``"docling-vlm"``.
docling_version: Installed Docling package version string.
has_image_captions: Flag indicating whether caption text accompanies the chunk.
has_image_classification: Flag indicating whether image classification labels exist.
num_images: Count of images referenced by the chunk.

Examples:
>>> ProvenanceMetadata(parse_engine="docling-html", docling_version="1.2.3")
ProvenanceMetadata(parse_engine='docling-html', docling_version='1.2.3', has_image_captions=False, has_image_classification=False, num_images=0)

### `ChunkRow`

Schema for chunk JSONL rows describing processed document segments.

Attributes:
doc_id: Document identifier shared across chunk rows.
source_path: Path to the originating DocTags file.
chunk_id: Sequential chunk index within the document.
source_chunk_idxs: Original chunk indices prior to coalescence.
num_tokens: Token count for the chunk's text body.
text: Extracted text for the chunk.
doc_items_refs: References to downstream document item metadata.
page_nos: List of 1-based page numbers touched by the chunk.
schema_version: Version identifier for the chunk schema.
provenance: Optional provenance metadata describing parsing context.
uuid: Optional stable identifier for the chunk.

Examples:
>>> ChunkRow(
...     doc_id="doc-123",
...     source_path="/tmp/doc-123.doctags.json",
...     chunk_id=0,
...     source_chunk_idxs=[0],
...     num_tokens=42,
...     text="Sample chunk text.",
... )
ChunkRow(doc_id='doc-123', source_path='/tmp/doc-123.doctags.json', chunk_id=0, source_chunk_idxs=[0], num_tokens=42, text='Sample chunk text.', doc_items_refs=[], page_nos=[], schema_version='docparse/1.1.0', provenance=None, uuid=None)

### `BM25Vector`

Encapsulates BM25 sparse vector statistics for a chunk.

Attributes:
terms: Token vocabulary used in the sparse representation.
weights: BM25 weight assigned to each token.
k1: Tunable BM25 parameter controlling term frequency saturation.
b: Tunable BM25 parameter controlling length normalisation.
avgdl: Average document length across the source corpus.
N: Total document count in the source corpus.

Examples:
>>> BM25Vector(terms=["doc"], weights=[1.2], avgdl=100.0, N=10)
BM25Vector(terms=['doc'], weights=[1.2], k1=1.5, b=0.75, avgdl=100.0, N=10)

### `SPLADEVector`

Represents a SPLADE-v3 sparse activation vector.

Attributes:
model_id: Identifier of the SPLADE model that produced the vector.
tokens: Token vocabulary included in the activation map.
weights: Normalised activation weight for each token.

Examples:
>>> SPLADEVector(tokens=["term"], weights=[0.5])
SPLADEVector(model_id='naver/splade-v3', tokens=['term'], weights=[0.5])

### `DenseVector`

Stores dense embedding output from a neural encoder.

Attributes:
model_id: Identifier for the originating embedding model.
vector: Vector of numeric embedding values.
dimension: Expected dimensionality for the vector, if known.

Examples:
>>> DenseVector(model_id="encoder", vector=[0.1, 0.2], dimension=2)
DenseVector(model_id='encoder', vector=[0.1, 0.2], dimension=2)

### `VectorRow`

Schema for vector JSONL rows storing embedding artefacts.

Attributes:
UUID: Stable chunk identifier referenced by vector data.
BM25: Sparse BM25 representation for lexical retrieval.
SPLADEv3: SPLADE sparse activations supporting neural lexical search.
Qwen3_4B: Dense embedding produced by the Qwen3-4B encoder.
model_metadata: Additional metadata describing embedding provenance.
schema_version: Version identifier for the vector schema.

Examples:
>>> VectorRow(
...     UUID="chunk-1",
...     BM25={"terms": ["doc"], "weights": [1.0], "avgdl": 10.0, "N": 2},
...     SPLADEv3={"tokens": ["doc"], "weights": [0.1]},
...     Qwen3_4B={"model_id": "encoder", "vector": [0.1], "dimension": 1},
... )
VectorRow(UUID='chunk-1', BM25=BM25Vector(terms=['doc'], weights=[1.0], k1=1.5, b=0.75, avgdl=10.0, N=2), SPLADEv3=SPLADEVector(model_id='naver/splade-v3', tokens=['doc'], weights=[0.1]), Qwen3_4B=DenseVector(model_id='encoder', vector=[0.1], dimension=1), model_metadata={}, schema_version='embeddings/1.0.0')
