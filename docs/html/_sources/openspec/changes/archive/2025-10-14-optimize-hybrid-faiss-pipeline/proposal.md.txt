## Why

The current FAISS integration in `src/DocsToKG/HybridSearch` achieves functional correctness but leaves significant performance and maintenance wins on the table:

- `_create_index` manually constructs CPU indices, wires quantizers, and promotes to GPU, duplicating logic already encapsulated by FAISS factory strings and GPU-native constructors that ship with the wheel we vend (`docs/07-reference/faiss/FaissWheelReference.md`).
- IVF parameters such as `nprobe` are configurable in `DenseIndexConfig` yet never applied centrally, forcing downstream callers to remember to tune per query.
- The delete path is verbose (IDSelector Array + SWIG pointer plumbing) and hard to reason about, even though FAISS already exposes a simple `IDSelectorBatch` API.
- We serialize and maintain a parallel `_id_lookup` map despite the authoritative mapping living in `ChunkRegistry`; this adds payload bloat and drift risk.
- MMR diversification and near-duplicate filtering loop in Python/Numpy, performing per-candidate cosine computations rather than using FAISS’ GPU pairwise distance helpers.
- Sparse search implementations for BM25 and SPLADE duplicate filter/sort/paginate logic.

With chunking handled upstream via `DoclingHybridChunkerPipelineWithMin.py`, the hybrid module should focus on optimal FAISS usage and result shaping. The requested improvements reduce boilerplate, centralise tuning, and tap the GPU helpers that the bundled wheel already provides.

## What Changes

- Replace manual FAISS index construction with factory strings (`IVF{nlist},Flat`, `IVF{nlist},PQ…`) and GPU-native constructors (`GpuIndexFlatIP`) so build/promote occurs in ≤3 lines while keeping `IndexIDMap2` wrapping.
- Apply IVF tuning parameters (`nprobe`, later PQ knobs) through `faiss.GpuParameterSpace().set_index_parameter(...)`, falling back to `faiss.ParameterSpace` when GPU resources are absent, ensuring config changes take effect automatically.
- Simplify `_remove_ids` by switching to `faiss.IDSelectorBatch`, retaining the existing CPU fallback but removing SWIG pointer glue and consolidating ID bookkeeping.
- Move FAISS int→vector ID mapping into `ChunkRegistry` (bridge map) and update `FaissVectorStore` to consult the registry instead of persisting a second `_id_lookup`, shrinking serialized payloads and eliminating double accounting.
- Accelerate MMR diversification and near-duplicate checks by batching embeddings and using `faiss.pairwise_distance_gpu(..., METRIC_INNER_PRODUCT)` when GPU resources are available (with NumPy CPU fallback for test environments).
- DRY up sparse search in `OpenSearchSimulator` by introducing a shared `_search_sparse` helper invoked by both BM25 and SPLADE paths, leaving only the scoring lambda unique.
- Log the effective FAISS configuration (index type, `nlist`, `nprobe`, PQ parameters, GPU device) at startup so operational tooling can confirm tuning.
- Update associated tests/validators (if needed) to exercise the new pathways, ensure GPU helpers fall back gracefully in CPU-only unit tests, and exercise optional dataset-provided dense query vectors.
- Adjust developer documentation and helper CLI references now that the test runners live under `src/DocsToKG/HybridSearch/tools/`.

## Impact

- Affected specs: `hybrid-search`
- Affected code: `src/DocsToKG/HybridSearch/dense.py`, `src/DocsToKG/HybridSearch/ingest.py`, `src/DocsToKG/HybridSearch/retrieval.py`, `src/DocsToKG/HybridSearch/results.py`, `src/DocsToKG/HybridSearch/storage.py`, `src/DocsToKG/HybridSearch/validation.py`, and related tests/utilities under `tests/` that assert FAISS behaviour.
- No external API changes, but improved performance, maintainability, and determinism for FAISS-backed hybrid search.
