## ADDED Requirements

### Requirement: Unified HTTP Retry Infrastructure

The Content Download module SHALL provide centralized HTTP request handling with exponential backoff and `Retry-After` header compliance.

#### Scenario: Successful request with no retries

- **WHEN** a resolver requests a URL and receives HTTP 200 on first attempt
- **THEN** the request completes immediately without retry delays
- **AND** the response is returned to the caller

#### Scenario: Transient failure with exponential backoff

- **WHEN** a resolver requests a URL and receives HTTP 503 status code
- **AND** the service is configured to retry on 503
- **THEN** the request is retried with exponential backoff: `backoff_factor * (2 ** attempt) + jitter`
- **AND** a maximum of `max_retries` attempts are made before raising exception

#### Scenario: Retry-After header compliance (integer format)

- **WHEN** a resolver requests a URL and receives HTTP 429 with `Retry-After: 5` header
- **AND** `respect_retry_after=True` is configured
- **THEN** the system waits 5 seconds before retrying
- **AND** the wait time overrides default exponential backoff if longer

#### Scenario: Retry-After header compliance (HTTP-date format)

- **WHEN** a resolver requests a URL and receives HTTP 429 with `Retry-After: Wed, 21 Oct 2025 07:28:00 GMT` header
- **AND** `respect_retry_after=True` is configured
- **THEN** the system computes delta seconds until specified time
- **AND** waits the computed duration before retrying

#### Scenario: Custom retry status codes per resolver

- **WHEN** a resolver is configured with custom `retry_statuses={404, 429}`
- **AND** the resolver requests a URL receiving HTTP 404
- **THEN** the request is retried per configured backoff policy
- **AND** other status codes (e.g., 500) are NOT retried

#### Scenario: Exhausted retry attempts

- **WHEN** a resolver exhausts all retry attempts without success
- **THEN** the system raises `requests.RequestException` with details
- **AND** logs the final attempt status for observability

### Requirement: Conditional Request Abstraction

The Content Download module SHALL provide reusable conditional request logic encapsulating ETag and If-Modified-Since semantics.

#### Scenario: Building conditional headers from prior metadata

- **WHEN** a download has prior manifest entry with `etag="abc123"` and `last_modified="Mon, 01 Jan 2024 00:00:00 GMT"`
- **AND** a new request is initiated for the same URL
- **THEN** the system generates headers: `{"If-None-Match": "abc123", "If-Modified-Since": "Mon, 01 Jan 2024 00:00:00 GMT"}`
- **AND** includes these headers in the HTTP request

#### Scenario: HTTP 304 Not Modified response

- **WHEN** a conditional request receives HTTP 304 status code
- **AND** prior metadata includes `path`, `sha256`, and `content_length`
- **THEN** the system returns `CachedResult` with all prior metadata preserved
- **AND** no file download occurs (bandwidth saved)

#### Scenario: HTTP 200 Modified response

- **WHEN** a conditional request receives HTTP 200 status code
- **THEN** the system returns `ModifiedResult` with new `etag` and `last_modified` from response headers
- **AND** proceeds with full file download

#### Scenario: Incomplete prior metadata with 304 response

- **WHEN** a conditional request receives HTTP 304
- **AND** prior metadata is missing required fields (`sha256` or `content_length`)
- **THEN** the system raises `ValueError` indicating incomplete cache entry
- **AND** logs the error for debugging

### Requirement: Modular Resolver Architecture

The Content Download module SHALL organize resolver implementations into discrete provider modules enabling independent testing and extensibility.

#### Scenario: Backward-compatible imports after refactoring

- **WHEN** existing code imports `from DocsToKG.ContentDownload.pipeline import ResolverPipeline`
- **THEN** the import succeeds without modification
- **AND** the imported class maintains identical API behavior

#### Scenario: Direct submodule imports

- **WHEN** new code imports `from DocsToKG.ContentDownload.pipeline.pipeline import ResolverPipeline`
- **THEN** the import succeeds and provides identical functionality
- **AND** reduces coupling to internal module structure

#### Scenario: Individual resolver testing

- **WHEN** tests import a single resolver: `from DocsToKG.ContentDownload.pipeline.providers.unpaywall import UnpaywallResolver`
- **THEN** the resolver can be instantiated and tested in isolation
- **AND** no pipeline or other resolver dependencies are loaded

#### Scenario: Adding custom resolver provider

- **WHEN** a developer creates new file `resolvers/providers/custom.py` with `CustomResolver` class
- **AND** registers the resolver in `providers/__init__.py` default list
- **THEN** the resolver is included in pipeline execution
- **AND** respects standard configuration (timeouts, rate limits, toggles)

### Requirement: OpenAlex Virtual Resolver Integration

The Content Download module SHALL treat OpenAlex-provided URLs as a standard resolver (position 0) unifying rate-limiting, metrics, and logging.

#### Scenario: OpenAlex resolver executes first in pipeline

- **WHEN** a work has both OpenAlex `pdf_urls` and external resolver candidates
- **AND** the resolver pipeline begins execution
- **THEN** the OpenAlexResolver yields URLs before any other resolver
- **AND** early-stops on first PDF success per standard pipeline logic

#### Scenario: OpenAlex URLs respect rate limiting

- **WHEN** OpenAlexResolver is configured with `resolver_min_interval_s: {openalex: 0.5}`
- **AND** multiple works are processed sequentially
- **THEN** the system enforces 0.5-second minimum interval between OpenAlex URL attempts
- **AND** behaves identically to other resolver rate limits

#### Scenario: OpenAlex attempts tracked in unified metrics

- **WHEN** OpenAlexResolver successfully downloads a PDF
- **THEN** the attempt is recorded in `ResolverMetrics.attempts["openalex"]`
- **AND** success is recorded in `ResolverMetrics.successes["openalex"]`
- **AND** metrics are aggregated identically to other resolvers

#### Scenario: OpenAlex as optional resolver

- **WHEN** configuration specifies `resolver_toggles: {openalex: false}`
- **THEN** OpenAlexResolver is skipped in pipeline execution
- **AND** the pipeline proceeds to next enabled resolver (e.g., Unpaywall)

### Requirement: HEAD-Based Content Filtering

The Content Download module SHALL perform lightweight HEAD requests to filter non-PDF URLs before full download, reducing wasted bandwidth and attempts.

#### Scenario: HEAD request filters HTML landing page

- **WHEN** a resolver yields a candidate URL
- **AND** HEAD request returns `Content-Type: text/html`
- **AND** `enable_head_precheck=True` is configured
- **THEN** the system skips full GET request for this URL
- **AND** logs attempt with `reason="head-precheck-failed"`

#### Scenario: HEAD request filters zero-length content

- **WHEN** a resolver yields a candidate URL
- **AND** HEAD request returns `Content-Length: 0`
- **THEN** the system skips full GET request
- **AND** records skip in metrics as `"head-precheck-failed"`

#### Scenario: HEAD request allows PDF content

- **WHEN** a resolver yields a candidate URL
- **AND** HEAD request returns `Content-Type: application/pdf` and `Content-Length: 524288`
- **THEN** the system proceeds with full GET request
- **AND** no pre-check skip is logged

#### Scenario: HEAD request failure allows GET attempt

- **WHEN** HEAD request times out or returns 500 error
- **THEN** the system proceeds with GET request anyway (defensive fallback)
- **AND** does not mark URL as failed based solely on HEAD error

#### Scenario: Per-resolver HEAD pre-check override

- **WHEN** global configuration sets `enable_head_precheck=True`
- **AND** resolver-specific override sets `resolver_head_precheck: {wayback: false}`
- **AND** Wayback resolver yields a URL
- **THEN** the system skips HEAD pre-check for Wayback URLs only
- **AND** performs HEAD pre-check for other resolvers

#### Scenario: Disabled HEAD pre-check

- **WHEN** configuration sets `enable_head_precheck=False`
- **THEN** the system never performs HEAD requests
- **AND** all candidate URLs proceed directly to GET

### Requirement: Bounded Intra-Work Concurrency

The Content Download module SHALL support concurrent execution of independent resolvers within a single work to reduce wall time while respecting per-resolver rate limits.

#### Scenario: Sequential execution (default)

- **WHEN** configuration sets `max_concurrent_resolvers=1`
- **THEN** resolvers execute sequentially in priority order
- **AND** the next resolver starts only after the previous completes
- **AND** behavior matches original sequential pipeline

#### Scenario: Bounded concurrent execution

- **WHEN** configuration sets `max_concurrent_resolvers=3`
- **AND** 10 enabled resolvers exist for a work
- **THEN** the system executes up to 3 resolvers concurrently
- **AND** queues remaining resolvers until a worker becomes available

#### Scenario: Rate limits enforced during concurrency

- **WHEN** configuration sets `max_concurrent_resolvers=3` and `resolver_min_interval_s: {unpaywall: 1.0}`
- **AND** Unpaywall resolver is invoked concurrently with others
- **THEN** the system enforces 1.0-second minimum interval between Unpaywall requests across all threads
- **AND** uses thread-safe lock to coordinate rate limit tracking

#### Scenario: Early-stop on first PDF during concurrent execution

- **WHEN** 3 resolvers execute concurrently for a work
- **AND** resolver 2 successfully downloads a PDF
- **THEN** the pipeline immediately returns success result
- **AND** cancels remaining queued and in-progress resolvers
- **AND** no additional download attempts occur

#### Scenario: Resolver failure doesn't block concurrent execution

- **WHEN** 3 resolvers execute concurrently
- **AND** resolver 1 raises an exception
- **THEN** the exception is logged but not propagated
- **AND** resolvers 2 and 3 continue execution
- **AND** the pipeline proceeds to next queued resolvers

#### Scenario: Thread-safe metrics aggregation

- **WHEN** multiple resolvers execute concurrently
- **AND** each records attempts and successes in `ResolverMetrics`
- **THEN** all metrics are aggregated without race conditions
- **AND** final counts match total attempts across all threads

### Requirement: Zenodo Resolver

The Content Download module SHALL query the Zenodo REST API by DOI to retrieve PDF files hosted in the Zenodo open repository.

#### Scenario: Successful Zenodo DOI query

- **WHEN** an artifact has DOI "10.5281/zenodo.1234567"
- **AND** Zenodo API returns matching record with PDF file
- **THEN** ZenodoResolver yields PDF download URL from `files[*].links.self`
- **AND** includes metadata: `{"source": "zenodo", "record_id": "1234567", "filename": "paper.pdf"}`

#### Scenario: Zenodo query with multiple files filters to PDF

- **WHEN** Zenodo API returns record with files: `["data.csv", "paper.pdf", "figures.zip"]`
- **THEN** ZenodoResolver yields only `paper.pdf` download URL
- **AND** skips non-PDF files

#### Scenario: Zenodo query with no matching records

- **WHEN** Zenodo API returns empty `hits.hits` array
- **THEN** ZenodoResolver yields no URLs
- **AND** logs event with `event_reason="no-matches"`

#### Scenario: Zenodo API HTTP error

- **WHEN** Zenodo API returns HTTP 404 or 500
- **THEN** ZenodoResolver logs error event with status code
- **AND** yields no URLs (resolver skipped)

#### Scenario: Zenodo resolver priority

- **WHEN** default resolver order is configured
- **THEN** ZenodoResolver executes after CoreResolver
- **AND** executes before DoajResolver

### Requirement: Figshare Resolver

The Content Download module SHALL query the Figshare REST API by DOI to retrieve PDF files hosted in the Figshare repository.

#### Scenario: Successful Figshare DOI search

- **WHEN** an artifact has DOI "10.6084/m9.figshare.1234567"
- **AND** Figshare API returns matching article with PDF file
- **THEN** FigshareResolver yields PDF download URL from `files[*].download_url`
- **AND** includes metadata: `{"source": "figshare", "article_id": "1234567", "filename": "manuscript.pdf"}`

#### Scenario: Figshare search with multiple files filters to PDF

- **WHEN** Figshare API returns article with files: `["dataset.csv", "manuscript.pdf", "supplement.docx"]`
- **THEN** FigshareResolver yields only `manuscript.pdf` download URL
- **AND** filters by `.pdf` extension

#### Scenario: Figshare search with no results

- **WHEN** Figshare API returns empty articles array
- **THEN** FigshareResolver yields no URLs
- **AND** does not log error (valid empty result)

#### Scenario: Figshare API HTTP error

- **WHEN** Figshare API returns HTTP 401 or 503
- **THEN** FigshareResolver logs error event with status code
- **AND** yields no URLs

#### Scenario: Figshare resolver priority

- **WHEN** default resolver order is configured
- **THEN** FigshareResolver executes after ZenodoResolver
- **AND** executes before DoajResolver

### Requirement: Complete Download Outcome Metadata

The Content Download module SHALL populate all metadata fields in `DownloadOutcome` across every code path for uniform manifest schema.

#### Scenario: Successful PDF download populates all fields

- **WHEN** a PDF is successfully downloaded and verified
- **THEN** `DownloadOutcome` includes: `classification="pdf"`, `path`, `http_status=200`, `content_type`, `elapsed_ms`, `sha256`, `content_length`, `etag`, `last_modified`
- **AND** no fields are omitted or undefined

#### Scenario: Cached 304 response preserves prior metadata

- **WHEN** HTTP 304 Not Modified is received
- **THEN** `DownloadOutcome` includes: `classification="cached"`, prior `path`, `sha256`, `content_length`, `etag`, `last_modified`
- **AND** all prior metadata is preserved in outcome

#### Scenario: HTML download with text extraction

- **WHEN** HTML content is downloaded and trafilatura extraction succeeds
- **THEN** `DownloadOutcome` includes: `classification="html"`, `path` (HTML file), `extracted_text_path` (TXT file), `sha256`, `content_length`
- **AND** both HTML and extracted text paths are populated

#### Scenario: HTTP error populates explicit None values

- **WHEN** download fails with HTTP 404 or network error
- **THEN** `DownloadOutcome` includes: `classification="http_error"`, `path=None`, `sha256=None`, `content_length=None`, `etag=None`, `last_modified=None`, `error` (message)
- **AND** missing fields are explicitly `None` rather than omitted

#### Scenario: Dry-run mode populates available metadata

- **WHEN** download runs in `--dry-run` mode
- **AND** HEAD request returns `ETag` and `Last-Modified` headers
- **THEN** `DownloadOutcome` includes: classification, `etag`, `last_modified`, `path=None`, `sha256=None`
- **AND** unavailable fields (sha256, path) are explicitly `None`

### Requirement: Resolver Wall Time Observability

The Content Download module SHALL track and log total wall time spent in each resolver including rate-limit waits for performance analysis.

#### Scenario: Resolver wall time includes rate-limit delays

- **WHEN** a resolver is rate-limited and waits 1.0 seconds before making request
- **AND** the HTTP request takes 0.5 seconds
- **THEN** `AttemptRecord.resolver_wall_time_ms` is approximately 1500ms
- **AND** `AttemptRecord.elapsed_ms` is approximately 500ms (HTTP only)

#### Scenario: Resolver wall time in JSONL logs

- **WHEN** an attempt is logged to JSONL
- **THEN** the log entry includes field: `"resolver_wall_time_ms": 1523.4`
- **AND** field is present for all resolver attempts

#### Scenario: Resolver wall time in CSV logs

- **WHEN** CSV logging is enabled
- **THEN** CSV header includes column `resolver_wall_time_ms`
- **AND** each row populates the column with timing data

### Requirement: Configuration Schema Extensions

The Content Download module SHALL support new configuration options for advanced features while maintaining backward compatibility.

#### Scenario: HEAD pre-check configuration

- **WHEN** configuration file includes:

  ```yaml
  enable_head_precheck: true
  resolver_head_precheck:
    wayback: false
  ```

- **THEN** the system performs HEAD checks for all resolvers except Wayback
- **AND** default remains `true` if not specified

#### Scenario: Bounded concurrency configuration

- **WHEN** configuration file includes:

  ```yaml
  max_concurrent_resolvers: 3
  ```

- **THEN** the system executes up to 3 resolvers concurrently within a work
- **AND** default remains `1` (sequential) if not specified

#### Scenario: Invalid concurrency value validation

- **WHEN** configuration specifies `max_concurrent_resolvers: 0`
- **THEN** the system raises `ValueError` during config initialization
- **AND** provides helpful error message

#### Scenario: Backward compatibility with existing configs

- **WHEN** an existing configuration file lacks new fields
- **THEN** the system applies default values for all new options
- **AND** no configuration migration is required

### Requirement: Developer Documentation for Custom Resolvers

The Content Download module SHALL provide comprehensive documentation and templates enabling developers to add custom resolver providers.

#### Scenario: Resolver template availability

- **WHEN** a developer reads `docs/adding-custom-resolvers.md`
- **THEN** the document includes complete resolver class template
- **AND** includes registration instructions for `providers/__init__.py`

#### Scenario: Custom resolver follows protocol

- **WHEN** a custom resolver implements `name`, `is_enabled()`, and `iter_urls()` methods
- **AND** is registered in default resolver list
- **THEN** the resolver executes in pipeline with standard error handling
- **AND** respects configuration (timeouts, rate limits, toggles)

#### Scenario: Custom resolver configuration

- **WHEN** a custom resolver named `"custom"` is added
- **THEN** standard configuration applies:

  ```yaml
  resolver_toggles:
    custom: true
  resolver_min_interval_s:
    custom: 0.5
  resolver_timeouts:
    custom: 15.0
  ```

- **AND** no code changes needed for configuration support
