

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>1. Module: ontology_download &mdash; DocsToKG 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/css/custom.css" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=8d563738"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            DocsToKG
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../01-overview/index.html">1. Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02-setup/index.html">1. Setup Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03-architecture/index.html">1. Architecture Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html">1. API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05-development/index.html">1. Development Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06-operations/index.html">1. Operations Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07-reference/index.html">1. Technical Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">DocsToKG</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">1. Module: ontology_download</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/04-api/DocsToKG.OntologyDownload.ontology_download.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-ontology-download">
<h1>1. Module: ontology_download<a class="headerlink" href="#module-ontology-download" title="Link to this heading"></a></h1>
<p>This reference documents the DocsToKG module <code class="docutils literal notranslate"><span class="pre">DocsToKG.OntologyDownload.ontology_download</span></code>.</p>
<section id="overview">
<h2>1. Overview<a class="headerlink" href="#overview" title="Link to this heading"></a></h2>
<p>Unified ontology downloader orchestrating settings, retries, and logging.</p>
</section>
<section id="functions">
<h2>2. Functions<a class="headerlink" href="#functions" title="Link to this heading"></a></h2>
<section id="retry-with-backoff-func">
<h3><code class="docutils literal notranslate"><span class="pre">retry_with_backoff(func)</span></code><a class="headerlink" href="#retry-with-backoff-func" title="Link to this heading"></a></h3>
<p>Execute <code class="docutils literal notranslate"><span class="pre">func</span></code> with exponential backoff until it succeeds.</p>
<p>Args:
func: Zero-argument callable to invoke.
retryable: Predicate returning <code class="docutils literal notranslate"><span class="pre">True</span></code> when the raised exception should
trigger another attempt.
max_attempts: Maximum number of attempts including the initial call.
backoff_base: Base delay in seconds used for the exponential schedule.
jitter: Maximum random jitter (uniform) added to each delay.
callback: Optional hook invoked before sleeping with
<code class="docutils literal notranslate"><span class="pre">(attempt_number,</span> <span class="pre">error,</span> <span class="pre">delay_seconds)</span></code>.
sleep: Sleep function, overridable for deterministic tests.</p>
<p>Returns:
The result produced by <code class="docutils literal notranslate"><span class="pre">func</span></code> when it succeeds.</p>
<p>Raises:
ValueError: If <code class="docutils literal notranslate"><span class="pre">max_attempts</span></code> is less than one.
BaseException: Re-raises the last exception from <code class="docutils literal notranslate"><span class="pre">func</span></code> when retries
are exhausted or the predicate indicates it is not retryable.</p>
</section>
<section id="sanitize-filename-filename">
<h3><code class="docutils literal notranslate"><span class="pre">sanitize_filename(filename)</span></code><a class="headerlink" href="#sanitize-filename-filename" title="Link to this heading"></a></h3>
<p>Sanitize filenames to prevent directory traversal and unsafe characters.</p>
<p>Args:
filename: Candidate filename provided by an upstream service.</p>
<p>Returns:
Safe filename compatible with local filesystem storage.</p>
</section>
<section id="generate-correlation-id">
<h3><code class="docutils literal notranslate"><span class="pre">generate_correlation_id()</span></code><a class="headerlink" href="#generate-correlation-id" title="Link to this heading"></a></h3>
<p>Create a short-lived identifier that links related log entries.</p>
<p>Args:
None.</p>
<p>Returns:
Twelve-character hexadecimal correlation identifier.</p>
<p>Raises:
None.</p>
</section>
<section id="mask-sensitive-data-payload">
<h3><code class="docutils literal notranslate"><span class="pre">mask_sensitive_data(payload)</span></code><a class="headerlink" href="#mask-sensitive-data-payload" title="Link to this heading"></a></h3>
<p>Remove secrets from structured payloads prior to logging.</p>
<p>Args:
payload: Structured data that may contain sensitive values.</p>
<p>Returns:
Copy of <code class="docutils literal notranslate"><span class="pre">payload</span></code> with common secret fields masked.</p>
</section>
<section id="ensure-python-version">
<h3><code class="docutils literal notranslate"><span class="pre">ensure_python_version()</span></code><a class="headerlink" href="#ensure-python-version" title="Link to this heading"></a></h3>
<p>Ensure the interpreter meets the minimum supported Python version.</p>
<p>Args:
None.</p>
<p>Returns:
None.</p>
<p>Raises:
SystemExit: If the current interpreter version is below the minimum.</p>
</section>
<section id="coerce-sequence-value">
<h3><code class="docutils literal notranslate"><span class="pre">_coerce_sequence(value)</span></code><a class="headerlink" href="#coerce-sequence-value" title="Link to this heading"></a></h3>
<p>Normalize configuration entries into a list of strings.</p>
<p>Args:
value: Input value that may be <code class="docutils literal notranslate"><span class="pre">None</span></code>, a string, or an iterable of strings.</p>
<p>Returns:
List of strings suitable for downstream configuration processing.</p>
</section>
<section id="parse-rate-limit-to-rps-limit-str">
<h3><code class="docutils literal notranslate"><span class="pre">parse_rate_limit_to_rps(limit_str)</span></code><a class="headerlink" href="#parse-rate-limit-to-rps-limit-str" title="Link to this heading"></a></h3>
<p>Convert a rate limit expression into requests-per-second.</p>
<p>The accepted format is <code class="docutils literal notranslate"><span class="pre">&lt;value&gt;/&lt;unit&gt;</span></code> where <code class="docutils literal notranslate"><span class="pre">unit</span></code> is one of
<code class="docutils literal notranslate"><span class="pre">second</span></code>, <code class="docutils literal notranslate"><span class="pre">minute</span></code>, or <code class="docutils literal notranslate"><span class="pre">hour</span></code> (including short aliases such as <code class="docutils literal notranslate"><span class="pre">s</span></code>
or <code class="docutils literal notranslate"><span class="pre">min</span></code>). The function returns <code class="docutils literal notranslate"><span class="pre">None</span></code> when the value cannot be parsed.</p>
<p>Args:
limit_str: Rate limit expression in <code class="docutils literal notranslate"><span class="pre">value/unit</span></code> form.</p>
<p>Returns:
Optional[float]: Requests-per-second value when parsing succeeds.</p>
<p>Raises:
ValueError: If the numeric component cannot be converted to <code class="docutils literal notranslate"><span class="pre">float</span></code>.</p>
</section>
<section id="get-env-overrides">
<h3><code class="docutils literal notranslate"><span class="pre">get_env_overrides()</span></code><a class="headerlink" href="#get-env-overrides" title="Link to this heading"></a></h3>
<p>Return raw environment override values for backwards compatibility.</p>
<p>Args:
None</p>
<p>Returns:
Mapping of configuration field name to override value sourced from the environment.</p>
</section>
<section id="apply-env-overrides-defaults">
<h3><code class="docutils literal notranslate"><span class="pre">_apply_env_overrides(defaults)</span></code><a class="headerlink" href="#apply-env-overrides-defaults" title="Link to this heading"></a></h3>
<p>Apply environment variable overrides to default configuration.</p>
<p>Args:
defaults: Defaults configuration object that will be mutated in place.</p>
<p>Returns:
None</p>
</section>
<section id="make-fetch-spec-ontology-id-resolver-extras-target-formats">
<h3><code class="docutils literal notranslate"><span class="pre">_make_fetch_spec(ontology_id,</span> <span class="pre">resolver,</span> <span class="pre">extras,</span> <span class="pre">target_formats)</span></code><a class="headerlink" href="#make-fetch-spec-ontology-id-resolver-extras-target-formats" title="Link to this heading"></a></h3>
<p>Instantiate a FetchSpec from raw YAML fields.</p>
<p>Args:
ontology_id: Identifier of the ontology being configured.
resolver: Name of the resolver responsible for fetching content.
extras: Additional resolver-specific configuration parameters.
target_formats: Desired output formats for the ontology artefact.</p>
<p>Returns:
Fully initialised <code class="docutils literal notranslate"><span class="pre">FetchSpec</span></code> object ready for execution.</p>
</section>
<section id="merge-defaults-ontology-spec-defaults">
<h3><code class="docutils literal notranslate"><span class="pre">merge_defaults(ontology_spec,</span> <span class="pre">defaults)</span></code><a class="headerlink" href="#merge-defaults-ontology-spec-defaults" title="Link to this heading"></a></h3>
<p>Merge an ontology specification with resolved default settings.</p>
<p>Args:
ontology_spec: Raw ontology specification mapping loaded from YAML.
defaults: Optional resolved defaults to merge with the specification.</p>
<p>Returns:
FetchSpec instance describing the fully-merged ontology configuration.</p>
<p>Raises:
ConfigError: If required fields are missing or invalid in the specification.</p>
</section>
<section id="build-resolved-config-raw-config">
<h3><code class="docutils literal notranslate"><span class="pre">build_resolved_config(raw_config)</span></code><a class="headerlink" href="#build-resolved-config-raw-config" title="Link to this heading"></a></h3>
<p>Construct fully-resolved configuration from raw YAML contents.</p>
<p>Args:
raw_config: Parsed YAML mapping defining defaults and ontologies.</p>
<p>Returns:
ResolvedConfig combining defaults and individual fetch specifications.</p>
<p>Raises:
ConfigError: If validation fails or required sections are missing.</p>
</section>
<section id="validate-schema-raw-config">
<h3><code class="docutils literal notranslate"><span class="pre">_validate_schema(raw,</span> <span class="pre">config)</span></code><a class="headerlink" href="#validate-schema-raw-config" title="Link to this heading"></a></h3>
<p>Perform additional structural validation beyond Pydantic models.</p>
<p>Args:
raw: Raw configuration mapping used for structural checks.
config: Optional resolved configuration for cross-field validation.</p>
<p>Raises:
ConfigError: When structural constraints are violated.</p>
</section>
<section id="load-raw-yaml-config-path">
<h3><code class="docutils literal notranslate"><span class="pre">load_raw_yaml(config_path)</span></code><a class="headerlink" href="#load-raw-yaml-config-path" title="Link to this heading"></a></h3>
<p>Load and parse a YAML configuration file into a mutable mapping.</p>
<p>Args:
config_path: Path to the YAML configuration file.</p>
<p>Returns:
Mutable mapping representation of the YAML content.</p>
<p>Raises:
SystemExit: If the file is not found on disk.
ConfigError: If the YAML cannot be parsed or is structurally invalid.</p>
</section>
<section id="load-config-config-path">
<h3><code class="docutils literal notranslate"><span class="pre">load_config(config_path)</span></code><a class="headerlink" href="#load-config-config-path" title="Link to this heading"></a></h3>
<p>Load configuration from disk without performing additional schema validation.</p>
<p>Args:
config_path: Path to the YAML configuration file.</p>
<p>Returns:
ResolvedConfig produced from the raw file contents.</p>
<p>Raises:
ConfigError: If the configuration cannot be parsed or validated.</p>
</section>
<section id="validate-config-config-path">
<h3><code class="docutils literal notranslate"><span class="pre">validate_config(config_path)</span></code><a class="headerlink" href="#validate-config-config-path" title="Link to this heading"></a></h3>
<p>Validate a configuration file and return the resolved settings.</p>
<p>Args:
config_path: Path to the YAML configuration file.</p>
<p>Returns:
ResolvedConfig object after validation.</p>
<p>Raises:
ConfigError: If validation fails.</p>
</section>
<section id="compress-old-log-path">
<h3><code class="docutils literal notranslate"><span class="pre">_compress_old_log(path)</span></code><a class="headerlink" href="#compress-old-log-path" title="Link to this heading"></a></h3>
<p>Compress a log file in-place using gzip to reclaim disk space.</p>
<p>Args:
path: Filesystem location of the log file to compress.</p>
</section>
<section id="cleanup-logs-log-dir-retention-days">
<h3><code class="docutils literal notranslate"><span class="pre">_cleanup_logs(log_dir,</span> <span class="pre">retention_days)</span></code><a class="headerlink" href="#cleanup-logs-log-dir-retention-days" title="Link to this heading"></a></h3>
<p>Apply rotation and retention policy to the log directory.</p>
<p>Args:
log_dir: Directory that stores structured log files.
retention_days: Number of days to keep uncompressed log files.</p>
</section>
<section id="setup-logging">
<h3><code class="docutils literal notranslate"><span class="pre">setup_logging()</span></code><a class="headerlink" href="#setup-logging" title="Link to this heading"></a></h3>
<p>Configure structured logging handlers for ontology downloads.</p>
<p>Args:
level: Logging level applied to the ontology downloader logger.
retention_days: Number of days to retain uncompressed log files before archival.
max_log_size_mb: Maximum size of each log file before rotation occurs.
log_dir: Optional override for the log directory; falls back to defaults when omitted.</p>
<p>Returns:
Logger instance configured with console and rotating JSON handlers.</p>
</section>
<section id="create-stub-module-name-attrs">
<h3><code class="docutils literal notranslate"><span class="pre">_create_stub_module(name,</span> <span class="pre">attrs)</span></code><a class="headerlink" href="#create-stub-module-name-attrs" title="Link to this heading"></a></h3>
<p>Create a stub module populated with the provided attributes.</p>
<p>Args:
name: Dotted module path that should appear in :data:<code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>.
attrs: Mapping of attribute names to objects exposed by the stub.</p>
<p>Returns:
Module instance that mimics the requested package for test isolation.</p>
</section>
<section id="create-stub-bnode-value">
<h3><code class="docutils literal notranslate"><span class="pre">_create_stub_bnode(value)</span></code><a class="headerlink" href="#create-stub-bnode-value" title="Link to this heading"></a></h3>
<p>Create a deterministic blank node identifier for rdflib stubs.</p>
<p>Args:
value: Optional explicit identifier to reuse instead of auto-incrementing.</p>
<p>Returns:
RDF blank node identifier anchored by the <code class="docutils literal notranslate"><span class="pre">_:</span></code> prefix.</p>
</section>
<section id="create-stub-literal-value">
<h3><code class="docutils literal notranslate"><span class="pre">_create_stub_literal(value)</span></code><a class="headerlink" href="#create-stub-literal-value" title="Link to this heading"></a></h3>
<p>Represent literals as simple string values for stub graphs.</p>
<p>Args:
value: Python value to coerce into an rdflib-style literal.</p>
<p>Returns:
String literal representation suitable for Turtle serialization.</p>
</section>
<section id="create-stub-uri-value">
<h3><code class="docutils literal notranslate"><span class="pre">_create_stub_uri(value)</span></code><a class="headerlink" href="#create-stub-uri-value" title="Link to this heading"></a></h3>
<p>Create a URI reference that matches rdflib serialization expectations.</p>
<p>Args:
value: URI string, optionally already wrapped in angle brackets.</p>
<p>Returns:
URI reference wrapped in angle brackets for Turtle compatibility.</p>
</section>
<section id="import-module-name">
<h3><code class="docutils literal notranslate"><span class="pre">_import_module(name)</span></code><a class="headerlink" href="#import-module-name" title="Link to this heading"></a></h3>
<p>Import a module by name using :mod:<code class="docutils literal notranslate"><span class="pre">importlib</span></code>.</p>
<p>The indirection makes it trivial to monkeypatch the import logic in unit
tests without modifying global interpreter state.</p>
<p>Args:
name: Fully qualified module name to load.</p>
<p>Returns:
Imported module, falling back to the real implementation when present.</p>
<p>Raises:
ModuleNotFoundError: If the module cannot be located.</p>
</section>
<section id="create-pystow-stub-root">
<h3><code class="docutils literal notranslate"><span class="pre">_create_pystow_stub(root)</span></code><a class="headerlink" href="#create-pystow-stub-root" title="Link to this heading"></a></h3>
<p>Return a stub module implementing <code class="docutils literal notranslate"><span class="pre">join</span></code> similar to pystow.</p>
<p>Args:
root: Filesystem directory that acts as the backing storage root.</p>
<p>Returns:
Module object exposing a <code class="docutils literal notranslate"><span class="pre">join</span></code> helper compatible with pystow usage.</p>
</section>
<section id="create-rdflib-stub">
<h3><code class="docutils literal notranslate"><span class="pre">_create_rdflib_stub()</span></code><a class="headerlink" href="#create-rdflib-stub" title="Link to this heading"></a></h3>
<p>Create a stub implementation compatible with rdflib usage in tests.</p>
<p>Returns:
Module object that mirrors the small subset of rdflib used by validators.</p>
</section>
<section id="create-pronto-stub">
<h3><code class="docutils literal notranslate"><span class="pre">_create_pronto_stub()</span></code><a class="headerlink" href="#create-pronto-stub" title="Link to this heading"></a></h3>
<p>Create a stub module mimicking pronto interfaces.</p>
<p>Returns:
Module object exposing a lightweight :class:<code class="docutils literal notranslate"><span class="pre">Ontology</span></code> implementation.</p>
</section>
<section id="create-owlready-stub">
<h3><code class="docutils literal notranslate"><span class="pre">_create_owlready_stub()</span></code><a class="headerlink" href="#create-owlready-stub" title="Link to this heading"></a></h3>
<p>Create a stub module mimicking owlready2 key behaviour.</p>
<p>Returns:
Module object providing <code class="docutils literal notranslate"><span class="pre">get_ontology</span></code> compatible with owlready2.</p>
</section>
<section id="get-pystow">
<h3><code class="docutils literal notranslate"><span class="pre">get_pystow()</span></code><a class="headerlink" href="#get-pystow" title="Link to this heading"></a></h3>
<p>Return the real :mod:<code class="docutils literal notranslate"><span class="pre">pystow</span></code> module or a fallback stub.</p>
<p>Args:
None.</p>
<p>Returns:
Real pystow module when installed, otherwise a deterministic stub.</p>
</section>
<section id="get-rdflib">
<h3><code class="docutils literal notranslate"><span class="pre">get_rdflib()</span></code><a class="headerlink" href="#get-rdflib" title="Link to this heading"></a></h3>
<p>Return :mod:<code class="docutils literal notranslate"><span class="pre">rdflib</span></code> or a stub supporting limited graph operations.</p>
<p>Args:
None.</p>
<p>Returns:
Real rdflib module when available, else a stub graph implementation.</p>
</section>
<section id="get-pronto">
<h3><code class="docutils literal notranslate"><span class="pre">get_pronto()</span></code><a class="headerlink" href="#get-pronto" title="Link to this heading"></a></h3>
<p>Return :mod:<code class="docutils literal notranslate"><span class="pre">pronto</span></code> or a stub with minimal ontology behaviour.</p>
<p>Args:
None.</p>
<p>Returns:
Real pronto module when installed, else a stub ontology wrapper.</p>
</section>
<section id="get-owlready2">
<h3><code class="docutils literal notranslate"><span class="pre">get_owlready2()</span></code><a class="headerlink" href="#get-owlready2" title="Link to this heading"></a></h3>
<p>Return :mod:<code class="docutils literal notranslate"><span class="pre">owlready2</span></code> or a stub matching the API used in validators.</p>
<p>Args:
None.</p>
<p>Returns:
Real owlready2 module when available, else a limited stub replacement.</p>
</section>
<section id="safe-identifiers-ontology-id-version">
<h3><code class="docutils literal notranslate"><span class="pre">_safe_identifiers(ontology_id,</span> <span class="pre">version)</span></code><a class="headerlink" href="#safe-identifiers-ontology-id-version" title="Link to this heading"></a></h3>
<p>Return identifiers sanitized for filesystem usage.</p>
<p>Args:
ontology_id: Raw ontology identifier that may contain unsafe characters.
version: Version label that should be filesystem-friendly.</p>
<p>Returns:
Tuple <code class="docutils literal notranslate"><span class="pre">(safe_id,</span> <span class="pre">safe_version)</span></code> containing sanitised values.</p>
</section>
<section id="directory-size-path">
<h3><code class="docutils literal notranslate"><span class="pre">_directory_size(path)</span></code><a class="headerlink" href="#directory-size-path" title="Link to this heading"></a></h3>
<p>Return the total size in bytes for all regular files under <code class="docutils literal notranslate"><span class="pre">path</span></code>.</p>
<p>Args:
path: Root directory whose files should be measured.</p>
<p>Returns:
Cumulative size in bytes of every regular file within <code class="docutils literal notranslate"><span class="pre">path</span></code>.</p>
</section>
<section id="get-storage-backend">
<h3><code class="docutils literal notranslate"><span class="pre">get_storage_backend()</span></code><a class="headerlink" href="#get-storage-backend" title="Link to this heading"></a></h3>
<p>Instantiate the storage backend based on environment configuration.</p>
<p>Args:
None.</p>
<p>Returns:
Storage backend instance selected according to <code class="docutils literal notranslate"><span class="pre">ONTOFETCH_STORAGE_URL</span></code>.</p>
</section>
<section id="log-download-memory-logger-event">
<h3><code class="docutils literal notranslate"><span class="pre">_log_download_memory(logger,</span> <span class="pre">event)</span></code><a class="headerlink" href="#log-download-memory-logger-event" title="Link to this heading"></a></h3>
<p>Emit debug-level memory usage snapshots when enabled.</p>
<p>Args:
logger: Logger instance controlling verbosity for download telemetry.
event: Short label describing the lifecycle point (e.g., <code class="docutils literal notranslate"><span class="pre">before</span></code>).</p>
<p>Returns:
None</p>
</section>
<section id="is-retryable-status-status-code">
<h3><code class="docutils literal notranslate"><span class="pre">_is_retryable_status(status_code)</span></code><a class="headerlink" href="#is-retryable-status-status-code" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="enforce-idn-safety-host">
<h3><code class="docutils literal notranslate"><span class="pre">_enforce_idn_safety(host)</span></code><a class="headerlink" href="#enforce-idn-safety-host" title="Link to this heading"></a></h3>
<p>Validate internationalized hostnames and reject suspicious patterns.</p>
<p>Args:
host: Hostname component extracted from the download URL.</p>
<p>Returns:
None</p>
<p>Raises:
ConfigError: If the hostname mixes multiple scripts or contains invisible characters.</p>
</section>
<section id="rebuild-netloc-parsed-ascii-host">
<h3><code class="docutils literal notranslate"><span class="pre">_rebuild_netloc(parsed,</span> <span class="pre">ascii_host)</span></code><a class="headerlink" href="#rebuild-netloc-parsed-ascii-host" title="Link to this heading"></a></h3>
<p>Reconstruct URL netloc with a normalized hostname.</p>
<p>Args:
parsed: Parsed URL components produced by :func:<code class="docutils literal notranslate"><span class="pre">urllib.parse.urlparse</span></code>.
ascii_host: ASCII-normalized hostname (potentially IPv6).</p>
<p>Returns:
String suitable for use as the netloc portion of a URL.</p>
</section>
<section id="validate-url-security-url-http-config">
<h3><code class="docutils literal notranslate"><span class="pre">validate_url_security(url,</span> <span class="pre">http_config)</span></code><a class="headerlink" href="#validate-url-security-url-http-config" title="Link to this heading"></a></h3>
<p>Validate URLs to avoid SSRF, enforce HTTPS, normalize IDNs, and honor host allowlists.</p>
<p>Hostnames are converted to punycode before resolution, and both direct IP
addresses and DNS results are rejected when they target private or loopback
ranges to prevent server-side request forgery.</p>
<p>Args:
url: URL returned by a resolver for ontology download.
http_config: Download configuration providing optional host allowlist.</p>
<p>Returns:
HTTPS URL safe for downstream download operations.</p>
<p>Raises:
ConfigError: If the URL violates security requirements or allowlists.</p>
</section>
<section id="sha256-file-path">
<h3><code class="docutils literal notranslate"><span class="pre">sha256_file(path)</span></code><a class="headerlink" href="#sha256-file-path" title="Link to this heading"></a></h3>
<p>Compute the SHA-256 digest for the provided file.</p>
<p>Args:
path: Path to the file whose digest should be calculated.</p>
<p>Returns:
Hexadecimal SHA-256 checksum string.</p>
</section>
<section id="validate-member-path-member-name">
<h3><code class="docutils literal notranslate"><span class="pre">_validate_member_path(member_name)</span></code><a class="headerlink" href="#validate-member-path-member-name" title="Link to this heading"></a></h3>
<p>Validate archive member paths to prevent traversal attacks.</p>
<p>Args:
member_name: Path declared within the archive.</p>
<p>Returns:
Sanitised relative path safe for extraction on the local filesystem.</p>
<p>Raises:
ConfigError: If the member path is absolute or contains traversal segments.</p>
</section>
<section id="check-compression-ratio">
<h3><code class="docutils literal notranslate"><span class="pre">_check_compression_ratio()</span></code><a class="headerlink" href="#check-compression-ratio" title="Link to this heading"></a></h3>
<p>Ensure compressed archives do not expand beyond the permitted ratio.</p>
<p>Args:
total_uncompressed: Sum of file sizes within the archive.
compressed_size: Archive file size on disk (or sum of compressed entries).
archive: Path to the archive on disk.
logger: Optional logger for emitting diagnostic messages.
archive_type: Human readable label for error messages (ZIP/TAR).</p>
<p>Raises:
ConfigError: If the archive exceeds the allowed expansion ratio.</p>
</section>
<section id="is-zip-symlink-info">
<h3><code class="docutils literal notranslate"><span class="pre">_is_zip_symlink(info)</span></code><a class="headerlink" href="#is-zip-symlink-info" title="Link to this heading"></a></h3>
<p>Return True when a ZIP member encodes a symbolic link.</p>
</section>
<section id="extract-zip-safe-zip-path-destination">
<h3><code class="docutils literal notranslate"><span class="pre">extract_zip_safe(zip_path,</span> <span class="pre">destination)</span></code><a class="headerlink" href="#extract-zip-safe-zip-path-destination" title="Link to this heading"></a></h3>
<p>Extract a ZIP archive while preventing traversal and compression bombs.</p>
<p>Args:
zip_path: Path to the ZIP file to extract.
destination: Directory where extracted files should be stored.
logger: Optional logger for emitting extraction telemetry.</p>
<p>Returns:
List of extracted file paths.</p>
<p>Raises:
ConfigError: If the archive contains unsafe paths, compression bombs, or is missing.</p>
</section>
<section id="extract-tar-safe-tar-path-destination">
<h3><code class="docutils literal notranslate"><span class="pre">extract_tar_safe(tar_path,</span> <span class="pre">destination)</span></code><a class="headerlink" href="#extract-tar-safe-tar-path-destination" title="Link to this heading"></a></h3>
<p>Safely extract tar archives (tar, tar.gz, tar.xz) with traversal and compression checks.</p>
<p>Args:
tar_path: Path to the tar archive (tar, tar.gz, tar.xz).
destination: Directory where extracted files should be stored.
logger: Optional logger for emitting extraction telemetry.</p>
<p>Returns:
List of extracted file paths.</p>
<p>Raises:
ConfigError: If the archive is missing, unsafe, or exceeds compression limits.</p>
</section>
<section id="extract-archive-safe-archive-path-destination">
<h3><code class="docutils literal notranslate"><span class="pre">extract_archive_safe(archive_path,</span> <span class="pre">destination)</span></code><a class="headerlink" href="#extract-archive-safe-archive-path-destination" title="Link to this heading"></a></h3>
<p>Extract archives by dispatching to the appropriate safe handler.</p>
<p>Args:
archive_path: Path to the archive on disk.
destination: Directory where files should be extracted.
logger: Optional logger receiving structured extraction telemetry.</p>
<p>Returns:
List of paths extracted from the archive in the order processed.</p>
<p>Raises:
ConfigError: If the archive format is unsupported or extraction fails.</p>
</section>
<section id="get-bucket-host-http-config-service">
<h3><code class="docutils literal notranslate"><span class="pre">_get_bucket(host,</span> <span class="pre">http_config,</span> <span class="pre">service)</span></code><a class="headerlink" href="#get-bucket-host-http-config-service" title="Link to this heading"></a></h3>
<p>Return a token bucket keyed by host and optional service name.</p>
<p>Args:
host: Hostname extracted from the download URL.
http_config: Download configuration providing base rate limits.
service: Logical service identifier enabling per-service overrides.</p>
<p>Returns:
TokenBucket instance shared across downloads for throttling, seeded
with either per-host defaults or service-specific overrides.</p>
</section>
<section id="download-stream">
<h3><code class="docutils literal notranslate"><span class="pre">download_stream()</span></code><a class="headerlink" href="#download-stream" title="Link to this heading"></a></h3>
<p>Download ontology content with HEAD validation, rate limiting, caching, retries, and hash checks.</p>
<p>Args:
url: URL of the ontology document to download.
destination: Target file path for the downloaded content.
headers: HTTP headers forwarded to the download request.
previous_manifest: Manifest metadata from a prior run, used for caching.
http_config: Download configuration containing timeouts, limits, and rate controls.
cache_dir: Directory where intermediary cached files are stored.
logger: Logger adapter for structured download telemetry.
expected_media_type: Expected Content-Type for validation, if known.
service: Logical service identifier for per-service rate limiting.</p>
<p>Returns:
DownloadResult describing the final artifact and metadata.</p>
<p>Raises:
ConfigError: If validation fails, limits are exceeded, or HTTP errors occur.</p>
</section>
<section id="log-validation-memory-logger-validator-event">
<h3><code class="docutils literal notranslate"><span class="pre">_log_validation_memory(logger,</span> <span class="pre">validator,</span> <span class="pre">event)</span></code><a class="headerlink" href="#log-validation-memory-logger-validator-event" title="Link to this heading"></a></h3>
<p>Emit memory usage diagnostics for a validator when debug logging is enabled.</p>
<p>Args:
logger: Logger responsible for validator telemetry.
validator: Name of the validator emitting the event.
event: Lifecycle label describing when the measurement is captured.</p>
</section>
<section id="write-validation-json-path-payload">
<h3><code class="docutils literal notranslate"><span class="pre">_write_validation_json(path,</span> <span class="pre">payload)</span></code><a class="headerlink" href="#write-validation-json-path-payload" title="Link to this heading"></a></h3>
<p>Persist structured validation metadata to disk as JSON.</p>
<p>Args:
path: Destination path for the JSON payload.
payload: Mapping containing validation results.</p>
</section>
<section id="python-merge-sort-source-destination">
<h3><code class="docutils literal notranslate"><span class="pre">_python_merge_sort(source,</span> <span class="pre">destination)</span></code><a class="headerlink" href="#python-merge-sort-source-destination" title="Link to this heading"></a></h3>
<p>Sort an N-Triples file using a disk-backed merge strategy.</p>
<p>Args:
source: Path to the unsorted triple file.
destination: Output path that receives sorted triples.
chunk_size: Number of lines loaded into memory per chunk before flushing.</p>
</section>
<section id="term-to-string-term-namespace-manager">
<h3><code class="docutils literal notranslate"><span class="pre">_term_to_string(term,</span> <span class="pre">namespace_manager)</span></code><a class="headerlink" href="#term-to-string-term-namespace-manager" title="Link to this heading"></a></h3>
<p>Render an RDF term using the provided namespace manager.</p>
<p>Args:
term: RDF term such as a URIRef, BNode, or Literal.
namespace_manager: Namespace manager responsible for prefix resolution.</p>
<p>Returns:
Term rendered in N3 form, falling back to :func:<code class="docutils literal notranslate"><span class="pre">str</span></code> when unavailable.</p>
</section>
<section id="canonicalize-turtle-graph">
<h3><code class="docutils literal notranslate"><span class="pre">_canonicalize_turtle(graph)</span></code><a class="headerlink" href="#canonicalize-turtle-graph" title="Link to this heading"></a></h3>
<p>Return canonical Turtle output with sorted prefixes and triples.</p>
<p>The canonical form mirrors the ontology downloader specification by sorting
prefixes lexicographically and emitting triples ordered by subject,
predicate, and object so downstream hashing yields deterministic values.</p>
<p>Args:
graph: RDF graph containing triples to canonicalize.</p>
<p>Returns:
Canonical Turtle serialization as a string.</p>
</section>
<section id="canonicalize-blank-nodes-line-line-mapping">
<h3><code class="docutils literal notranslate"><span class="pre">_canonicalize_blank_nodes_line(line,</span> <span class="pre">mapping)</span></code><a class="headerlink" href="#canonicalize-blank-nodes-line-line-mapping" title="Link to this heading"></a></h3>
<p>Replace blank node identifiers with deterministic sequential labels.</p>
<p>Args:
line: Serialized triple line containing blank node identifiers.
mapping: Mutable mapping preserving deterministic blank node assignments.</p>
<p>Returns:
Triple line with normalized blank node identifiers.</p>
</section>
<section id="sort-triple-file-source-destination">
<h3><code class="docutils literal notranslate"><span class="pre">_sort_triple_file(source,</span> <span class="pre">destination)</span></code><a class="headerlink" href="#sort-triple-file-source-destination" title="Link to this heading"></a></h3>
<p>Sort serialized triple lines using platform sort when available.</p>
<p>Args:
source: Path to the unsorted triple file.
destination: Output path that receives sorted triples.</p>
</section>
<section id="normalize-streaming-source-output-path">
<h3><code class="docutils literal notranslate"><span class="pre">normalize_streaming(source,</span> <span class="pre">output_path)</span></code><a class="headerlink" href="#normalize-streaming-source-output-path" title="Link to this heading"></a></h3>
<p>Normalize ontologies using streaming canonical Turtle serialization.</p>
<p>The streaming path serializes triples to a temporary file, leverages the
platform <code class="docutils literal notranslate"><span class="pre">sort</span></code> command (when available) to order triples lexicographically,
and streams the canonical Turtle output while computing a SHA-256 digest.
When <code class="docutils literal notranslate"><span class="pre">output_path</span></code> is provided the canonical form is persisted without
retaining the entire content in memory.</p>
<p>Args:
source: Path to the ontology document providing triples.
output_path: Optional destination for the normalized Turtle document.
graph: Optional pre-loaded RDF graph re-used instead of reparsing.
chunk_bytes: Threshold controlling how frequently buffered bytes are flushed.</p>
<p>Returns:
SHA-256 hex digest of the canonical Turtle content.</p>
</section>
<section id="worker-pronto-payload">
<h3><code class="docutils literal notranslate"><span class="pre">_worker_pronto(payload)</span></code><a class="headerlink" href="#worker-pronto-payload" title="Link to this heading"></a></h3>
<p>Execute Pronto validation logic and emit JSON-friendly results.</p>
</section>
<section id="worker-owlready2-payload">
<h3><code class="docutils literal notranslate"><span class="pre">_worker_owlready2(payload)</span></code><a class="headerlink" href="#worker-owlready2-payload" title="Link to this heading"></a></h3>
<p>Execute Owlready2 validation logic and emit JSON-friendly results.</p>
</section>
<section id="run-validator-subprocess-name-payload">
<h3><code class="docutils literal notranslate"><span class="pre">_run_validator_subprocess(name,</span> <span class="pre">payload)</span></code><a class="headerlink" href="#run-validator-subprocess-name-payload" title="Link to this heading"></a></h3>
<p>Execute a validator worker module within a subprocess.</p>
<p>The subprocess workflow enforces parser timeouts, returns JSON payloads,
and helps release memory held by heavy libraries such as Pronto and
Owlready2 after each validation completes.</p>
</section>
<section id="run-with-timeout-func-timeout-sec">
<h3><code class="docutils literal notranslate"><span class="pre">_run_with_timeout(func,</span> <span class="pre">timeout_sec)</span></code><a class="headerlink" href="#run-with-timeout-func-timeout-sec" title="Link to this heading"></a></h3>
<p>Execute a callable and raise :class:<code class="docutils literal notranslate"><span class="pre">ValidationTimeout</span></code> on deadline expiry.</p>
<p>Args:
func: Callable invoked without arguments.
timeout_sec: Number of seconds allowed for execution.</p>
<p>Returns:
None</p>
<p>Raises:
ValidationTimeout: When the callable exceeds the allotted runtime.</p>
</section>
<section id="prepare-xbrl-package-request-logger">
<h3><code class="docutils literal notranslate"><span class="pre">_prepare_xbrl_package(request,</span> <span class="pre">logger)</span></code><a class="headerlink" href="#prepare-xbrl-package-request-logger" title="Link to this heading"></a></h3>
<p>Extract XBRL taxonomy ZIP archives for downstream validation.</p>
<p>Args:
request: Validation request describing the ontology package under test.
logger: Logger used to record extraction telemetry.</p>
<p>Returns:
Tuple containing the entrypoint path passed to Arelle and a list of artifacts.</p>
<p>Raises:
ValueError: If the archive is malformed or contains unsafe paths.</p>
</section>
<section id="validate-rdflib-request-logger">
<h3><code class="docutils literal notranslate"><span class="pre">validate_rdflib(request,</span> <span class="pre">logger)</span></code><a class="headerlink" href="#validate-rdflib-request-logger" title="Link to this heading"></a></h3>
<p>Parse ontologies with rdflib, canonicalize Turtle output, and emit hashes.</p>
<p>Args:
request: Validation request describing the target ontology and output directories.
logger: Logger adapter used for structured validation events.</p>
<p>Returns:
ValidationResult capturing success state, metadata, canonical hash,
and generated files.</p>
<p>Raises:
ValidationTimeout: Propagated when parsing exceeds configured timeout.</p>
</section>
<section id="validate-pronto-request-logger">
<h3><code class="docutils literal notranslate"><span class="pre">validate_pronto(request,</span> <span class="pre">logger)</span></code><a class="headerlink" href="#validate-pronto-request-logger" title="Link to this heading"></a></h3>
<p>Execute Pronto validation in an isolated subprocess and emit OBO Graphs when requested.</p>
<p>Args:
request: Validation request describing ontology inputs and output directories.
logger: Structured logger for recording warnings and failures.</p>
<p>Returns:
ValidationResult with parsed ontology statistics, subprocess output,
and any generated artifacts.</p>
<p>Raises:
ValidationTimeout: Propagated when Pronto takes longer than allowed.</p>
</section>
<section id="validate-owlready2-request-logger">
<h3><code class="docutils literal notranslate"><span class="pre">validate_owlready2(request,</span> <span class="pre">logger)</span></code><a class="headerlink" href="#validate-owlready2-request-logger" title="Link to this heading"></a></h3>
<p>Inspect ontologies with Owlready2 in a subprocess to count entities and catch parsing errors.</p>
<p>Args:
request: Validation request referencing the ontology to parse.
logger: Logger for reporting failures or memory warnings.</p>
<p>Returns:
ValidationResult summarizing entity counts or failure details.</p>
<p>Raises:
None</p>
</section>
<section id="validate-robot-request-logger">
<h3><code class="docutils literal notranslate"><span class="pre">validate_robot(request,</span> <span class="pre">logger)</span></code><a class="headerlink" href="#validate-robot-request-logger" title="Link to this heading"></a></h3>
<p>Run ROBOT CLI validation and conversion workflows when available.</p>
<p>Args:
request: Validation request detailing ontology paths and output locations.
logger: Logger adapter for reporting warnings and CLI errors.</p>
<p>Returns:
ValidationResult describing generated outputs or encountered issues.</p>
<p>Raises:
None</p>
</section>
<section id="validate-arelle-request-logger">
<h3><code class="docutils literal notranslate"><span class="pre">validate_arelle(request,</span> <span class="pre">logger)</span></code><a class="headerlink" href="#validate-arelle-request-logger" title="Link to this heading"></a></h3>
<p>Validate XBRL ontologies with Arelle CLI if installed.</p>
<p>Args:
request: Validation request referencing the ontology under test.
logger: Logger used to communicate validation progress and failures.</p>
<p>Returns:
ValidationResult indicating whether the validation completed and
referencing any produced log files.</p>
<p>Raises:
None</p>
</section>
<section id="load-validator-plugins-logger">
<h3><code class="docutils literal notranslate"><span class="pre">_load_validator_plugins(logger)</span></code><a class="headerlink" href="#load-validator-plugins-logger" title="Link to this heading"></a></h3>
<p>Discover validator plugins registered via entry points.</p>
</section>
<section id="run-validator-task-validator-request-logger">
<h3><code class="docutils literal notranslate"><span class="pre">_run_validator_task(validator,</span> <span class="pre">request,</span> <span class="pre">logger)</span></code><a class="headerlink" href="#run-validator-task-validator-request-logger" title="Link to this heading"></a></h3>
<p>Execute a single validator with exception guards.</p>
</section>
<section id="run-validators-requests-logger">
<h3><code class="docutils literal notranslate"><span class="pre">run_validators(requests,</span> <span class="pre">logger)</span></code><a class="headerlink" href="#run-validators-requests-logger" title="Link to this heading"></a></h3>
<p>Execute registered validators and aggregate their results.</p>
<p>Args:
requests: Iterable of validation requests that specify validators to run.
logger: Logger adapter shared across validation executions.</p>
<p>Returns:
Mapping from validator name to the corresponding ValidationResult.</p>
</section>
<section id="run-worker-cli-name-stdin-payload">
<h3><code class="docutils literal notranslate"><span class="pre">_run_worker_cli(name,</span> <span class="pre">stdin_payload)</span></code><a class="headerlink" href="#run-worker-cli-name-stdin-payload" title="Link to this heading"></a></h3>
<p>Execute a validator worker handler and emit JSON to stdout.</p>
</section>
<section id="main">
<h3><code class="docutils literal notranslate"><span class="pre">main()</span></code><a class="headerlink" href="#main" title="Link to this heading"></a></h3>
<p>Entry point for module execution providing validator worker dispatch.</p>
<p>Args:
None.</p>
<p>Returns:
None.</p>
</section>
<section id="get-manifest-schema">
<h3><code class="docutils literal notranslate"><span class="pre">get_manifest_schema()</span></code><a class="headerlink" href="#get-manifest-schema" title="Link to this heading"></a></h3>
<p>Return a deep copy of the manifest JSON Schema definition.</p>
<p>Args:
None</p>
<p>Returns:
Dictionary describing the manifest JSON Schema.</p>
</section>
<section id="validate-manifest-dict-payload">
<h3><code class="docutils literal notranslate"><span class="pre">validate_manifest_dict(payload)</span></code><a class="headerlink" href="#validate-manifest-dict-payload" title="Link to this heading"></a></h3>
<p>Validate manifest payload against the JSON Schema definition.</p>
<p>Args:
payload: Manifest dictionary loaded from JSON.
source: Optional filesystem path for contextual error reporting.</p>
<p>Returns:
None</p>
<p>Raises:
ConfigurationError: If validation fails.</p>
</section>
<section id="parse-http-datetime-value">
<h3><code class="docutils literal notranslate"><span class="pre">parse_http_datetime(value)</span></code><a class="headerlink" href="#parse-http-datetime-value" title="Link to this heading"></a></h3>
<p>Parse HTTP <code class="docutils literal notranslate"><span class="pre">Last-Modified</span></code> style timestamps into UTC datetimes.</p>
<p>Args:
value: Timestamp string from HTTP headers such as <code class="docutils literal notranslate"><span class="pre">Last-Modified</span></code>.</p>
<p>Returns:
Optional[datetime]: Normalized UTC datetime when parsing succeeds.</p>
<p>Raises:
None: Parsing failures are converted into a <code class="docutils literal notranslate"><span class="pre">None</span></code> return value.</p>
</section>
<section id="parse-iso-datetime-value">
<h3><code class="docutils literal notranslate"><span class="pre">parse_iso_datetime(value)</span></code><a class="headerlink" href="#parse-iso-datetime-value" title="Link to this heading"></a></h3>
<p>Parse ISO-8601 timestamps into timezone-aware UTC datetimes.</p>
<p>Args:
value: ISO-8601 formatted timestamp string.</p>
<p>Returns:
Optional[datetime]: Normalized UTC datetime when parsing succeeds.</p>
<p>Raises:
None: Invalid values return <code class="docutils literal notranslate"><span class="pre">None</span></code> instead of raising.</p>
</section>
<section id="parse-version-timestamp-value">
<h3><code class="docutils literal notranslate"><span class="pre">parse_version_timestamp(value)</span></code><a class="headerlink" href="#parse-version-timestamp-value" title="Link to this heading"></a></h3>
<p>Parse version strings or manifest timestamps into UTC datetimes.</p>
<p>Args:
value: Version identifier or timestamp string to normalize.</p>
<p>Returns:
Optional[datetime]: Parsed UTC datetime when the input matches supported formats.</p>
<p>Raises:
None: All parsing failures result in <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</section>
<section id="infer-version-timestamp-value">
<h3><code class="docutils literal notranslate"><span class="pre">infer_version_timestamp(value)</span></code><a class="headerlink" href="#infer-version-timestamp-value" title="Link to this heading"></a></h3>
<p>Infer a timestamp from resolver version identifiers.</p>
<p>Args:
value: Resolver version string containing date-like fragments.</p>
<p>Returns:
Optional[datetime]: Parsed UTC datetime when the value contains recoverable dates.</p>
<p>Raises:
None: Returns <code class="docutils literal notranslate"><span class="pre">None</span></code> instead of raising on unparseable inputs.</p>
</section>
<section id="coerce-datetime-value">
<h3><code class="docutils literal notranslate"><span class="pre">_coerce_datetime(value)</span></code><a class="headerlink" href="#coerce-datetime-value" title="Link to this heading"></a></h3>
<p>Return timezone-aware datetime parsed from HTTP or ISO timestamp.</p>
</section>
<section id="normalize-timestamp-value">
<h3><code class="docutils literal notranslate"><span class="pre">_normalize_timestamp(value)</span></code><a class="headerlink" href="#normalize-timestamp-value" title="Link to this heading"></a></h3>
<p>Return canonical ISO8601 string for HTTP timestamp headers.</p>
</section>
<section id="populate-plan-metadata-planned-config-adapter">
<h3><code class="docutils literal notranslate"><span class="pre">_populate_plan_metadata(planned,</span> <span class="pre">config,</span> <span class="pre">adapter)</span></code><a class="headerlink" href="#populate-plan-metadata-planned-config-adapter" title="Link to this heading"></a></h3>
<p>Augment planned fetch with HTTP metadata when available.</p>
</section>
<section id="migrate-manifest-inplace-payload">
<h3><code class="docutils literal notranslate"><span class="pre">_migrate_manifest_inplace(payload)</span></code><a class="headerlink" href="#migrate-manifest-inplace-payload" title="Link to this heading"></a></h3>
<p>Upgrade manifests created with older schema versions in place.</p>
</section>
<section id="read-manifest-manifest-path">
<h3><code class="docutils literal notranslate"><span class="pre">_read_manifest(manifest_path)</span></code><a class="headerlink" href="#read-manifest-manifest-path" title="Link to this heading"></a></h3>
<p>Return previously recorded manifest data if a valid JSON file exists.</p>
<p>Args:
manifest_path: Filesystem path where the manifest is stored.</p>
<p>Returns:
Parsed manifest dictionary when available and valid, otherwise <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</section>
<section id="validate-manifest-manifest">
<h3><code class="docutils literal notranslate"><span class="pre">_validate_manifest(manifest)</span></code><a class="headerlink" href="#validate-manifest-manifest" title="Link to this heading"></a></h3>
<p>Check that a manifest instance satisfies structural and type requirements.</p>
<p>Args:
manifest: Manifest produced after a download completes.</p>
<p>Raises:
ConfigurationError: If required fields are missing or contain invalid types.</p>
</section>
<section id="parse-last-modified-value">
<h3><code class="docutils literal notranslate"><span class="pre">_parse_last_modified(value)</span></code><a class="headerlink" href="#parse-last-modified-value" title="Link to this heading"></a></h3>
<p>Return a timezone-aware datetime parsed from HTTP date headers.</p>
</section>
<section id="fetch-last-modified-plan-config-logger">
<h3><code class="docutils literal notranslate"><span class="pre">_fetch_last_modified(plan,</span> <span class="pre">config,</span> <span class="pre">logger)</span></code><a class="headerlink" href="#fetch-last-modified-plan-config-logger" title="Link to this heading"></a></h3>
<p>Probe the upstream plan URL for a Last-Modified header.</p>
</section>
<section id="write-manifest-manifest-path-manifest">
<h3><code class="docutils literal notranslate"><span class="pre">_write_manifest(manifest_path,</span> <span class="pre">manifest)</span></code><a class="headerlink" href="#write-manifest-manifest-path-manifest" title="Link to this heading"></a></h3>
<p>Persist a validated manifest to disk as JSON.</p>
<p>Args:
manifest_path: Destination path for the manifest file.
manifest: Manifest describing the downloaded ontology artifact.</p>
</section>
<section id="build-destination-spec-plan-config">
<h3><code class="docutils literal notranslate"><span class="pre">_build_destination(spec,</span> <span class="pre">plan,</span> <span class="pre">config)</span></code><a class="headerlink" href="#build-destination-spec-plan-config" title="Link to this heading"></a></h3>
<p>Determine the output directory and filename for a download.</p>
<p>Args:
spec: Fetch specification identifying the ontology.
plan: Resolver plan containing URL metadata and optional hints.
config: Resolved configuration with storage layout parameters.</p>
<p>Returns:
Tuple containing the target file path, resolved version, and base directory.</p>
</section>
<section id="ensure-license-allowed-plan-config-spec">
<h3><code class="docutils literal notranslate"><span class="pre">_ensure_license_allowed(plan,</span> <span class="pre">config,</span> <span class="pre">spec)</span></code><a class="headerlink" href="#ensure-license-allowed-plan-config-spec" title="Link to this heading"></a></h3>
<p>Confirm the ontology license is present in the configured allow list.</p>
<p>Args:
plan: Resolver plan returned for the ontology.
config: Resolved configuration containing accepted licenses.
spec: Fetch specification for contextual error reporting.</p>
<p>Raises:
ConfigurationError: If the plan’s license is not permitted.</p>
</section>
<section id="resolver-candidates-spec-config">
<h3><code class="docutils literal notranslate"><span class="pre">_resolver_candidates(spec,</span> <span class="pre">config)</span></code><a class="headerlink" href="#resolver-candidates-spec-config" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="resolve-plan-with-fallback-spec-config-adapter">
<h3><code class="docutils literal notranslate"><span class="pre">_resolve_plan_with_fallback(spec,</span> <span class="pre">config,</span> <span class="pre">adapter)</span></code><a class="headerlink" href="#resolve-plan-with-fallback-spec-config-adapter" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="fetch-one-spec">
<h3><code class="docutils literal notranslate"><span class="pre">fetch_one(spec)</span></code><a class="headerlink" href="#fetch-one-spec" title="Link to this heading"></a></h3>
<p>Fetch, validate, and persist a single ontology described by <em>spec</em>.</p>
<p>Args:
spec: Ontology fetch specification describing sources and formats.
config: Optional resolved configuration overriding global defaults.
correlation_id: Correlation identifier for structured logging.
logger: Optional logger to reuse instead of configuring a new one.
force: When <code class="docutils literal notranslate"><span class="pre">True</span></code>, bypass local cache checks and redownload artifacts.</p>
<p>Returns:
FetchResult: Structured result containing manifest metadata and resolver attempts.</p>
<p>Raises:
ResolverError: If all resolver candidates fail to retrieve the ontology.</p>
</section>
<section id="plan-one-spec">
<h3><code class="docutils literal notranslate"><span class="pre">plan_one(spec)</span></code><a class="headerlink" href="#plan-one-spec" title="Link to this heading"></a></h3>
<p>Return a resolver plan for a single ontology without performing downloads.</p>
<p>Args:
spec: Fetch specification describing the ontology to plan.
config: Optional resolved configuration providing defaults and limits.
correlation_id: Correlation identifier reused for logging context.
logger: Logger instance used to emit resolver telemetry.</p>
<p>Returns:
PlannedFetch containing the normalized spec, resolver name, and plan.</p>
<p>Raises:
ResolverError: If all resolvers fail to produce a plan for <code class="docutils literal notranslate"><span class="pre">spec</span></code>.
ConfigurationError: If licence checks reject the planned ontology.</p>
</section>
<section id="plan-all-specs">
<h3><code class="docutils literal notranslate"><span class="pre">plan_all(specs)</span></code><a class="headerlink" href="#plan-all-specs" title="Link to this heading"></a></h3>
<p>Return resolver plans for a collection of ontologies.</p>
<p>Args:
specs: Iterable of fetch specifications to resolve.
config: Optional resolved configuration reused across plans.
logger: Logger instance used for annotation-aware logging.
since: Optional cutoff date; plans older than this timestamp are filtered out.</p>
<p>Returns:
List of PlannedFetch entries describing each ontology plan.</p>
<p>Raises:
ResolverError: Propagated when fallback planning fails for any spec.
ConfigurationError: When licence enforcement rejects a planned ontology.</p>
</section>
<section id="fetch-all-specs">
<h3><code class="docutils literal notranslate"><span class="pre">fetch_all(specs)</span></code><a class="headerlink" href="#fetch-all-specs" title="Link to this heading"></a></h3>
<p>Fetch a sequence of ontologies sequentially.</p>
<p>Args:
specs: Iterable of fetch specifications to process.
config: Optional resolved configuration shared across downloads.
logger: Logger used to emit progress and error events.
force: When True, skip manifest reuse and download everything again.</p>
<p>Returns:
List of FetchResult entries corresponding to completed downloads.</p>
<p>Raises:
OntologyDownloadError: Propagated when downloads fail and the pipeline
is configured to stop on error.</p>
</section>
<section id="safe-lock-component-value">
<h3><code class="docutils literal notranslate"><span class="pre">_safe_lock_component(value)</span></code><a class="headerlink" href="#safe-lock-component-value" title="Link to this heading"></a></h3>
<p>Return a filesystem-safe token for lock filenames.</p>
</section>
<section id="version-lock-ontology-id-version">
<h3><code class="docutils literal notranslate"><span class="pre">_version_lock(ontology_id,</span> <span class="pre">version)</span></code><a class="headerlink" href="#version-lock-ontology-id-version" title="Link to this heading"></a></h3>
<p>Acquire an inter-process lock for a specific ontology version.</p>
</section>
<section id="validate-level-cls-value">
<h3><code class="docutils literal notranslate"><span class="pre">validate_level(cls,</span> <span class="pre">value)</span></code><a class="headerlink" href="#validate-level-cls-value" title="Link to this heading"></a></h3>
<p>Validate logging level values.</p>
<p>Args:
value: Logging level provided in configuration.</p>
<p>Returns:
Uppercase logging level string accepted by :mod:<code class="docutils literal notranslate"><span class="pre">logging</span></code>.</p>
<p>Raises:
ValueError: If the supplied level is not among the supported options.</p>
</section>
<section id="validate-rate-limits-cls-value">
<h3><code class="docutils literal notranslate"><span class="pre">validate_rate_limits(cls,</span> <span class="pre">value)</span></code><a class="headerlink" href="#validate-rate-limits-cls-value" title="Link to this heading"></a></h3>
<p>Ensure rate limit strings follow the expected pattern.</p>
<p>Args:
value: Mapping of service name to rate limit expression.</p>
<p>Returns:
Validated mapping preserving the original values.</p>
<p>Raises:
ValueError: If any rate limit fails to match the accepted pattern.</p>
</section>
<section id="rate-limit-per-second-self">
<h3><code class="docutils literal notranslate"><span class="pre">rate_limit_per_second(self)</span></code><a class="headerlink" href="#rate-limit-per-second-self" title="Link to this heading"></a></h3>
<p>Convert <code class="docutils literal notranslate"><span class="pre">per_host_rate_limit</span></code> to a requests-per-second value.</p>
<p>Args:
None.</p>
<p>Returns:
Requests-per-second value derived from the configuration.</p>
<p>Raises:
ValueError: If the configured rate limit string is invalid.</p>
</section>
<section id="parse-service-rate-limit-self-service">
<h3><code class="docutils literal notranslate"><span class="pre">parse_service_rate_limit(self,</span> <span class="pre">service)</span></code><a class="headerlink" href="#parse-service-rate-limit-self-service" title="Link to this heading"></a></h3>
<p>Parse a per-service rate limit to requests per second.</p>
<p>Args:
service: Logical service name to look up.</p>
<p>Returns:
Requests-per-second value when configured, otherwise <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Raises:
None.</p>
</section>
<section id="normalized-allowed-hosts-self">
<h3><code class="docutils literal notranslate"><span class="pre">normalized_allowed_hosts(self)</span></code><a class="headerlink" href="#normalized-allowed-hosts-self" title="Link to this heading"></a></h3>
<p>Return allowlist entries normalized to lowercase punycode labels.</p>
<p>Args:
None.</p>
<p>Returns:
Tuple of (exact hostnames, wildcard suffixes) when entries exist,
otherwise <code class="docutils literal notranslate"><span class="pre">None</span></code> if no valid allowlist entries are configured.</p>
<p>Raises:
ValueError: If any configured hostname cannot be converted to punycode.</p>
</section>
<section id="polite-http-headers-self">
<h3><code class="docutils literal notranslate"><span class="pre">polite_http_headers(self)</span></code><a class="headerlink" href="#polite-http-headers-self" title="Link to this heading"></a></h3>
<p>Return polite HTTP headers suitable for resolver API calls.</p>
<p>The headers include a deterministic <code class="docutils literal notranslate"><span class="pre">User-Agent</span></code> string, propagate a
<code class="docutils literal notranslate"><span class="pre">From</span></code> contact address when configured, and synthesize an <code class="docutils literal notranslate"><span class="pre">X-Request-ID</span></code>
correlated with the current fetch so API providers can trace requests.</p>
<p>Args:
correlation_id: Identifier attached to the current batch for log correlation.
request_id: Optional override for <code class="docutils literal notranslate"><span class="pre">X-Request-ID</span></code> header; auto-generated when <code class="docutils literal notranslate"><span class="pre">None</span></code>.
timestamp: Optional timestamp used when constructing the request identifier.</p>
<p>Returns:
Mapping of header names to polite values complying with provider guidelines.</p>
</section>
<section id="validate-prefer-source-cls-value">
<h3><code class="docutils literal notranslate"><span class="pre">validate_prefer_source(cls,</span> <span class="pre">value)</span></code><a class="headerlink" href="#validate-prefer-source-cls-value" title="Link to this heading"></a></h3>
<p>Allow custom resolver identifiers while warning about unknown entries.</p>
<p>Args:
value: Ordered list of resolver identifiers supplied by configuration.</p>
<p>Returns:
Sanitised resolver list preserving the original order.</p>
<p>Raises:
ValueError: If any resolver name is not recognized.</p>
</section>
<section id="from-defaults-cls">
<h3><code class="docutils literal notranslate"><span class="pre">from_defaults(cls)</span></code><a class="headerlink" href="#from-defaults-cls" title="Link to this heading"></a></h3>
<p>Create an empty resolved configuration with library defaults.</p>
<p>Args:
None</p>
<p>Returns:
ResolvedConfig populated with default settings and no fetch specs.</p>
</section>
<section id="format-self-record">
<h3><code class="docutils literal notranslate"><span class="pre">format(self,</span> <span class="pre">record)</span></code><a class="headerlink" href="#format-self-record" title="Link to this heading"></a></h3>
<p>Serialize a logging record into a JSON line.</p>
<p>Args:
record: Logging record produced by the underlying logger.</p>
<p>Returns:
JSON string containing logging metadata and contextual extras.</p>
</section>
<section id="getitem-self-key">
<h3><code class="docutils literal notranslate"><span class="pre">__getitem__(self,</span> <span class="pre">key)</span></code><a class="headerlink" href="#getitem-self-key" title="Link to this heading"></a></h3>
<p>Return the expanded URI for the provided key.</p>
<p>Args:
key: Local name appended to the base namespace.</p>
<p>Returns:
Fully qualified IRI for the requested key.</p>
</section>
<section id="bind-self-prefix-namespace">
<h3><code class="docutils literal notranslate"><span class="pre">bind(self,</span> <span class="pre">prefix,</span> <span class="pre">namespace)</span></code><a class="headerlink" href="#bind-self-prefix-namespace" title="Link to this heading"></a></h3>
<p>Associate a namespace prefix with a full URI.</p>
<p>Args:
prefix: Namespace shorthand used in Turtle output.
namespace: Fully qualified namespace IRI.</p>
<p>Returns:
None.</p>
</section>
<section id="namespaces-self">
<h3><code class="docutils literal notranslate"><span class="pre">namespaces(self)</span></code><a class="headerlink" href="#namespaces-self" title="Link to this heading"></a></h3>
<p>Yield bound namespaces as <code class="docutils literal notranslate"><span class="pre">(prefix,</span> <span class="pre">namespace)</span></code> tuples.</p>
<p>Args:
None.</p>
<p>Returns:
Iterable of namespace bindings recorded by the manager.</p>
</section>
<section id="join">
<h3><code class="docutils literal notranslate"><span class="pre">join()</span></code><a class="headerlink" href="#join" title="Link to this heading"></a></h3>
<p>Join path segments beneath the stub root directory.</p>
<p>Args:
*segments: Arbitrary path components appended to the root.</p>
<p>Returns:
Path anchored at <code class="docutils literal notranslate"><span class="pre">root</span></code> with the provided segments appended.</p>
</section>
<section id="parse-self-source-format">
<h3><code class="docutils literal notranslate"><span class="pre">parse(self,</span> <span class="pre">source,</span> <span class="pre">format)</span></code><a class="headerlink" href="#parse-self-source-format" title="Link to this heading"></a></h3>
<p>Parse a Turtle file into the stub graph.</p>
<p>Args:
source: Local filesystem path to a Turtle document.
format: Optional rdflib format hint that is ignored by the stub.
_kwargs: Additional keyword arguments unused by the stub.</p>
<p>Returns:
The current graph instance populated with parsed triple strings.</p>
<p>Raises:
FileNotFoundError: If the Turtle file cannot be read.</p>
</section>
<section id="serialize-self-destination-format">
<h3><code class="docutils literal notranslate"><span class="pre">serialize(self,</span> <span class="pre">destination,</span> <span class="pre">format)</span></code><a class="headerlink" href="#serialize-self-destination-format" title="Link to this heading"></a></h3>
<p>Serialize the stub graph back to Turtle text.</p>
<p>Args:
destination: Optional output target path or file-like object.
format: Optional rdflib format that is ignored by the stub.
_kwargs: Additional keyword arguments unused by the stub.</p>
<p>Returns:
Destination handle or Turtle text when serializing to a string.</p>
<p>Raises:
OSError: If writing to the provided destination fails.</p>
</section>
<section id="id1">
<h3><code class="docutils literal notranslate"><span class="pre">bind(self,</span> <span class="pre">prefix,</span> <span class="pre">namespace)</span></code><a class="headerlink" href="#id1" title="Link to this heading"></a></h3>
<p>Attach a namespace binding to the internal namespace manager.</p>
<p>Args:
prefix: Namespace shorthand used in serialization.
namespace: Fully qualified namespace IRI.</p>
<p>Returns:
None.</p>
</section>
<section id="id2">
<h3><code class="docutils literal notranslate"><span class="pre">namespaces(self)</span></code><a class="headerlink" href="#id2" title="Link to this heading"></a></h3>
<p>Return the stored namespace bindings for serialization.</p>
<p>Args:
None.</p>
<p>Returns:
Iterable containing prefix-to-namespace mappings.</p>
</section>
<section id="len-self">
<h3><code class="docutils literal notranslate"><span class="pre">__len__(self)</span></code><a class="headerlink" href="#len-self" title="Link to this heading"></a></h3>
<p>Return the number of parsed triples retained by the stub.</p>
<p>Args:
None.</p>
<p>Returns:
Integer count of Turtle triples captured during parsing.</p>
</section>
<section id="iter-self">
<h3><code class="docutils literal notranslate"><span class="pre">__iter__(self)</span></code><a class="headerlink" href="#iter-self" title="Link to this heading"></a></h3>
<p>Iterate over the stored Turtle triple representations.</p>
<p>Args:
None.</p>
<p>Returns:
Iterator yielding Turtle triple strings from the stub graph.</p>
</section>
<section id="get-ontology-iri">
<h3><code class="docutils literal notranslate"><span class="pre">get_ontology(iri)</span></code><a class="headerlink" href="#get-ontology-iri" title="Link to this heading"></a></h3>
<p>Return a stub ontology bound to the provided IRI.</p>
<p>Args:
iri: Ontology IRI used to instantiate the stub.</p>
<p>Returns:
<code class="docutils literal notranslate"><span class="pre">_StubOntology</span></code> instance wrapping the provided IRI.</p>
</section>
<section id="prepare-version-self-ontology-id-version">
<h3><code class="docutils literal notranslate"><span class="pre">prepare_version(self,</span> <span class="pre">ontology_id,</span> <span class="pre">version)</span></code><a class="headerlink" href="#prepare-version-self-ontology-id-version" title="Link to this heading"></a></h3>
<p>Return a working directory prepared for the given ontology version.</p>
<p>Args:
ontology_id: Identifier of the ontology being downloaded.
version: Version string representing the in-flight download.</p>
<p>Returns:
Path to a freshly prepared directory tree ready for population.</p>
</section>
<section id="ensure-local-version-self-ontology-id-version">
<h3><code class="docutils literal notranslate"><span class="pre">ensure_local_version(self,</span> <span class="pre">ontology_id,</span> <span class="pre">version)</span></code><a class="headerlink" href="#ensure-local-version-self-ontology-id-version" title="Link to this heading"></a></h3>
<p>Ensure the requested version is present locally and return its path.</p>
<p>Args:
ontology_id: Identifier whose version must be present.
version: Version string that should exist on local storage.</p>
<p>Returns:
Path to the local directory containing the requested version.</p>
</section>
<section id="available-versions-self-ontology-id">
<h3><code class="docutils literal notranslate"><span class="pre">available_versions(self,</span> <span class="pre">ontology_id)</span></code><a class="headerlink" href="#available-versions-self-ontology-id" title="Link to this heading"></a></h3>
<p>Return sorted version identifiers currently stored for an ontology.</p>
<p>Args:
ontology_id: Identifier whose known versions are requested.</p>
<p>Returns:
Sorted list of version strings recognised by the backend.</p>
</section>
<section id="available-ontologies-self">
<h3><code class="docutils literal notranslate"><span class="pre">available_ontologies(self)</span></code><a class="headerlink" href="#available-ontologies-self" title="Link to this heading"></a></h3>
<p>Return sorted ontology identifiers known to the backend.</p>
<p>Args:
None.</p>
<p>Returns:
Alphabetically sorted list of ontology identifiers the backend can
service.</p>
</section>
<section id="finalize-version-self-ontology-id-version-local-dir">
<h3><code class="docutils literal notranslate"><span class="pre">finalize_version(self,</span> <span class="pre">ontology_id,</span> <span class="pre">version,</span> <span class="pre">local_dir)</span></code><a class="headerlink" href="#finalize-version-self-ontology-id-version-local-dir" title="Link to this heading"></a></h3>
<p>Persist the working directory after validation succeeds.</p>
<p>Args:
ontology_id: Identifier of the ontology that completed processing.
version: Version string associated with the finalized artifacts.
local_dir: Directory containing the validated ontology payload.</p>
<p>Returns:
None.</p>
</section>
<section id="version-path-self-ontology-id-version">
<h3><code class="docutils literal notranslate"><span class="pre">version_path(self,</span> <span class="pre">ontology_id,</span> <span class="pre">version)</span></code><a class="headerlink" href="#version-path-self-ontology-id-version" title="Link to this heading"></a></h3>
<p>Return the canonical storage path for <code class="docutils literal notranslate"><span class="pre">ontology_id</span></code>/<code class="docutils literal notranslate"><span class="pre">version</span></code>.</p>
<p>Args:
ontology_id: Identifier of the ontology being queried.
version: Version string for which a canonical path is needed.</p>
<p>Returns:
Path pointing to the storage location for the requested version.</p>
</section>
<section id="delete-version-self-ontology-id-version">
<h3><code class="docutils literal notranslate"><span class="pre">delete_version(self,</span> <span class="pre">ontology_id,</span> <span class="pre">version)</span></code><a class="headerlink" href="#delete-version-self-ontology-id-version" title="Link to this heading"></a></h3>
<p>Delete a stored version returning the number of bytes reclaimed.</p>
<p>Args:
ontology_id: Identifier whose version should be removed.
version: Version string targeted for deletion.</p>
<p>Returns:
Number of bytes reclaimed by removing the stored version.</p>
<p>Raises:
OSError: If the underlying storage provider fails to delete data.</p>
</section>
<section id="set-latest-version-self-ontology-id-version">
<h3><code class="docutils literal notranslate"><span class="pre">set_latest_version(self,</span> <span class="pre">ontology_id,</span> <span class="pre">version)</span></code><a class="headerlink" href="#set-latest-version-self-ontology-id-version" title="Link to this heading"></a></h3>
<p>Update the latest version marker for operators and CLI tooling.</p>
<p>Args:
ontology_id: Identifier whose latest marker requires updating.
version: Version string to record as the active release.</p>
<p>Returns:
None.</p>
</section>
<section id="version-dir-self-ontology-id-version">
<h3><code class="docutils literal notranslate"><span class="pre">_version_dir(self,</span> <span class="pre">ontology_id,</span> <span class="pre">version)</span></code><a class="headerlink" href="#version-dir-self-ontology-id-version" title="Link to this heading"></a></h3>
<p>Return the directory where a given ontology version is stored.</p>
<p>Args:
ontology_id: Identifier whose storage directory is required.
version: Version string combined with the identifier.</p>
<p>Returns:
Path pointing to <code class="docutils literal notranslate"><span class="pre">root/&lt;ontology_id&gt;/&lt;version&gt;</span></code>.</p>
</section>
<section id="id3">
<h3><code class="docutils literal notranslate"><span class="pre">prepare_version(self,</span> <span class="pre">ontology_id,</span> <span class="pre">version)</span></code><a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<p>Create the working directory structure for a download run.</p>
<p>Args:
ontology_id: Identifier of the ontology being processed.
version: Canonical version string for the ontology.</p>
<p>Returns:
Path to the prepared base directory containing <code class="docutils literal notranslate"><span class="pre">original</span></code>,
<code class="docutils literal notranslate"><span class="pre">normalized</span></code>, and <code class="docutils literal notranslate"><span class="pre">validation</span></code> subdirectories.</p>
</section>
<section id="id4">
<h3><code class="docutils literal notranslate"><span class="pre">ensure_local_version(self,</span> <span class="pre">ontology_id,</span> <span class="pre">version)</span></code><a class="headerlink" href="#id4" title="Link to this heading"></a></h3>
<p>Ensure a local workspace exists for <code class="docutils literal notranslate"><span class="pre">ontology_id</span></code>/<code class="docutils literal notranslate"><span class="pre">version</span></code>.</p>
<p>Args:
ontology_id: Identifier whose workspace must exist.
version: Version string that should map to a directory.</p>
<p>Returns:
Path to the local directory for the ontology version.</p>
</section>
<section id="id5">
<h3><code class="docutils literal notranslate"><span class="pre">available_versions(self,</span> <span class="pre">ontology_id)</span></code><a class="headerlink" href="#id5" title="Link to this heading"></a></h3>
<p>Return sorted versions already present for an ontology.</p>
<p>Args:
ontology_id: Identifier whose stored versions should be listed.</p>
<p>Returns:
Sorted list of version strings found under the storage root.</p>
</section>
<section id="id6">
<h3><code class="docutils literal notranslate"><span class="pre">available_ontologies(self)</span></code><a class="headerlink" href="#id6" title="Link to this heading"></a></h3>
<p>Return ontology identifiers discovered under <code class="docutils literal notranslate"><span class="pre">root</span></code>.</p>
<p>Args:
None.</p>
<p>Returns:
Sorted list of ontology identifiers available locally.</p>
</section>
<section id="id7">
<h3><code class="docutils literal notranslate"><span class="pre">finalize_version(self,</span> <span class="pre">ontology_id,</span> <span class="pre">version,</span> <span class="pre">local_dir)</span></code><a class="headerlink" href="#id7" title="Link to this heading"></a></h3>
<p>Finalize a local version directory (no-op for purely local storage).</p>
<p>Args:
ontology_id: Identifier that finished processing.
version: Version string associated with the processed ontology.
local_dir: Directory containing the ready-to-serve ontology.</p>
<p>Returns:
None.</p>
</section>
<section id="id8">
<h3><code class="docutils literal notranslate"><span class="pre">version_path(self,</span> <span class="pre">ontology_id,</span> <span class="pre">version)</span></code><a class="headerlink" href="#id8" title="Link to this heading"></a></h3>
<p>Return the local storage directory for the requested version.</p>
<p>Args:
ontology_id: Identifier being queried.
version: Version string whose storage path is needed.</p>
<p>Returns:
Path pointing to the stored ontology version.</p>
</section>
<section id="id9">
<h3><code class="docutils literal notranslate"><span class="pre">delete_version(self,</span> <span class="pre">ontology_id,</span> <span class="pre">version)</span></code><a class="headerlink" href="#id9" title="Link to this heading"></a></h3>
<p>Delete a stored ontology version returning reclaimed bytes.</p>
<p>Args:
ontology_id: Identifier whose stored version should be removed.
version: Version string targeted for deletion.</p>
<p>Returns:
Number of bytes reclaimed by removing the version directory.</p>
<p>Raises:
OSError: Propagated if filesystem deletion fails.</p>
</section>
<section id="id10">
<h3><code class="docutils literal notranslate"><span class="pre">set_latest_version(self,</span> <span class="pre">ontology_id,</span> <span class="pre">version)</span></code><a class="headerlink" href="#id10" title="Link to this heading"></a></h3>
<p>Update symlink and marker file indicating the latest version.</p>
<p>Args:
ontology_id: Identifier whose latest marker should be updated.
version: Version string to record as the latest processed build.</p>
<p>Returns:
None.</p>
</section>
<section id="remote-version-path-self-ontology-id-version">
<h3><code class="docutils literal notranslate"><span class="pre">_remote_version_path(self,</span> <span class="pre">ontology_id,</span> <span class="pre">version)</span></code><a class="headerlink" href="#remote-version-path-self-ontology-id-version" title="Link to this heading"></a></h3>
<p>Return the remote filesystem path for the specified ontology version.</p>
<p>Args:
ontology_id: Identifier whose remote storage path is required.
version: Version string associated with the ontology release.</p>
<p>Returns:
Posix-style path referencing the remote storage location.</p>
</section>
<section id="id11">
<h3><code class="docutils literal notranslate"><span class="pre">available_versions(self,</span> <span class="pre">ontology_id)</span></code><a class="headerlink" href="#id11" title="Link to this heading"></a></h3>
<p>Return versions aggregated from local cache and remote storage.</p>
<p>Args:
ontology_id: Identifier whose version catalogue is required.</p>
<p>Returns:
Sorted list combining local and remote version identifiers.</p>
</section>
<section id="id12">
<h3><code class="docutils literal notranslate"><span class="pre">available_ontologies(self)</span></code><a class="headerlink" href="#id12" title="Link to this heading"></a></h3>
<p>Return ontology identifiers available locally or remotely.</p>
<p>Args:
None.</p>
<p>Returns:
Sorted set union of local and remote ontology identifiers.</p>
</section>
<section id="id13">
<h3><code class="docutils literal notranslate"><span class="pre">ensure_local_version(self,</span> <span class="pre">ontology_id,</span> <span class="pre">version)</span></code><a class="headerlink" href="#id13" title="Link to this heading"></a></h3>
<p>Mirror a remote ontology version into the local cache when absent.</p>
<p>Args:
ontology_id: Identifier whose version should exist locally.
version: Version string to ensure within the local cache.</p>
<p>Returns:
Path to the local directory containing the requested version.</p>
</section>
<section id="id14">
<h3><code class="docutils literal notranslate"><span class="pre">finalize_version(self,</span> <span class="pre">ontology_id,</span> <span class="pre">version,</span> <span class="pre">local_dir)</span></code><a class="headerlink" href="#id14" title="Link to this heading"></a></h3>
<p>Upload the finalized local directory to the remote store.</p>
<p>Args:
ontology_id: Identifier of the ontology that has completed processing.
version: Version string associated with the finalised ontology.
local_dir: Directory containing the validated ontology payload.</p>
<p>Returns:
None.</p>
</section>
<section id="id15">
<h3><code class="docutils literal notranslate"><span class="pre">delete_version(self,</span> <span class="pre">ontology_id,</span> <span class="pre">version)</span></code><a class="headerlink" href="#id15" title="Link to this heading"></a></h3>
<p>Delete both local and remote copies of a stored version.</p>
<p>Args:
ontology_id: Identifier whose stored version should be deleted.
version: Version string targeted for deletion.</p>
<p>Returns:
Total bytes reclaimed across local and remote storage.</p>
<p>Raises:
OSError: Propagated if remote deletion fails irrecoverably.</p>
</section>
<section id="consume-self-tokens">
<h3><code class="docutils literal notranslate"><span class="pre">consume(self,</span> <span class="pre">tokens)</span></code><a class="headerlink" href="#consume-self-tokens" title="Link to this heading"></a></h3>
<p>Consume tokens from the bucket, sleeping until capacity is available.</p>
<p>Args:
tokens: Number of tokens required for the current download request.</p>
<p>Returns:
None</p>
</section>
<section id="preliminary-head-check-self-url-session">
<h3><code class="docutils literal notranslate"><span class="pre">_preliminary_head_check(self,</span> <span class="pre">url,</span> <span class="pre">session)</span></code><a class="headerlink" href="#preliminary-head-check-self-url-session" title="Link to this heading"></a></h3>
<p>Probe the origin with HEAD to audit media type and size before downloading.</p>
<p>The HEAD probe allows the pipeline to abort before streaming large
payloads that exceed configured limits and to log early warnings for
mismatched Content-Type headers reported by the origin.</p>
<p>Args:
url: Fully qualified download URL resolved by the planner.
session: Prepared requests session used for outbound calls.</p>
<p>Returns:
Tuple <code class="docutils literal notranslate"><span class="pre">(content_type,</span> <span class="pre">content_length)</span></code> extracted from response
headers. Each element is <code class="docutils literal notranslate"><span class="pre">None</span></code> when the origin omits it.</p>
<p>Raises:
ConfigError: If the origin reports a payload larger than the
configured <code class="docutils literal notranslate"><span class="pre">max_download_size_gb</span></code> limit.</p>
</section>
<section id="validate-media-type-self-actual-content-type-expected-media-type-url">
<h3><code class="docutils literal notranslate"><span class="pre">_validate_media_type(self,</span> <span class="pre">actual_content_type,</span> <span class="pre">expected_media_type,</span> <span class="pre">url)</span></code><a class="headerlink" href="#validate-media-type-self-actual-content-type-expected-media-type-url" title="Link to this heading"></a></h3>
<p>Validate that the received <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> header is acceptable, tolerating aliases.</p>
<p>RDF endpoints often return generic XML or Turtle aliases, so the
validator accepts a small set of known MIME variants while still
surfacing actionable warnings for unexpected types.</p>
<p>Args:
actual_content_type: Raw header value reported by the origin server.
expected_media_type: MIME type declared by resolver metadata.
url: Download URL logged when mismatches occur.</p>
<p>Returns:
None</p>
</section>
<section id="call-self-url-output-file-pooch-logger">
<h3><code class="docutils literal notranslate"><span class="pre">__call__(self,</span> <span class="pre">url,</span> <span class="pre">output_file,</span> <span class="pre">pooch_logger)</span></code><a class="headerlink" href="#call-self-url-output-file-pooch-logger" title="Link to this heading"></a></h3>
<p>Stream ontology content to disk while enforcing download policies.</p>
<p>Args:
url: Secure download URL resolved by the planner.
output_file: Temporary filename managed by pooch during download.
pooch_logger: Logger instance supplied by pooch (unused).</p>
<p>Raises:
ConfigError: If download limits are exceeded or filesystem errors occur.
requests.HTTPError: Propagated when HTTP status codes indicate failure.</p>
<p>Returns:
None</p>
</section>
<section id="to-dict-self">
<h3><code class="docutils literal notranslate"><span class="pre">to_dict(self)</span></code><a class="headerlink" href="#to-dict-self" title="Link to this heading"></a></h3>
<p>Represent the validation result as a JSON-serializable dict.</p>
<p>Args:
None.</p>
<p>Returns:
Dictionary with boolean status, detail payload, and output paths.</p>
</section>
<section id="replace-match">
<h3><code class="docutils literal notranslate"><span class="pre">_replace(match)</span></code><a class="headerlink" href="#replace-match" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="flush-writer">
<h3><code class="docutils literal notranslate"><span class="pre">_flush(writer)</span></code><a class="headerlink" href="#flush-writer" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="parse">
<h3><code class="docutils literal notranslate"><span class="pre">_parse()</span></code><a class="headerlink" href="#parse" title="Link to this heading"></a></h3>
<p>Parse the ontology with rdflib to populate the graph object.</p>
</section>
<section id="determine-max-workers">
<h3><code class="docutils literal notranslate"><span class="pre">_determine_max_workers()</span></code><a class="headerlink" href="#determine-max-workers" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="id16">
<h3><code class="docutils literal notranslate"><span class="pre">to_dict(self)</span></code><a class="headerlink" href="#id16" title="Link to this heading"></a></h3>
<p>Return a JSON-serializable dictionary for the manifest.</p>
<p>Args:
None</p>
<p>Returns:
Dictionary representing the manifest payload.</p>
</section>
<section id="to-json-self">
<h3><code class="docutils literal notranslate"><span class="pre">to_json(self)</span></code><a class="headerlink" href="#to-json-self" title="Link to this heading"></a></h3>
<p>Serialize the manifest to a stable, human-readable JSON string.</p>
<p>Args:
None</p>
<p>Returns:
JSON document encoding the manifest metadata.</p>
</section>
<section id="plan-self-spec-config-logger">
<h3><code class="docutils literal notranslate"><span class="pre">plan(self,</span> <span class="pre">spec,</span> <span class="pre">config,</span> <span class="pre">logger)</span></code><a class="headerlink" href="#plan-self-spec-config-logger" title="Link to this heading"></a></h3>
<p>Return a FetchPlan describing how to obtain the ontology.</p>
<p>Args:
spec: Ontology fetch specification under consideration.
config: Fully resolved configuration containing defaults.
logger: Logger adapter scoped to the current fetch request.</p>
<p>Returns:
Concrete plan containing download URL, headers, and metadata.</p>
</section>
<section id="add-candidate-candidate">
<h3><code class="docutils literal notranslate"><span class="pre">_add_candidate(candidate)</span></code><a class="headerlink" href="#add-candidate-candidate" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="add-name">
<h3><code class="docutils literal notranslate"><span class="pre">_add(name)</span></code><a class="headerlink" href="#add-name" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="terms-self">
<h3><code class="docutils literal notranslate"><span class="pre">terms(self)</span></code><a class="headerlink" href="#terms-self" title="Link to this heading"></a></h3>
<p>Return a static list of ontology term identifiers.</p>
<p>Args:
None.</p>
<p>Returns:
Iterable containing deterministic ontology term IDs.</p>
</section>
<section id="dump-self-destination-format">
<h3><code class="docutils literal notranslate"><span class="pre">dump(self,</span> <span class="pre">destination,</span> <span class="pre">format)</span></code><a class="headerlink" href="#dump-self-destination-format" title="Link to this heading"></a></h3>
<p>Write an empty ontology JSON payload to <code class="docutils literal notranslate"><span class="pre">destination</span></code>.</p>
<p>Args:
destination: Filesystem path where the JSON stub is stored.
format: Serialization format, kept for API equivalence.</p>
<p>Returns:
None.</p>
</section>
<section id="load-self">
<h3><code class="docutils literal notranslate"><span class="pre">load(self)</span></code><a class="headerlink" href="#load-self" title="Link to this heading"></a></h3>
<p>Provide a fluent API returning the ontology itself.</p>
<p>Args:
None.</p>
<p>Returns:
The same stub ontology instance, mimicking owlready2.</p>
<p>Raises:
None.</p>
</section>
<section id="classes-self">
<h3><code class="docutils literal notranslate"><span class="pre">classes(self)</span></code><a class="headerlink" href="#classes-self" title="Link to this heading"></a></h3>
<p>Return a deterministic set of class identifiers.</p>
<p>Args:
None.</p>
<p>Returns:
List of representative ontology class names.</p>
</section>
<section id="handler-signum-frame">
<h3><code class="docutils literal notranslate"><span class="pre">_handler(signum,</span> <span class="pre">frame)</span></code><a class="headerlink" href="#handler-signum-frame" title="Link to this heading"></a></h3>
<p>Signal handler converting SIGALRM into :class:<code class="docutils literal notranslate"><span class="pre">ValidationTimeout</span></code>.</p>
<p>Args:
signum: Received signal number.
frame: Current stack frame (unused).</p>
</section>
<section id="execute-candidate">
<h3><code class="docutils literal notranslate"><span class="pre">_execute_candidate()</span></code><a class="headerlink" href="#execute-candidate" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="emit-text">
<h3><code class="docutils literal notranslate"><span class="pre">_emit(text)</span></code><a class="headerlink" href="#emit-text" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
</section>
<section id="classes">
<h2>3. Classes<a class="headerlink" href="#classes" title="Link to this heading"></a></h2>
<section id="configerror">
<h3><code class="docutils literal notranslate"><span class="pre">ConfigError</span></code><a class="headerlink" href="#configerror" title="Link to this heading"></a></h3>
<p>Raised when ontology configuration files are invalid or inconsistent.</p>
<p>Attributes:
message: Human-readable explanation of the configuration flaw.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>try:
…     raise ConfigError(“missing id”)
… except ConfigError as exc:
…     assert “missing id” in str(exc)</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="loggingconfiguration">
<h3><code class="docutils literal notranslate"><span class="pre">LoggingConfiguration</span></code><a class="headerlink" href="#loggingconfiguration" title="Link to this heading"></a></h3>
<p>Structured logging options for ontology download operations.</p>
<p>Attributes:
level: Logging level for downloader telemetry (DEBUG, INFO, etc.).
max_log_size_mb: Maximum size of log files before rotation occurs.
retention_days: Number of days log files are retained on disk.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>config = LoggingConfiguration(level=”debug”)
config.level
‘DEBUG’</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="validationconfig">
<h3><code class="docutils literal notranslate"><span class="pre">ValidationConfig</span></code><a class="headerlink" href="#validationconfig" title="Link to this heading"></a></h3>
<p>Validation limits governing parser execution.</p>
<p>Attributes:
parser_timeout_sec: Maximum runtime allowed for ontology parsing.
max_memory_mb: Memory ceiling allocated to validation routines.
skip_reasoning_if_size_mb: Threshold above which reasoning is skipped.
streaming_normalization_threshold_mb: File size threshold for streaming normalization.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>ValidationConfig(parser_timeout_sec=120).parser_timeout_sec
120</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="downloadconfiguration">
<h3><code class="docutils literal notranslate"><span class="pre">DownloadConfiguration</span></code><a class="headerlink" href="#downloadconfiguration" title="Link to this heading"></a></h3>
<p>HTTP download, throttling, and polite header settings for resolvers.</p>
<p>Attributes:
max_retries: Maximum retry attempts for failed download requests.
timeout_sec: Base timeout applied to metadata requests.
download_timeout_sec: Timeout applied to streaming download operations.
backoff_factor: Exponential backoff multiplier between retry attempts.
per_host_rate_limit: Token bucket rate limit string for host throttling.
max_download_size_gb: Maximum permitted download size in gigabytes.
concurrent_downloads: Allowed number of simultaneous downloads.
validate_media_type: Whether to enforce Content-Type validation.
rate_limits: Optional per-service rate limit overrides.
allowed_hosts: Optional allowlist restricting download hostnames.
polite_headers: Default polite HTTP headers applied to resolver API calls.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>cfg = DownloadConfiguration(per_host_rate_limit=”10/second”)
round(cfg.rate_limit_per_second(), 2)
10.0</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="defaultsconfig">
<h3><code class="docutils literal notranslate"><span class="pre">DefaultsConfig</span></code><a class="headerlink" href="#defaultsconfig" title="Link to this heading"></a></h3>
<p>Collection of default settings for ontology fetch specifications.</p>
<p>Attributes:
accept_licenses: Licenses accepted by default during downloads.
normalize_to: Preferred formats for normalized ontology output.
prefer_source: Ordered list of resolver priorities.
http: Download configuration defaults.
validation: Validation configuration defaults.
logging: Logging configuration defaults.
continue_on_error: Whether processing continues after failures.
resolver_fallback_enabled: Whether automatic resolver fallback is enabled.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>defaults = DefaultsConfig()
“obo” in defaults.prefer_source
True</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="resolvedconfig">
<h3><code class="docutils literal notranslate"><span class="pre">ResolvedConfig</span></code><a class="headerlink" href="#resolvedconfig" title="Link to this heading"></a></h3>
<p>Container for merged configuration defaults and fetch specifications.</p>
<p>Attributes:
defaults: Default configuration applied to all ontology fetch specs.
specs: List of individual fetch specifications after merging defaults.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>config = ResolvedConfig.from_defaults()
isinstance(config.defaults, DefaultsConfig)
True</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="environmentoverrides">
<h3><code class="docutils literal notranslate"><span class="pre">EnvironmentOverrides</span></code><a class="headerlink" href="#environmentoverrides" title="Link to this heading"></a></h3>
<p>Environment variable overrides for ontology downloader defaults.</p>
<p>Attributes:
max_retries: Override for retry count via <code class="docutils literal notranslate"><span class="pre">ONTOFETCH_MAX_RETRIES</span></code>.
timeout_sec: Override for metadata timeout via <code class="docutils literal notranslate"><span class="pre">ONTOFETCH_TIMEOUT_SEC</span></code>.
download_timeout_sec: Override for streaming timeout.
per_host_rate_limit: Override for per-host rate limit string.
backoff_factor: Override for exponential backoff multiplier.
log_level: Override for logging level.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>overrides = EnvironmentOverrides()
overrides.model_config[‘env_prefix’]
‘ONTOFETCH_’</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="jsonformatter">
<h3><code class="docutils literal notranslate"><span class="pre">JSONFormatter</span></code><a class="headerlink" href="#jsonformatter" title="Link to this heading"></a></h3>
<p>Formatter emitting JSON structured logs.</p>
<p>Attributes:
default_msec_format: Fractional second format applied to timestamps.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>formatter = JSONFormatter()
isinstance(formatter.format(logging.LogRecord(“test”, 20, <strong>file</strong>, 1, “msg”, (), None)), str)  # doctest: +SKIP
True</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="stubnamespace">
<h3><code class="docutils literal notranslate"><span class="pre">_StubNamespace</span></code><a class="headerlink" href="#stubnamespace" title="Link to this heading"></a></h3>
<p>Minimal replacement mimicking rdflib Namespace behaviour.</p>
<p>Attributes:
_base: Base IRI string used to expand namespace members.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>ns = _StubNamespace(“http://example.org/”)
ns[“Term”]
‘http://example.org/Term’</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="stubnamespacemanager">
<h3><code class="docutils literal notranslate"><span class="pre">_StubNamespaceManager</span></code><a class="headerlink" href="#stubnamespacemanager" title="Link to this heading"></a></h3>
<p>Provide a namespaces() method compatible with rdflib.</p>
<p>Attributes:
_bindings: Mapping of prefixes to namespace IRIs.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>manager = _StubNamespaceManager()
manager.bind(“ex”, “http://example.org/”)
list(manager.namespaces())
[(‘ex’, ‘http://example.org/’)]</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="stubgraph">
<h3><code class="docutils literal notranslate"><span class="pre">_StubGraph</span></code><a class="headerlink" href="#stubgraph" title="Link to this heading"></a></h3>
<p>Lightweight graph implementation mirroring rdflib essentials.</p>
<p>Attributes:
_triples: In-memory list of Turtle triple strings.
_last_text: Raw Turtle content captured during parsing.
namespace_manager: Stub namespace manager for rdflib compatibility.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>graph = _StubGraph()
graph.parse(“tests/data/example.ttl”)  # doctest: +SKIP
len(graph)
0</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="storagebackend">
<h3><code class="docutils literal notranslate"><span class="pre">StorageBackend</span></code><a class="headerlink" href="#storagebackend" title="Link to this heading"></a></h3>
<p>Protocol describing the operations required by the downloader pipeline.</p>
<p>Attributes:
root_path: Canonical base path that implementations expose for disk
storage.  Remote-only backends can synthesize this attribute for
instrumentation purposes.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>class MemoryBackend(StorageBackend):
…     root_path = Path(“/tmp”)  # pragma: no cover - illustrative stub
…     def prepare_version(self, ontology_id: str, version: str) -&gt; Path:
…         …</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="localstoragebackend">
<h3><code class="docutils literal notranslate"><span class="pre">LocalStorageBackend</span></code><a class="headerlink" href="#localstoragebackend" title="Link to this heading"></a></h3>
<p>Storage backend that keeps ontology artifacts on the local filesystem.</p>
<p>Attributes:
root: Base directory that stores ontology versions grouped by identifier.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>backend = LocalStorageBackend(LOCAL_ONTOLOGY_DIR)
backend.available_ontologies()
[]</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="fsspecstoragebackend">
<h3><code class="docutils literal notranslate"><span class="pre">FsspecStorageBackend</span></code><a class="headerlink" href="#fsspecstoragebackend" title="Link to this heading"></a></h3>
<p>Hybrid storage backend that mirrors artifacts to an fsspec location.</p>
<p>Attributes:
fs: <code class="docutils literal notranslate"><span class="pre">fsspec</span></code> filesystem instance used for remote operations.
base_path: Root path within the remote filesystem where artefacts live.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>backend = FsspecStorageBackend(“memory://ontologies”)  # doctest: +SKIP
backend.available_ontologies()  # doctest: +SKIP
[]</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="downloadresult">
<h3><code class="docutils literal notranslate"><span class="pre">DownloadResult</span></code><a class="headerlink" href="#downloadresult" title="Link to this heading"></a></h3>
<p>Result metadata for a completed download operation.</p>
<p>Attributes:
path: Final file path where the ontology document was stored.
status: Download status (<code class="docutils literal notranslate"><span class="pre">fresh</span></code>, <code class="docutils literal notranslate"><span class="pre">updated</span></code>, or <code class="docutils literal notranslate"><span class="pre">cached</span></code>).
sha256: SHA-256 checksum of the downloaded artifact.
etag: HTTP ETag returned by the upstream server, when available.
last_modified: Upstream last-modified header value if provided.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>result = DownloadResult(Path(“ontology.owl”), “fresh”, “deadbeef”, None, None)
result.status
‘fresh’</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="downloadfailure">
<h3><code class="docutils literal notranslate"><span class="pre">DownloadFailure</span></code><a class="headerlink" href="#downloadfailure" title="Link to this heading"></a></h3>
<p>Raised when an HTTP download attempt fails.</p>
<p>Attributes:
status_code: Optional HTTP status code returned by the upstream service.
retryable: Whether the failure is safe to retry with an alternate resolver.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>raise DownloadFailure(“Unavailable”, status_code=503, retryable=True)
Traceback (most recent call last):
DownloadFailure: Unavailable</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="tokenbucket">
<h3><code class="docutils literal notranslate"><span class="pre">TokenBucket</span></code><a class="headerlink" href="#tokenbucket" title="Link to this heading"></a></h3>
<p>Token bucket used to enforce per-host and per-service rate limits.</p>
<p>Each unique combination of host and logical service identifier receives
its own bucket so resolvers can honour provider-specific throttling
guidance without starving other endpoints.</p>
<p>Attributes:
rate: Token replenishment rate per second.
capacity: Maximum number of tokens the bucket may hold.
tokens: Current token balance available for consumption.
timestamp: Monotonic timestamp of the last refill.
lock: Threading lock protecting bucket state.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>bucket = TokenBucket(rate_per_sec=2.0, capacity=4.0)
bucket.consume(1.0)  # consumes immediately
isinstance(bucket.tokens, float)
True</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="streamingdownloader">
<h3><code class="docutils literal notranslate"><span class="pre">StreamingDownloader</span></code><a class="headerlink" href="#streamingdownloader" title="Link to this heading"></a></h3>
<p>Custom downloader supporting HEAD validation, conditional requests, resume, and caching.</p>
<p>The downloader shares a :mod:<code class="docutils literal notranslate"><span class="pre">requests</span></code> session so it can issue a HEAD probe
prior to streaming content, verifies Content-Type and Content-Length against
expectations, and persists ETag/Last-Modified headers for cache-friendly
revalidation.</p>
<p>Attributes:
destination: Final location where the ontology will be stored.
custom_headers: HTTP headers supplied by the resolver.
http_config: Download configuration governing retries and limits.
previous_manifest: Manifest from prior runs used for caching.
logger: Logger used for structured telemetry.
status: Final download status (<code class="docutils literal notranslate"><span class="pre">fresh</span></code>, <code class="docutils literal notranslate"><span class="pre">updated</span></code>, or <code class="docutils literal notranslate"><span class="pre">cached</span></code>).
response_etag: ETag returned by the upstream server, if present.
response_last_modified: Last-modified timestamp provided by the server.
expected_media_type: MIME type provided by the resolver for validation.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>from pathlib import Path
from DocsToKG.OntologyDownload import DownloadConfiguration
downloader = StreamingDownloader(
…     destination=Path(“/tmp/ontology.owl”),
…     headers={},
…     http_config=DownloadConfiguration(),
…     previous_manifest={},
…     logger=logging.getLogger(“test”),
… )
downloader.status
‘fresh’</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="validationrequest">
<h3><code class="docutils literal notranslate"><span class="pre">ValidationRequest</span></code><a class="headerlink" href="#validationrequest" title="Link to this heading"></a></h3>
<p>Parameters describing a single validation task.</p>
<p>Attributes:
name: Identifier of the validator to execute.
file_path: Path to the ontology document to inspect.
normalized_dir: Directory used to write normalized artifacts.
validation_dir: Directory for validator reports and logs.
config: Resolved configuration that supplies timeout thresholds.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>from pathlib import Path
from DocsToKG.OntologyDownload import ResolvedConfig
req = ValidationRequest(
…     name=”rdflib”,
…     file_path=Path(“ontology.owl”),
…     normalized_dir=Path(“normalized”),
…     validation_dir=Path(“validation”),
…     config=ResolvedConfig.from_defaults(),
… )
req.name
‘rdflib’</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="validationresult">
<h3><code class="docutils literal notranslate"><span class="pre">ValidationResult</span></code><a class="headerlink" href="#validationresult" title="Link to this heading"></a></h3>
<p>Outcome produced by a validator.</p>
<p>Attributes:
ok: Indicates whether the validator succeeded.
details: Arbitrary metadata describing validator output.
output_files: Generated files for downstream processing.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>result = ValidationResult(ok=True, details={“triples”: 10}, output_files=[“ontology.ttl”])
result.ok
True</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="validationtimeout">
<h3><code class="docutils literal notranslate"><span class="pre">ValidationTimeout</span></code><a class="headerlink" href="#validationtimeout" title="Link to this heading"></a></h3>
<p>Raised when a validation task exceeds the configured timeout.</p>
<p>Args:
message: Optional description of the timeout condition.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>raise ValidationTimeout(“rdflib exceeded 60s”)
Traceback (most recent call last):
…
ValidationTimeout: rdflib exceeded 60s</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="validatorsubprocesserror">
<h3><code class="docutils literal notranslate"><span class="pre">ValidatorSubprocessError</span></code><a class="headerlink" href="#validatorsubprocesserror" title="Link to this heading"></a></h3>
<p>Raised when a validator subprocess exits unsuccessfully.</p>
<p>Attributes:
message: Human-readable description of the underlying subprocess failure.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>raise ValidatorSubprocessError(“rdflib validator crashed”)
Traceback (most recent call last):
…
ValidatorSubprocessError: rdflib validator crashed</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="ontologydownloaderror">
<h3><code class="docutils literal notranslate"><span class="pre">OntologyDownloadError</span></code><a class="headerlink" href="#ontologydownloaderror" title="Link to this heading"></a></h3>
<p>Base exception for ontology download failures.</p>
<p>Args:
message: Description of the failure encountered.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>raise OntologyDownloadError(“unexpected error”)
Traceback (most recent call last):
…
OntologyDownloadError: unexpected error</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="resolvererror">
<h3><code class="docutils literal notranslate"><span class="pre">ResolverError</span></code><a class="headerlink" href="#resolvererror" title="Link to this heading"></a></h3>
<p>Raised when resolver planning fails.</p>
<p>Args:
message: Description of the resolver failure.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>raise ResolverError(“resolver unavailable”)
Traceback (most recent call last):
…
ResolverError: resolver unavailable</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="validationerror">
<h3><code class="docutils literal notranslate"><span class="pre">ValidationError</span></code><a class="headerlink" href="#validationerror" title="Link to this heading"></a></h3>
<p>Raised when validation encounters unrecoverable issues.</p>
<p>Args:
message: Human-readable description of the validation failure.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>raise ValidationError(“robot validator crashed”)
Traceback (most recent call last):
…
ValidationError: robot validator crashed</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="configurationerror">
<h3><code class="docutils literal notranslate"><span class="pre">ConfigurationError</span></code><a class="headerlink" href="#configurationerror" title="Link to this heading"></a></h3>
<p>Raised when configuration or manifest validation fails.</p>
<p>Args:
message: Details about the configuration inconsistency.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>raise ConfigurationError(“manifest missing sha256”)
Traceback (most recent call last):
…
ConfigurationError: manifest missing sha256</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="fetchspec">
<h3><code class="docutils literal notranslate"><span class="pre">FetchSpec</span></code><a class="headerlink" href="#fetchspec" title="Link to this heading"></a></h3>
<p>Specification describing a single ontology download.</p>
<p>Attributes:
id: Stable identifier for the ontology to fetch.
resolver: Name of the resolver strategy used to locate resources.
extras: Resolver-specific configuration overrides.
target_formats: Normalized ontology formats that should be produced.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>spec = FetchSpec(id=”CHEBI”, resolver=”obo”, extras={}, target_formats=(“owl”,))
spec.resolver
‘obo’</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="fetchresult">
<h3><code class="docutils literal notranslate"><span class="pre">FetchResult</span></code><a class="headerlink" href="#fetchresult" title="Link to this heading"></a></h3>
<p>Outcome of a single ontology fetch operation.</p>
<p>Attributes:
spec: Fetch specification that initiated the download.
local_path: Path to the downloaded ontology document.
status: Final download status (e.g., <code class="docutils literal notranslate"><span class="pre">success</span></code>, <code class="docutils literal notranslate"><span class="pre">skipped</span></code>).
sha256: SHA-256 digest of the downloaded file.
manifest_path: Path to the generated manifest JSON file.
artifacts: Ancillary files produced during extraction or validation.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>from pathlib import Path
spec = FetchSpec(id=”CHEBI”, resolver=”obo”, extras={}, target_formats=(“owl”,))
result = FetchResult(
…     spec=spec,
…     local_path=Path(“CHEBI.owl”),
…     status=”success”,
…     sha256=”deadbeef”,
…     manifest_path=Path(“manifest.json”),
…     artifacts=(),
… )
result.status
‘success’</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="manifest">
<h3><code class="docutils literal notranslate"><span class="pre">Manifest</span></code><a class="headerlink" href="#manifest" title="Link to this heading"></a></h3>
<p>Provenance information for a downloaded ontology artifact.</p>
<p>Attributes:
schema_version: Manifest schema version identifier.
id: Ontology identifier recorded in the manifest.
resolver: Resolver used to retrieve the ontology.
url: Final URL from which the ontology was fetched.
filename: Local filename of the downloaded artifact.
version: Resolver-reported ontology version, if available.
license: License identifier associated with the ontology.
status: Result status reported by the downloader.
sha256: Hash of the downloaded artifact for integrity checking.
normalized_sha256: Hash of the canonical normalized TTL output.
fingerprint: Composite fingerprint combining key provenance values.
etag: HTTP ETag returned by the upstream server, when provided.
last_modified: Upstream last-modified timestamp, if supplied.
downloaded_at: UTC timestamp of the completed download.
target_formats: Desired conversion targets for normalization.
validation: Mapping of validator names to their results.
artifacts: Additional file paths generated during processing.
resolver_attempts: Ordered record of resolver attempts during download.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>manifest = Manifest(
…     schema_version=”1.0”,
…     id=”CHEBI”,
…     resolver=”obo”,
…     url=”https://example.org/chebi.owl”,
…     filename=”chebi.owl”,
…     version=None,
…     license=”CC-BY”,
…     status=”success”,
…     sha256=”deadbeef”,
…     normalized_sha256=None,
…     fingerprint=None,
…     etag=None,
…     last_modified=None,
…     downloaded_at=”2024-01-01T00:00:00Z”,
…     target_formats=(“owl”,),
…     validation={},
…     artifacts=(),
…     resolver_attempts=(),
… )
manifest.resolver
‘obo’</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="resolver">
<h3><code class="docutils literal notranslate"><span class="pre">Resolver</span></code><a class="headerlink" href="#resolver" title="Link to this heading"></a></h3>
<p>Protocol describing resolver planning behaviour.</p>
<p>Attributes:
None</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>import logging
spec = FetchSpec(id=”CHEBI”, resolver=”dummy”, extras={}, target_formats=(“owl”,))
class DummyResolver:
…     def plan(self, spec, config, logger):
…         return FetchPlan(
…             url=”https://example.org/chebi.owl”,
…             headers={},
…             filename_hint=”chebi.owl”,
…             version=”v1”,
…             license=”CC-BY”,
…             media_type=”application/rdf+xml”,
…         )
…
plan = DummyResolver().plan(spec, ResolvedConfig.from_defaults(), logging.getLogger(“test”))
plan.url
‘https://example.org/chebi.owl’</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="resolvercandidate">
<h3><code class="docutils literal notranslate"><span class="pre">ResolverCandidate</span></code><a class="headerlink" href="#resolvercandidate" title="Link to this heading"></a></h3>
<p>Resolver plan captured for download-time fallback.</p>
<p>Attributes:
resolver: Name of the resolver that produced the plan.
plan: Concrete :class:<code class="docutils literal notranslate"><span class="pre">FetchPlan</span></code> describing how to fetch the ontology.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>candidate = ResolverCandidate(
…     resolver=”obo”,
…     plan=FetchPlan(
…         url=”https://example.org/hp.owl”,
…         headers={},
…         filename_hint=None,
…         version=”2024-01-01”,
…         license=”CC-BY”,
…         media_type=”application/rdf+xml”,
…         service=”obo”,
…     ),
… )
candidate.resolver
‘obo’</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="plannedfetch">
<h3><code class="docutils literal notranslate"><span class="pre">PlannedFetch</span></code><a class="headerlink" href="#plannedfetch" title="Link to this heading"></a></h3>
<p>Plan describing how an ontology would be fetched without side effects.</p>
<p>Attributes:
spec: Original fetch specification provided by the caller.
resolver: Name of the resolver selected to satisfy the plan.
plan: Concrete :class:<code class="docutils literal notranslate"><span class="pre">FetchPlan</span></code> generated by the resolver.
candidates: Ordered list of resolver candidates available for fallback.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>fetch_plan = PlannedFetch(
…     spec=FetchSpec(id=”hp”, resolver=”obo”, extras={}, target_formats=(“owl”,)),
…     resolver=”obo”,
…     plan=FetchPlan(
…         url=”https://example.org/hp.owl”,
…         headers={},
…         filename_hint=”hp.owl”,
…         version=”2024-01-01”,
…         license=”CC-BY-4.0”,
…         media_type=”application/rdf+xml”,
…     ),
…     candidates=(
…         ResolverCandidate(
…             resolver=”obo”,
…             plan=FetchPlan(
…                 url=”https://example.org/hp.owl”,
…                 headers={},
…                 filename_hint=”hp.owl”,
…                 version=”2024-01-01”,
…                 license=”CC-BY-4.0”,
…                 media_type=”application/rdf+xml”,
…             ),
…         ),
…     ),
… )
fetch_plan.resolver
‘obo’</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="stubontology">
<h3><code class="docutils literal notranslate"><span class="pre">_StubOntology</span></code><a class="headerlink" href="#stubontology" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="id17">
<h3><code class="docutils literal notranslate"><span class="pre">_StubOntology</span></code><a class="headerlink" href="#id17" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="alarm">
<h3><code class="docutils literal notranslate"><span class="pre">_Alarm</span></code><a class="headerlink" href="#alarm" title="Link to this heading"></a></h3>
<p>Sentinel exception raised when the alarm signal fires.</p>
<p>Args:
message: Optional description associated with the exception.</p>
<p>Attributes:
message: Optional description associated with the exception.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>try:
…     raise _Alarm()
… except _Alarm:
…     pass</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, DocsToKG Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>