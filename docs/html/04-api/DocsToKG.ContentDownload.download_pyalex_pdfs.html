

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>1. Module: download_pyalex_pdfs &mdash; DocsToKG 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/css/custom.css" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=8d563738"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            DocsToKG
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../01-overview/index.html">1. Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02-setup/index.html">1. Setup Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03-architecture/index.html">1. Architecture Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html">1. API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05-development/index.html">1. Development Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06-operations/index.html">1. Operations Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07-reference/index.html">1. Technical Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">DocsToKG</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">1. Module: download_pyalex_pdfs</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/04-api/DocsToKG.ContentDownload.download_pyalex_pdfs.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-download-pyalex-pdfs">
<h1>1. Module: download_pyalex_pdfs<a class="headerlink" href="#module-download-pyalex-pdfs" title="Link to this heading"></a></h1>
<p>This reference documents the DocsToKG module <code class="docutils literal notranslate"><span class="pre">DocsToKG.ContentDownload.download_pyalex_pdfs</span></code>.</p>
<p>OpenAlex PDF Downloader CLI</p>
<p>This module implements the command-line interface responsible for downloading
open-access PDFs referenced by OpenAlex works. It combines resolver discovery,
content classification, manifest logging, and polite crawling behaviours into a
single executable entrypoint. The implementation aligns with the modular content
download architecture documented in the OpenSpec proposal and exposes hooks for
custom resolver configuration, dry-run execution, and manifest resume logic.</p>
<p>Key Features:</p>
<ul class="simple">
<li><p>Threaded resolver pipeline with conditional request caching.</p></li>
<li><p>Thread-safe JSONL/CSV logging including manifest entries and attempt metrics.</p></li>
<li><p>Streaming content hashing with corruption detection heuristics for PDFs.</p></li>
<li><p>Centralised retry handling and polite header management for resolver requests.</p></li>
<li><p>Single-request download path (no redundant HEAD probes) with classification via
streamed sniff buffers.</p></li>
<li><p>CLI flags for controlling topic selection, time ranges, resolver order, and
polite crawling identifiers.</p></li>
<li><p>Optional global URL deduplication and domain-level throttling controls for
large-scale crawls.</p></li>
</ul>
<p>Dependencies:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">requests</span></code>: HTTP communication and connection pooling adapters.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pyalex</span></code>: Query construction for OpenAlex works and topics.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DocsToKG.ContentDownload</span></code> submodules: Resolver pipeline orchestration,
conditional caching, and shared utilities.</p></li>
</ul>
<p>Usage:
python -m DocsToKG.ContentDownload.download_pyalex_pdfs <br />
–topic “knowledge graphs” –year-start 2020 –year-end 2023 <br />
–out ./pdfs –resolver-config download_config.yaml</p>
<section id="functions">
<h2>1. Functions<a class="headerlink" href="#functions" title="Link to this heading"></a></h2>
<section id="utc-timestamp">
<h3><code class="docutils literal notranslate"><span class="pre">_utc_timestamp()</span></code><a class="headerlink" href="#utc-timestamp" title="Link to this heading"></a></h3>
<p>Return the current time as an ISO 8601 UTC timestamp.</p>
<p>Returns:
Timestamp string formatted with a trailing <code class="docutils literal notranslate"><span class="pre">'Z'</span></code> suffix.</p>
</section>
<section id="has-pdf-eof-path">
<h3><code class="docutils literal notranslate"><span class="pre">_has_pdf_eof(path)</span></code><a class="headerlink" href="#has-pdf-eof-path" title="Link to this heading"></a></h3>
<p>Check whether a PDF file terminates with the <code class="docutils literal notranslate"><span class="pre">%%EOF</span></code> marker.</p>
<p>Args:
path: Path to the candidate PDF file.</p>
<p>Returns:
<code class="docutils literal notranslate"><span class="pre">True</span></code> if the file ends with <code class="docutils literal notranslate"><span class="pre">%%EOF</span></code>; <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</section>
<section id="slugify-text-keep">
<h3><code class="docutils literal notranslate"><span class="pre">slugify(text,</span> <span class="pre">keep)</span></code><a class="headerlink" href="#slugify-text-keep" title="Link to this heading"></a></h3>
<p>Create a filesystem-friendly slug for a work title.</p>
<p>Args:
text: Input string to normalize into a slug.
keep: Maximum number of characters to retain.</p>
<p>Returns:
Sanitized slug string suitable for filenames.</p>
</section>
<section id="ensure-dir-path">
<h3><code class="docutils literal notranslate"><span class="pre">ensure_dir(path)</span></code><a class="headerlink" href="#ensure-dir-path" title="Link to this heading"></a></h3>
<p>Create a directory if it does not already exist.</p>
<p>Args:
path: Directory path to create when absent.</p>
<p>Returns:
None</p>
<p>Raises:
OSError: If the directory cannot be created because of permissions.</p>
</section>
<section id="parse-domain-interval-value">
<h3><code class="docutils literal notranslate"><span class="pre">_parse_domain_interval(value)</span></code><a class="headerlink" href="#parse-domain-interval-value" title="Link to this heading"></a></h3>
<p>Parse <code class="docutils literal notranslate"><span class="pre">DOMAIN=SECONDS</span></code> CLI arguments for domain throttling.</p>
<p>Args:
value: Argument provided via <code class="docutils literal notranslate"><span class="pre">--domain-min-interval</span></code>.</p>
<p>Returns:
Tuple containing the normalized domain name and interval seconds.</p>
<p>Raises:
argparse.ArgumentTypeError: If the argument is malformed or negative.</p>
</section>
<section id="make-session-headers">
<h3><code class="docutils literal notranslate"><span class="pre">_make_session(headers)</span></code><a class="headerlink" href="#make-session-headers" title="Link to this heading"></a></h3>
<p>Create a :class:<code class="docutils literal notranslate"><span class="pre">requests.Session</span></code> configured for polite crawling.</p>
<p>Adapter-level retries remain disabled so :func:<code class="docutils literal notranslate"><span class="pre">request_with_retries</span></code> fully
controls backoff, ensuring deterministic retry counts across the pipeline.</p>
<p>Args:
headers: Header dictionary returned by :func:<code class="docutils literal notranslate"><span class="pre">load_resolver_config</span></code>. The mapping
must already include the project user agent and <code class="docutils literal notranslate"><span class="pre">mailto</span></code> contact address.
A copy of the mapping is applied to the outgoing session so callers can
reuse mutable dictionaries without side effects.</p>
<p>Returns:
requests.Session: Session with connection pooling enabled and retries
disabled at the adapter level so the application layer governs
backoff behaviour.</p>
<p>Notes:
Each worker should call this helper to obtain an isolated session instance.
Example:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>_make_session({“User-Agent”: “DocsToKGDownloader/1.0”, “mailto”: “ops&#64;example.org”})  # doctest: +ELLIPSIS
&lt;requests.sessions.Session object at …&gt;</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
<p>The returned session is safe for concurrent HTTP requests because
:class:<code class="docutils literal notranslate"><span class="pre">requests.adapters.HTTPAdapter</span></code> manages a thread-safe connection
pool. Avoid mutating shared session state (for example <code class="docutils literal notranslate"><span class="pre">session.headers.update</span></code>)
once the session is handed to worker threads.</p>
</section>
<section id="load-previous-manifest-path">
<h3><code class="docutils literal notranslate"><span class="pre">load_previous_manifest(path)</span></code><a class="headerlink" href="#load-previous-manifest-path" title="Link to this heading"></a></h3>
<p>Load manifest JSONL entries indexed by work identifier.</p>
<p>Args:
path: Path to a previous manifest JSONL log, or None.</p>
<p>Returns:
Tuple containing:</p>
<ul class="simple">
<li><p>Mapping of work_id -&gt; url -&gt; manifest payloads</p></li>
<li><p>Set of work IDs already completed</p></li>
</ul>
<p>Raises:
json.JSONDecodeError: If the manifest contains invalid JSON.</p>
</section>
<section id="build-manifest-entry-artifact-resolver-url-outcome-html-paths">
<h3><code class="docutils literal notranslate"><span class="pre">build_manifest_entry(artifact,</span> <span class="pre">resolver,</span> <span class="pre">url,</span> <span class="pre">outcome,</span> <span class="pre">html_paths)</span></code><a class="headerlink" href="#build-manifest-entry-artifact-resolver-url-outcome-html-paths" title="Link to this heading"></a></h3>
<p>Create a manifest entry summarizing a download attempt.</p>
<p>Args:
artifact: Work artifact providing metadata.
resolver: Resolver name responsible for the download.
url: URL that was attempted.
outcome: Download outcome describing classification and metadata.
html_paths: Any HTML paths captured during the attempt.
dry_run: Whether this was a dry-run execution.
reason: Optional reason string for failures.</p>
<p>Returns:
ManifestEntry populated with download metadata.</p>
</section>
<section id="classify-payload-head-bytes-content-type-url">
<h3><code class="docutils literal notranslate"><span class="pre">classify_payload(head_bytes,</span> <span class="pre">content_type,</span> <span class="pre">url)</span></code><a class="headerlink" href="#classify-payload-head-bytes-content-type-url" title="Link to this heading"></a></h3>
<p>Classify a payload as PDF, HTML, or unknown based on heuristics.</p>
<p>Args:
head_bytes: Leading bytes from the HTTP payload.
content_type: Content-Type header reported by the server.
url: Source URL of the payload.</p>
<p>Returns:
Classification string <code class="docutils literal notranslate"><span class="pre">&quot;pdf&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;html&quot;</span></code> when detection succeeds,
otherwise <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Raises:
UnicodeDecodeError: If heuristics attempt to decode malformed byte
sequences while inspecting the payload prefix.</p>
</section>
<section id="extract-filename-from-disposition-disposition">
<h3><code class="docutils literal notranslate"><span class="pre">_extract_filename_from_disposition(disposition)</span></code><a class="headerlink" href="#extract-filename-from-disposition-disposition" title="Link to this heading"></a></h3>
<p>Return the filename component from a Content-Disposition header.</p>
</section>
<section id="infer-suffix-url-content-type-disposition-classification-default-suffix">
<h3><code class="docutils literal notranslate"><span class="pre">_infer_suffix(url,</span> <span class="pre">content_type,</span> <span class="pre">disposition,</span> <span class="pre">classification,</span> <span class="pre">default_suffix)</span></code><a class="headerlink" href="#infer-suffix-url-content-type-disposition-classification-default-suffix" title="Link to this heading"></a></h3>
<p>Infer a destination suffix from HTTP hints and classification heuristics.</p>
<p>Args:
url: Candidate download URL emitted by a resolver.
content_type: Content-Type header returned by the response (if any).
disposition: Raw Content-Disposition header for RFC 6266 parsing.
classification: Downloader classification such as <code class="docutils literal notranslate"><span class="pre">&quot;pdf&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;html&quot;</span></code>.
default_suffix: Fallback extension to use when no signals are present.</p>
<p>Returns:
Lowercase file suffix (including leading dot) chosen from the strongest
available signal. Preference order is:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">filename*</span></code> / <code class="docutils literal notranslate"><span class="pre">filename</span></code> parameters in Content-Disposition.</p></li>
<li><p>Content-Type heuristics (PDF/HTML).</p></li>
<li><p>URL path suffix derived from :func:<code class="docutils literal notranslate"><span class="pre">urllib.parse.urlsplit</span></code>.</p></li>
<li><p>Provided <code class="docutils literal notranslate"><span class="pre">default_suffix</span></code>.</p></li>
</ol>
</section>
<section id="update-tail-buffer-buffer-chunk">
<h3><code class="docutils literal notranslate"><span class="pre">_update_tail_buffer(buffer,</span> <span class="pre">chunk)</span></code><a class="headerlink" href="#update-tail-buffer-buffer-chunk" title="Link to this heading"></a></h3>
<p>Maintain the trailing <code class="docutils literal notranslate"><span class="pre">limit</span></code> bytes of a streamed download.</p>
</section>
<section id="build-download-outcome">
<h3><code class="docutils literal notranslate"><span class="pre">_build_download_outcome()</span></code><a class="headerlink" href="#build-download-outcome" title="Link to this heading"></a></h3>
<p>Create a :class:<code class="docutils literal notranslate"><span class="pre">DownloadOutcome</span></code> applying PDF validation rules.</p>
<p>The helper normalises classification labels, performs the terminal <code class="docutils literal notranslate"><span class="pre">%%EOF</span></code>
check for PDFs (skipping when running in <code class="docutils literal notranslate"><span class="pre">--dry-run</span></code> mode), and attaches
bookkeeping metadata such as digests and conditional request headers.</p>
<p>Args:
artifact: Work metadata describing the current OpenAlex record.
classification: Initial classification derived from content sniffing.
dest_path: Final storage path for the artefact (if any).
response: HTTP response object returned by :func:<code class="docutils literal notranslate"><span class="pre">request_with_retries</span></code>.
elapsed_ms: Download duration in milliseconds.
flagged_unknown: Whether heuristics flagged the payload as ambiguous.
sha256: SHA-256 digest of the payload when computed.
content_length: Size of the payload in bytes, if known.
etag: ETag header value supplied by the origin.
last_modified: Last-Modified header value supplied by the origin.
extracted_text_path: Optional path to extracted HTML text artefacts.
tail_bytes: Trailing bytes captured from the streamed download for
corruption detection heuristics.
dry_run: Indicates whether this execution runs in dry-run mode.</p>
<p>Returns:
DownloadOutcome capturing the normalized classification and metadata.</p>
</section>
<section id="normalize-pmid-pmid">
<h3><code class="docutils literal notranslate"><span class="pre">_normalize_pmid(pmid)</span></code><a class="headerlink" href="#normalize-pmid-pmid" title="Link to this heading"></a></h3>
<p>Extract the numeric PubMed identifier or return <code class="docutils literal notranslate"><span class="pre">None</span></code> when absent.</p>
<p>Args:
pmid: Raw PubMed identifier string which may include prefixes.</p>
<p>Returns:
Normalised numeric PMCID string or <code class="docutils literal notranslate"><span class="pre">None</span></code> when not parsable.</p>
</section>
<section id="normalize-arxiv-arxiv-id">
<h3><code class="docutils literal notranslate"><span class="pre">_normalize_arxiv(arxiv_id)</span></code><a class="headerlink" href="#normalize-arxiv-arxiv-id" title="Link to this heading"></a></h3>
<p>Normalize arXiv identifiers by removing prefixes and whitespace.</p>
<p>Args:
arxiv_id: Raw arXiv identifier which may include URL or prefix.</p>
<p>Returns:
Canonical arXiv identifier without prefixes or whitespace.</p>
</section>
<section id="collect-location-urls-work">
<h3><code class="docutils literal notranslate"><span class="pre">_collect_location_urls(work)</span></code><a class="headerlink" href="#collect-location-urls-work" title="Link to this heading"></a></h3>
<p>Return landing/PDF/source URL collections derived from OpenAlex metadata.</p>
<p>Args:
work: OpenAlex work payload as returned by the Works API.</p>
<p>Returns:
Dictionary containing <code class="docutils literal notranslate"><span class="pre">landing</span></code>, <code class="docutils literal notranslate"><span class="pre">pdf</span></code>, and <code class="docutils literal notranslate"><span class="pre">sources</span></code> URL lists.</p>
</section>
<section id="build-query-args">
<h3><code class="docutils literal notranslate"><span class="pre">build_query(args)</span></code><a class="headerlink" href="#build-query-args" title="Link to this heading"></a></h3>
<p>Build a pyalex Works query based on CLI arguments.</p>
<p>Args:
args: Parsed command-line arguments.</p>
<p>Returns:
Configured Works query object ready for iteration.</p>
</section>
<section id="resolve-topic-id-if-needed-topic-text">
<h3><code class="docutils literal notranslate"><span class="pre">resolve_topic_id_if_needed(topic_text)</span></code><a class="headerlink" href="#resolve-topic-id-if-needed-topic-text" title="Link to this heading"></a></h3>
<p>Resolve a textual topic label into an OpenAlex topic identifier.</p>
<p>Args:
topic_text: Free-form topic text supplied via CLI.</p>
<p>Returns:
OpenAlex topic identifier string if resolved, else None.</p>
</section>
<section id="create-artifact-work-pdf-dir-html-dir">
<h3><code class="docutils literal notranslate"><span class="pre">create_artifact(work,</span> <span class="pre">pdf_dir,</span> <span class="pre">html_dir)</span></code><a class="headerlink" href="#create-artifact-work-pdf-dir-html-dir" title="Link to this heading"></a></h3>
<p>Normalize an OpenAlex work into a WorkArtifact instance.</p>
<p>Args:
work: Raw OpenAlex work payload.
pdf_dir: Directory where PDFs should be stored.
html_dir: Directory where HTML resources should be stored.</p>
<p>Returns:
WorkArtifact describing the work and candidate URLs.</p>
<p>Raises:
KeyError: If required identifiers are missing from the work payload.</p>
</section>
<section id="download-candidate-session-artifact-url-referer-timeout-context-head-precheck-passed">
<h3><code class="docutils literal notranslate"><span class="pre">download_candidate(session,</span> <span class="pre">artifact,</span> <span class="pre">url,</span> <span class="pre">referer,</span> <span class="pre">timeout,</span> <span class="pre">context,</span> <span class="pre">head_precheck_passed)</span></code><a class="headerlink" href="#download-candidate-session-artifact-url-referer-timeout-context-head-precheck-passed" title="Link to this heading"></a></h3>
<p>Download a single candidate URL and classify the payload.</p>
<p>Args:
session: HTTP session capable of issuing retried requests via the
centralised :func:<code class="docutils literal notranslate"><span class="pre">request_with_retries</span></code> helper.
artifact: Work metadata and output directory handles for the current record.
url: Candidate download URL discovered by a resolver.
referer: Optional referer header override provided by the resolver.
timeout: Per-request timeout in seconds.
context: Execution context containing <code class="docutils literal notranslate"><span class="pre">dry_run</span></code>, <code class="docutils literal notranslate"><span class="pre">extract_html_text</span></code>,
and <code class="docutils literal notranslate"><span class="pre">previous</span></code> manifest lookup data.</p>
<p>Returns:
DownloadOutcome describing the result of the download attempt including
streaming hash metadata when available.</p>
<p>Raises:
OSError: If writing the downloaded payload to disk fails.
TypeError: If conditional response parsing returns unexpected objects.</p>
</section>
<section id="read-resolver-config-path">
<h3><code class="docutils literal notranslate"><span class="pre">read_resolver_config(path)</span></code><a class="headerlink" href="#read-resolver-config-path" title="Link to this heading"></a></h3>
<p>Read resolver configuration from JSON or YAML files.</p>
<p>Args:
path: Path to the configuration file.</p>
<p>Returns:
Parsed configuration mapping.</p>
<p>Raises:
RuntimeError: If YAML parsing is requested but PyYAML is unavailable.</p>
</section>
<section id="apply-config-overrides-config-data-resolver-names">
<h3><code class="docutils literal notranslate"><span class="pre">apply_config_overrides(config,</span> <span class="pre">data,</span> <span class="pre">resolver_names)</span></code><a class="headerlink" href="#apply-config-overrides-config-data-resolver-names" title="Link to this heading"></a></h3>
<p>Apply overrides from configuration data onto a ResolverConfig.</p>
<p>Args:
config: Resolver configuration object to mutate.
data: Mapping loaded from a configuration file.
resolver_names: Known resolver names to seed toggle defaults.</p>
<p>Returns:
None</p>
</section>
<section id="load-resolver-config-args-resolver-names-resolver-order-override">
<h3><code class="docutils literal notranslate"><span class="pre">load_resolver_config(args,</span> <span class="pre">resolver_names,</span> <span class="pre">resolver_order_override)</span></code><a class="headerlink" href="#load-resolver-config-args-resolver-names-resolver-order-override" title="Link to this heading"></a></h3>
<p>Construct resolver configuration combining CLI, config files, and env vars.</p>
<p>Args:
args: Parsed CLI arguments.
resolver_names: Sequence of resolver names supported by the pipeline.
resolver_order_override: Optional override list for resolver order.</p>
<p>Returns:
Populated ResolverConfig instance.</p>
<p>Raises:
FileNotFoundError: If the resolver configuration file does not exist.
RuntimeError: If YAML parsing is requested but PyYAML is unavailable.</p>
</section>
<section id="iterate-openalex-query-per-page-max-results">
<h3><code class="docutils literal notranslate"><span class="pre">iterate_openalex(query,</span> <span class="pre">per_page,</span> <span class="pre">max_results)</span></code><a class="headerlink" href="#iterate-openalex-query-per-page-max-results" title="Link to this heading"></a></h3>
<p>Iterate over OpenAlex works respecting pagination and limits.</p>
<p>Args:
query: Configured Works query instance.
per_page: Number of results to request per page.
max_results: Optional maximum number of works to yield.</p>
<p>Yields:
Work payload dictionaries returned by the OpenAlex API.</p>
<p>Returns:
Iterable yielding the same work payload dictionaries for convenience.</p>
</section>
<section id="process-one-work-work-session-pdf-dir-html-dir-pipeline-logger-metrics">
<h3><code class="docutils literal notranslate"><span class="pre">process_one_work(work,</span> <span class="pre">session,</span> <span class="pre">pdf_dir,</span> <span class="pre">html_dir,</span> <span class="pre">pipeline,</span> <span class="pre">logger,</span> <span class="pre">metrics)</span></code><a class="headerlink" href="#process-one-work-work-session-pdf-dir-html-dir-pipeline-logger-metrics" title="Link to this heading"></a></h3>
<p>Process a single OpenAlex work through the resolver pipeline.</p>
<p>Args:
work: OpenAlex work payload from :func:<code class="docutils literal notranslate"><span class="pre">iterate_openalex</span></code>.
session: Requests session configured for resolver usage.
pdf_dir: Directory where PDF artefacts are written.
html_dir: Directory where HTML artefacts are written.
pipeline: Resolver pipeline orchestrating downstream resolvers.
logger: Structured attempt logger capturing manifest records.
metrics: Resolver metrics collector.
dry_run: When True, simulate downloads without writing files.
extract_html_text: Whether to extract plaintext from HTML artefacts.
previous_lookup: Mapping of work_id/URL to prior manifest entries.
resume_completed: Set of work IDs already processed in resume mode.</p>
<p>Returns:
Dictionary summarizing the outcome (saved/html_only/skipped flags).</p>
<p>Raises:
requests.RequestException: Propagated if resolver HTTP requests fail
unexpectedly outside guarded sections.
Exception: Bubbling from resolver pipeline internals when not handled.</p>
</section>
<section id="main">
<h3><code class="docutils literal notranslate"><span class="pre">main()</span></code><a class="headerlink" href="#main" title="Link to this heading"></a></h3>
<p>Parse CLI arguments, configure resolvers, and execute downloads.</p>
<p>The entrypoint wires together argument parsing, resolver configuration,
logging setup, and the resolver pipeline orchestration documented in the
modular content download specification. It is exposed both as the module’s
<code class="docutils literal notranslate"><span class="pre">__main__</span></code> handler and via <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span></code>.</p>
<p>Args:
None</p>
<p>Returns:
None</p>
</section>
<section id="write-self-payload">
<h3><code class="docutils literal notranslate"><span class="pre">_write(self,</span> <span class="pre">payload)</span></code><a class="headerlink" href="#write-self-payload" title="Link to this heading"></a></h3>
<p>Append a JSON record to the log file ensuring timestamps are present.</p>
<p>Args:
payload: JSON-serializable mapping to write.</p>
<p>Returns:
None</p>
</section>
<section id="log-attempt-self-record">
<h3><code class="docutils literal notranslate"><span class="pre">log_attempt(self,</span> <span class="pre">record)</span></code><a class="headerlink" href="#log-attempt-self-record" title="Link to this heading"></a></h3>
<p>Record a resolver attempt entry.</p>
<p>Args:
record: Attempt metadata captured from the resolver pipeline.
timestamp: Optional override timestamp (ISO format).</p>
<p>Returns:
None</p>
</section>
<section id="log-self-record">
<h3><code class="docutils literal notranslate"><span class="pre">log(self,</span> <span class="pre">record)</span></code><a class="headerlink" href="#log-self-record" title="Link to this heading"></a></h3>
<p>Compatibility shim mapping to :meth:<code class="docutils literal notranslate"><span class="pre">log_attempt</span></code>.</p>
<p>Args:
record: Attempt record to forward to :meth:<code class="docutils literal notranslate"><span class="pre">log_attempt</span></code>.</p>
<p>Returns:
None</p>
</section>
<section id="log-manifest-self-entry">
<h3><code class="docutils literal notranslate"><span class="pre">log_manifest(self,</span> <span class="pre">entry)</span></code><a class="headerlink" href="#log-manifest-self-entry" title="Link to this heading"></a></h3>
<p>Persist a manifest entry to the JSONL log.</p>
<p>Args:
entry: Manifest entry to write.</p>
<p>Returns:
None</p>
</section>
<section id="log-summary-self-summary">
<h3><code class="docutils literal notranslate"><span class="pre">log_summary(self,</span> <span class="pre">summary)</span></code><a class="headerlink" href="#log-summary-self-summary" title="Link to this heading"></a></h3>
<p>Write a summary record to the log.</p>
<p>Args:
summary: Mapping containing summary metrics.</p>
<p>Returns:
None</p>
</section>
<section id="close-self">
<h3><code class="docutils literal notranslate"><span class="pre">close(self)</span></code><a class="headerlink" href="#close-self" title="Link to this heading"></a></h3>
<p>Close the underlying file handle.</p>
<p>Args:
self: Logger instance managing the JSONL file descriptor.</p>
<p>Returns:
None</p>
</section>
<section id="enter-self">
<h3><code class="docutils literal notranslate"><span class="pre">__enter__(self)</span></code><a class="headerlink" href="#enter-self" title="Link to this heading"></a></h3>
<p>Return <code class="docutils literal notranslate"><span class="pre">self</span></code> when used as a context manager.</p>
<p>Args:
None</p>
<p>Returns:
Logger instance configured for context-managed usage.</p>
</section>
<section id="exit-self-exc-type-exc-tb">
<h3><code class="docutils literal notranslate"><span class="pre">__exit__(self,</span> <span class="pre">exc_type,</span> <span class="pre">exc,</span> <span class="pre">tb)</span></code><a class="headerlink" href="#exit-self-exc-type-exc-tb" title="Link to this heading"></a></h3>
<p>Close the file handle on context manager exit.</p>
<p>Args:
exc_type: Exception type raised within the context, if any.
exc: Exception instance raised within the context.
tb: Traceback associated with <code class="docutils literal notranslate"><span class="pre">exc</span></code>.</p>
<p>Returns:
None</p>
</section>
<section id="id1">
<h3><code class="docutils literal notranslate"><span class="pre">log_attempt(self,</span> <span class="pre">record)</span></code><a class="headerlink" href="#id1" title="Link to this heading"></a></h3>
<p>Write an attempt record to both JSONL and CSV outputs.</p>
<p>Args:
record: Attempt record to persist.</p>
<p>Returns:
None</p>
</section>
<section id="id2">
<h3><code class="docutils literal notranslate"><span class="pre">log_manifest(self,</span> <span class="pre">entry)</span></code><a class="headerlink" href="#id2" title="Link to this heading"></a></h3>
<p>Forward manifest entries to the JSONL logger.</p>
<p>Args:
entry: Manifest entry to forward.</p>
<p>Returns:
None</p>
</section>
<section id="id3">
<h3><code class="docutils literal notranslate"><span class="pre">log_summary(self,</span> <span class="pre">summary)</span></code><a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<p>Forward summary entries to the JSONL logger.</p>
<p>Args:
summary: Summary mapping to forward.</p>
<p>Returns:
None</p>
</section>
<section id="id4">
<h3><code class="docutils literal notranslate"><span class="pre">log(self,</span> <span class="pre">record)</span></code><a class="headerlink" href="#id4" title="Link to this heading"></a></h3>
<p>Compatibility shim mapping to :meth:<code class="docutils literal notranslate"><span class="pre">log_attempt</span></code>.</p>
<p>Args:
record: Attempt record to log.</p>
<p>Returns:
None</p>
</section>
<section id="id5">
<h3><code class="docutils literal notranslate"><span class="pre">close(self)</span></code><a class="headerlink" href="#id5" title="Link to this heading"></a></h3>
<p>Close both the JSONL logger and the CSV file handle.</p>
<p>Args:
self: Adapter instance coordinating CSV and JSONL streams.</p>
<p>Returns:
None</p>
</section>
<section id="id6">
<h3><code class="docutils literal notranslate"><span class="pre">__enter__(self)</span></code><a class="headerlink" href="#id6" title="Link to this heading"></a></h3>
<p>Return <code class="docutils literal notranslate"><span class="pre">self</span></code> when used as a context manager.</p>
<p>Args:
None</p>
<p>Returns:
Adapter instance configured for context-managed usage.</p>
</section>
<section id="id7">
<h3><code class="docutils literal notranslate"><span class="pre">__exit__(self,</span> <span class="pre">exc_type,</span> <span class="pre">exc,</span> <span class="pre">tb)</span></code><a class="headerlink" href="#id7" title="Link to this heading"></a></h3>
<p>Close the CSV file handle on context manager exit.</p>
<p>Args:
exc_type: Exception type raised within the context, if any.
exc: Exception instance raised within the context.
tb: Traceback associated with <code class="docutils literal notranslate"><span class="pre">exc</span></code>.</p>
<p>Returns:
None</p>
</section>
<section id="post-init-self">
<h3><code class="docutils literal notranslate"><span class="pre">__post_init__(self)</span></code><a class="headerlink" href="#post-init-self" title="Link to this heading"></a></h3>
<p>Define namespace mappings for output artefact directories.</p>
<p>Args:
self: Instance whose namespace mapping is being initialised.</p>
<p>Returns:
None</p>
</section>
<section id="append-location-loc">
<h3><code class="docutils literal notranslate"><span class="pre">_append_location(loc)</span></code><a class="headerlink" href="#append-location-loc" title="Link to this heading"></a></h3>
<p>Accumulate location URLs from a single OpenAlex location record.</p>
<p>Args:
loc: Location dictionary as returned by OpenAlex (may be None).</p>
</section>
<section id="session-factory">
<h3><code class="docutils literal notranslate"><span class="pre">_session_factory()</span></code><a class="headerlink" href="#session-factory" title="Link to this heading"></a></h3>
<p>Build a fresh requests session configured with polite headers.</p>
</section>
<section id="id8">
<h3><code class="docutils literal notranslate"><span class="pre">_session_factory()</span></code><a class="headerlink" href="#id8" title="Link to this heading"></a></h3>
<p>Build a fresh requests session configured with polite headers.</p>
</section>
<section id="record-result-res">
<h3><code class="docutils literal notranslate"><span class="pre">_record_result(res)</span></code><a class="headerlink" href="#record-result-res" title="Link to this heading"></a></h3>
<p>Update aggregate counters based on a single work result.</p>
</section>
<section id="submit-work-work-item">
<h3><code class="docutils literal notranslate"><span class="pre">_submit_work(work_item)</span></code><a class="headerlink" href="#submit-work-work-item" title="Link to this heading"></a></h3>
<p>Submit a work item to the executor for asynchronous processing.</p>
</section>
<section id="runner">
<h3><code class="docutils literal notranslate"><span class="pre">_runner()</span></code><a class="headerlink" href="#runner" title="Link to this heading"></a></h3>
<p>Process a single work item within a worker-managed session.</p>
</section>
</section>
<section id="classes">
<h2>2. Classes<a class="headerlink" href="#classes" title="Link to this heading"></a></h2>
<section id="manifestentry">
<h3><code class="docutils literal notranslate"><span class="pre">ManifestEntry</span></code><a class="headerlink" href="#manifestentry" title="Link to this heading"></a></h3>
<p>Structured record capturing the outcome of a resolver attempt.</p>
<p>Attributes:
timestamp: ISO timestamp when the manifest entry was created.
work_id: OpenAlex work identifier associated with the download.
title: Human-readable work title.
publication_year: Publication year when available.
resolver: Name of the resolver that produced the asset.
url: Source URL of the downloaded artifact.
path: Local filesystem path to the stored artifact.
classification: Classification label describing the outcome (e.g., ‘pdf’).
content_type: MIME type reported by the server.
reason: Failure or status reason for non-successful attempts.
html_paths: Paths to any captured HTML artifacts.
sha256: SHA-256 digest of the downloaded content.
content_length: Size of the artifact in bytes.
etag: HTTP ETag header value if provided.
last_modified: HTTP Last-Modified timestamp.
extracted_text_path: Optional path to extracted text content.
dry_run: Flag indicating whether the download was simulated.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>ManifestEntry(
…     timestamp=”2024-01-01T00:00:00Z”,
…     work_id=”W123”,
…     title=”Sample Work”,
…     publication_year=2024,
…     resolver=”unpaywall”,
…     url=”https://example.org/sample.pdf”,
…     path=”pdfs/sample.pdf”,
…     classification=”pdf”,
…     content_type=”application/pdf”,
…     reason=None,
…     dry_run=False,
… )</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="jsonllogger">
<h3><code class="docutils literal notranslate"><span class="pre">JsonlLogger</span></code><a class="headerlink" href="#jsonllogger" title="Link to this heading"></a></h3>
<p>Structured logger that emits attempt, manifest, and summary JSONL records.</p>
<p>Attributes:
_path: Destination JSONL log path.
_file: Underlying file handle used for writes.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>logger = JsonlLogger(Path(“logs/attempts.jsonl”))
logger.log_summary({“processed”: 10})
logger.close()</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
<p>The logger serialises records outside a thread lock and performs atomic
writes under the lock, ensuring well-formed output even when multiple
threads share the instance. It also implements the context manager protocol
for deterministic resource cleanup.</p>
</section>
<section id="csvattemptloggeradapter">
<h3><code class="docutils literal notranslate"><span class="pre">CsvAttemptLoggerAdapter</span></code><a class="headerlink" href="#csvattemptloggeradapter" title="Link to this heading"></a></h3>
<p>Adapter that mirrors attempt records to CSV for backward compatibility.</p>
<p>Attributes:
_logger: Underlying :class:<code class="docutils literal notranslate"><span class="pre">JsonlLogger</span></code> instance.
_file: CSV file handle used for writing.
_writer: <code class="docutils literal notranslate"><span class="pre">csv.DictWriter</span></code> writing to :attr:<code class="docutils literal notranslate"><span class="pre">_file</span></code>.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>adapter = CsvAttemptLoggerAdapter(JsonlLogger(Path(“attempts.jsonl”)), Path(“attempts.csv”))
adapter.log_attempt(AttemptRecord(work_id=”W1”, resolver_name=”unpaywall”, resolver_order=1,
…                                   url=”https://example”, status=”pdf”, http_status=200,
…                                   content_type=”application/pdf”, elapsed_ms=120.0))
adapter.close()</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
<p>CSV writes are protected by a lock to ensure rows remain well formed when
multiple worker threads log through the same adapter instance.</p>
</section>
<section id="workartifact">
<h3><code class="docutils literal notranslate"><span class="pre">WorkArtifact</span></code><a class="headerlink" href="#workartifact" title="Link to this heading"></a></h3>
<p>Normalized artifact describing an OpenAlex work to process.</p>
<p>Attributes:
work_id: OpenAlex work identifier.
title: Work title suitable for logging.
publication_year: Publication year or None.
doi: Canonical DOI string.
pmid: PubMed identifier (normalized).
pmcid: PubMed Central identifier (normalized).
arxiv_id: Normalized arXiv identifier.
landing_urls: Candidate landing page URLs.
pdf_urls: Candidate PDF download URLs.
open_access_url: Open access URL provided by OpenAlex.
source_display_names: Source names for provenance.
base_stem: Base filename stem for local artefacts.
pdf_dir: Directory where PDFs are stored.
html_dir: Directory where HTML assets are stored.
failed_pdf_urls: URLs that failed during resolution.
metadata: Arbitrary metadata collected during processing.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>artifact = WorkArtifact(
…     work_id=”W123”,
…     title=”Sample Work”,
…     publication_year=2024,
…     doi=”10.1234/example”,
…     pmid=None,
…     pmcid=None,
…     arxiv_id=None,
…     landing_urls=[“https://example.org”],
…     pdf_urls=[],
…     open_access_url=None,
…     source_display_names=[“Example Source”],
…     base_stem=”2024__Sample_Work__W123”,
…     pdf_dir=Path(“pdfs”),
…     html_dir=Path(“html”),
… )</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="downloadstate">
<h3><code class="docutils literal notranslate"><span class="pre">DownloadState</span></code><a class="headerlink" href="#downloadstate" title="Link to this heading"></a></h3>
<p>State machine for streaming downloads.</p>
<p>Attributes:
PENDING: Payload type is being sniffed.
WRITING: Payload bytes are being streamed to disk.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>DownloadState.PENDING is DownloadState.WRITING
False</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, DocsToKG Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>