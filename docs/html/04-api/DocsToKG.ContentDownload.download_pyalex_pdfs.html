

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>1. Module: download_pyalex_pdfs &mdash; DocsToKG 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/css/custom.css" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=8d563738"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            DocsToKG
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../01-overview/index.html">1. Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02-setup/index.html">1. Setup Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03-architecture/index.html">1. Architecture Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html">1. API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05-development/index.html">1. Development Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06-operations/index.html">1. Operations Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07-reference/index.html">1. Technical Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">DocsToKG</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">1. Module: download_pyalex_pdfs</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/04-api/DocsToKG.ContentDownload.download_pyalex_pdfs.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-download-pyalex-pdfs">
<h1>1. Module: download_pyalex_pdfs<a class="headerlink" href="#module-download-pyalex-pdfs" title="Link to this heading"></a></h1>
<p>This reference documents the DocsToKG module <code class="docutils literal notranslate"><span class="pre">DocsToKG.ContentDownload.download_pyalex_pdfs</span></code>.</p>
<section id="overview">
<h2>1. Overview<a class="headerlink" href="#overview" title="Link to this heading"></a></h2>
<p>OpenAlex PDF Downloader CLI</p>
<p>This module implements the command-line interface responsible for downloading
open-access PDFs referenced by OpenAlex works. It combines resolver discovery,
content classification, manifest logging, and polite crawling behaviours into a
single executable entrypoint. The implementation aligns with the modular content
download architecture documented in the OpenSpec proposal and exposes hooks for
custom resolver configuration, dry-run execution, and manifest resume logic.</p>
<p>Key Features:</p>
<ul class="simple">
<li><p>Threaded resolver pipeline with conditional request caching.</p></li>
<li><p>Thread-safe JSONL/CSV logging including manifest entries and attempt metrics.</p></li>
<li><p>Streaming content hashing with corruption detection heuristics for PDFs.</p></li>
<li><p>Centralised retry handling and polite header management for resolver requests.</p></li>
<li><p>Single-request download path (no redundant HEAD probes) with classification via
streamed sniff buffers.</p></li>
<li><p>CLI flags for controlling topic selection, time ranges, resolver order, and
polite crawling identifiers.</p></li>
<li><p>Optional global URL deduplication and domain-level throttling controls for
large-scale crawls.</p></li>
</ul>
<p>Dependencies:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">requests</span></code>: HTTP communication and connection pooling adapters.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pyalex</span></code>: Query construction for OpenAlex works and topics.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DocsToKG.ContentDownload</span></code> submodules: Resolver pipeline orchestration,
conditional caching, and shared utilities.</p></li>
</ul>
<p>Usage:
python -m DocsToKG.ContentDownload.download_pyalex_pdfs <br />
–topic “knowledge graphs” –year-start 2020 –year-end 2023 <br />
–out ./pdfs –resolver-config download_config.yaml</p>
</section>
<section id="functions">
<h2>2. Functions<a class="headerlink" href="#functions" title="Link to this heading"></a></h2>
<section id="utc-timestamp">
<h3><code class="docutils literal notranslate"><span class="pre">_utc_timestamp()</span></code><a class="headerlink" href="#utc-timestamp" title="Link to this heading"></a></h3>
<p>Return the current time as an ISO 8601 UTC timestamp.</p>
<p>Returns:
Timestamp string formatted with a trailing <code class="docutils literal notranslate"><span class="pre">'Z'</span></code> suffix.</p>
</section>
<section id="has-pdf-eof-path">
<h3><code class="docutils literal notranslate"><span class="pre">_has_pdf_eof(path)</span></code><a class="headerlink" href="#has-pdf-eof-path" title="Link to this heading"></a></h3>
<p>Check whether a PDF file terminates with the <code class="docutils literal notranslate"><span class="pre">%%EOF</span></code> marker.</p>
<p>Args:
path: Path to the candidate PDF file.</p>
<p>Returns:
<code class="docutils literal notranslate"><span class="pre">True</span></code> if the file ends with <code class="docutils literal notranslate"><span class="pre">%%EOF</span></code>; <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</section>
<section id="slugify-text-keep">
<h3><code class="docutils literal notranslate"><span class="pre">slugify(text,</span> <span class="pre">keep)</span></code><a class="headerlink" href="#slugify-text-keep" title="Link to this heading"></a></h3>
<p>Create a filesystem-friendly slug for a work title.</p>
<p>Args:
text: Input string to normalize into a slug.
keep: Maximum number of characters to retain.</p>
<p>Returns:
Sanitized slug string suitable for filenames.</p>
</section>
<section id="ensure-dir-path">
<h3><code class="docutils literal notranslate"><span class="pre">ensure_dir(path)</span></code><a class="headerlink" href="#ensure-dir-path" title="Link to this heading"></a></h3>
<p>Create a directory if it does not already exist.</p>
<p>Args:
path: Directory path to create when absent.</p>
<p>Returns:
None</p>
<p>Raises:
OSError: If the directory cannot be created because of permissions.</p>
</section>
<section id="parse-domain-interval-value">
<h3><code class="docutils literal notranslate"><span class="pre">_parse_domain_interval(value)</span></code><a class="headerlink" href="#parse-domain-interval-value" title="Link to this heading"></a></h3>
<p>Parse <code class="docutils literal notranslate"><span class="pre">DOMAIN=SECONDS</span></code> CLI arguments for domain throttling.</p>
<p>Args:
value: Argument provided via <code class="docutils literal notranslate"><span class="pre">--domain-min-interval</span></code>.</p>
<p>Returns:
Tuple containing the normalized domain name and interval seconds.</p>
<p>Raises:
argparse.ArgumentTypeError: If the argument is malformed or negative.</p>
</section>
<section id="make-session-headers">
<h3><code class="docutils literal notranslate"><span class="pre">_make_session(headers)</span></code><a class="headerlink" href="#make-session-headers" title="Link to this heading"></a></h3>
<p>Create a :class:<code class="docutils literal notranslate"><span class="pre">requests.Session</span></code> configured for polite crawling.</p>
<p>Adapter-level retries remain disabled so :func:<code class="docutils literal notranslate"><span class="pre">request_with_retries</span></code> fully
controls backoff, ensuring deterministic retry counts across the pipeline.</p>
<p>Args:
headers (Dict[str, str]): Header dictionary returned by
:func:<code class="docutils literal notranslate"><span class="pre">load_resolver_config</span></code>. The mapping must already include the
project user agent and <code class="docutils literal notranslate"><span class="pre">mailto</span></code> contact address. A copy of the
mapping is applied to the outgoing session so callers can reuse
mutable dictionaries without side effects.</p>
<p>Returns:
requests.Session: Session with connection pooling enabled and retries
disabled at the adapter level so the application layer governs backoff.</p>
<p>Notes:
Each worker should call this helper to obtain an isolated session instance.
Example:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>_make_session({“User-Agent”: “DocsToKGDownloader/1.0”, “mailto”: “ops&#64;example.org”})  # doctest: +ELLIPSIS
&lt;requests.sessions.Session object at …&gt;</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
<p>The returned session is safe for concurrent HTTP requests because
:class:<code class="docutils literal notranslate"><span class="pre">requests.adapters.HTTPAdapter</span></code> manages a thread-safe connection
pool. Avoid mutating shared session state (for example <code class="docutils literal notranslate"><span class="pre">session.headers.update</span></code>)
once the session is handed to worker threads.</p>
</section>
<section id="load-previous-manifest-path">
<h3><code class="docutils literal notranslate"><span class="pre">load_previous_manifest(path)</span></code><a class="headerlink" href="#load-previous-manifest-path" title="Link to this heading"></a></h3>
<p>Load manifest JSONL entries indexed by work identifier.</p>
<p>Args:
path: Path to a previous manifest JSONL log, or None.</p>
<p>Returns:
Tuple containing:</p>
<ul class="simple">
<li><p>Mapping of work_id -&gt; url -&gt; manifest payloads</p></li>
<li><p>Set of work IDs already completed</p></li>
</ul>
<p>Raises:
json.JSONDecodeError: If the manifest contains invalid JSON.
ValueError: If entries omit required fields or use deprecated schemas.</p>
</section>
<section id="build-manifest-entry-artifact-resolver-url-outcome-html-paths">
<h3><code class="docutils literal notranslate"><span class="pre">build_manifest_entry(artifact,</span> <span class="pre">resolver,</span> <span class="pre">url,</span> <span class="pre">outcome,</span> <span class="pre">html_paths)</span></code><a class="headerlink" href="#build-manifest-entry-artifact-resolver-url-outcome-html-paths" title="Link to this heading"></a></h3>
<p>Create a manifest entry summarizing a download attempt.</p>
<p>Args:
artifact: Work artifact providing metadata.
resolver: Resolver name responsible for the download.
url: URL that was attempted.
outcome: Download outcome describing classification and metadata.
html_paths: Any HTML paths captured during the attempt.
dry_run: Whether this was a dry-run execution.
reason: Optional reason string for failures.</p>
<p>Returns:
ManifestEntry populated with download metadata.</p>
</section>
<section id="classify-payload-head-bytes-content-type-url">
<h3><code class="docutils literal notranslate"><span class="pre">classify_payload(head_bytes,</span> <span class="pre">content_type,</span> <span class="pre">url)</span></code><a class="headerlink" href="#classify-payload-head-bytes-content-type-url" title="Link to this heading"></a></h3>
<p>Classify a payload as PDF, HTML, or unknown based on heuristics.</p>
<p>Args:
head_bytes: Leading bytes from the HTTP payload.
content_type: Content-Type header reported by the server.
url: Source URL of the payload.</p>
<p>Returns:
Classification string <code class="docutils literal notranslate"><span class="pre">&quot;pdf&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;html&quot;</span></code> when detection succeeds,
otherwise <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Raises:
UnicodeDecodeError: If heuristics attempt to decode malformed byte
sequences while inspecting the payload prefix.</p>
</section>
<section id="extract-filename-from-disposition-disposition">
<h3><code class="docutils literal notranslate"><span class="pre">_extract_filename_from_disposition(disposition)</span></code><a class="headerlink" href="#extract-filename-from-disposition-disposition" title="Link to this heading"></a></h3>
<p>Return the filename component from a Content-Disposition header.</p>
</section>
<section id="infer-suffix-url-content-type-disposition-classification-default-suffix">
<h3><code class="docutils literal notranslate"><span class="pre">_infer_suffix(url,</span> <span class="pre">content_type,</span> <span class="pre">disposition,</span> <span class="pre">classification,</span> <span class="pre">default_suffix)</span></code><a class="headerlink" href="#infer-suffix-url-content-type-disposition-classification-default-suffix" title="Link to this heading"></a></h3>
<p>Infer a destination suffix from HTTP hints and classification heuristics.</p>
<p>Args:
url: Candidate download URL emitted by a resolver.
content_type: Content-Type header returned by the response (if any).
disposition: Raw Content-Disposition header for RFC 6266 parsing.
classification: Downloader classification such as <code class="docutils literal notranslate"><span class="pre">&quot;pdf&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;html&quot;</span></code>.
default_suffix: Fallback extension to use when no signals are present.</p>
<p>Returns:
Lowercase file suffix (including leading dot) chosen from the strongest
available signal. Preference order is:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">filename*</span></code> / <code class="docutils literal notranslate"><span class="pre">filename</span></code> parameters in Content-Disposition.</p></li>
<li><p>Content-Type heuristics (PDF/HTML).</p></li>
<li><p>URL path suffix derived from :func:<code class="docutils literal notranslate"><span class="pre">urllib.parse.urlsplit</span></code>.</p></li>
<li><p>Provided <code class="docutils literal notranslate"><span class="pre">default_suffix</span></code>.</p></li>
</ol>
</section>
<section id="update-tail-buffer-buffer-chunk">
<h3><code class="docutils literal notranslate"><span class="pre">_update_tail_buffer(buffer,</span> <span class="pre">chunk)</span></code><a class="headerlink" href="#update-tail-buffer-buffer-chunk" title="Link to this heading"></a></h3>
<p>Maintain the trailing <code class="docutils literal notranslate"><span class="pre">limit</span></code> bytes of a streamed download.</p>
</section>
<section id="build-download-outcome">
<h3><code class="docutils literal notranslate"><span class="pre">_build_download_outcome()</span></code><a class="headerlink" href="#build-download-outcome" title="Link to this heading"></a></h3>
<p>Create a :class:<code class="docutils literal notranslate"><span class="pre">DownloadOutcome</span></code> applying PDF validation rules.</p>
<p>The helper normalises classification labels, performs the terminal <code class="docutils literal notranslate"><span class="pre">%%EOF</span></code>
check for PDFs (skipping when running in <code class="docutils literal notranslate"><span class="pre">--dry-run</span></code> mode), and attaches
bookkeeping metadata such as digests and conditional request headers.</p>
<p>Args:
artifact: Work metadata describing the current OpenAlex record.
classification: Initial classification derived from content sniffing.
dest_path: Final storage path for the artefact (if any).
response: HTTP response object returned by :func:<code class="docutils literal notranslate"><span class="pre">request_with_retries</span></code>.
elapsed_ms: Download duration in milliseconds.
flagged_unknown: Whether heuristics flagged the payload as ambiguous.
sha256: SHA-256 digest of the payload when computed.
content_length: Size of the payload in bytes, if known.
etag: ETag header value supplied by the origin.
last_modified: Last-Modified header value supplied by the origin.
extracted_text_path: Optional path to extracted HTML text artefacts.
tail_bytes: Trailing bytes captured from the streamed download for
corruption detection heuristics.
dry_run: Indicates whether this execution runs in dry-run mode.</p>
<p>Returns:
DownloadOutcome capturing the normalized classification and metadata.</p>
</section>
<section id="normalize-pmid-pmid">
<h3><code class="docutils literal notranslate"><span class="pre">_normalize_pmid(pmid)</span></code><a class="headerlink" href="#normalize-pmid-pmid" title="Link to this heading"></a></h3>
<p>Extract the numeric PubMed identifier or return <code class="docutils literal notranslate"><span class="pre">None</span></code> when absent.</p>
<p>Args:
pmid: Raw PubMed identifier string which may include prefixes.</p>
<p>Returns:
Normalised numeric PMCID string or <code class="docutils literal notranslate"><span class="pre">None</span></code> when not parsable.</p>
</section>
<section id="normalize-arxiv-arxiv-id">
<h3><code class="docutils literal notranslate"><span class="pre">_normalize_arxiv(arxiv_id)</span></code><a class="headerlink" href="#normalize-arxiv-arxiv-id" title="Link to this heading"></a></h3>
<p>Normalize arXiv identifiers by removing prefixes and whitespace.</p>
<p>Args:
arxiv_id: Raw arXiv identifier which may include URL or prefix.</p>
<p>Returns:
Canonical arXiv identifier without prefixes or whitespace.</p>
</section>
<section id="collect-location-urls-work">
<h3><code class="docutils literal notranslate"><span class="pre">_collect_location_urls(work)</span></code><a class="headerlink" href="#collect-location-urls-work" title="Link to this heading"></a></h3>
<p>Return landing/PDF/source URL collections derived from OpenAlex metadata.</p>
<p>Args:
work: OpenAlex work payload as returned by the Works API.</p>
<p>Returns:
Dictionary containing <code class="docutils literal notranslate"><span class="pre">landing</span></code>, <code class="docutils literal notranslate"><span class="pre">pdf</span></code>, and <code class="docutils literal notranslate"><span class="pre">sources</span></code> URL lists.</p>
</section>
<section id="build-query-args">
<h3><code class="docutils literal notranslate"><span class="pre">build_query(args)</span></code><a class="headerlink" href="#build-query-args" title="Link to this heading"></a></h3>
<p>Build a pyalex Works query based on CLI arguments.</p>
<p>Args:
args: Parsed command-line arguments.</p>
<p>Returns:
Configured Works query object ready for iteration.</p>
</section>
<section id="resolve-topic-id-if-needed-topic-text">
<h3><code class="docutils literal notranslate"><span class="pre">resolve_topic_id_if_needed(topic_text)</span></code><a class="headerlink" href="#resolve-topic-id-if-needed-topic-text" title="Link to this heading"></a></h3>
<p>Resolve a textual topic label into an OpenAlex topic identifier.</p>
<p>Args:
topic_text: Free-form topic text supplied via CLI.</p>
<p>Returns:
OpenAlex topic identifier string if resolved, else None.</p>
</section>
<section id="create-artifact-work-pdf-dir-html-dir">
<h3><code class="docutils literal notranslate"><span class="pre">create_artifact(work,</span> <span class="pre">pdf_dir,</span> <span class="pre">html_dir)</span></code><a class="headerlink" href="#create-artifact-work-pdf-dir-html-dir" title="Link to this heading"></a></h3>
<p>Normalize an OpenAlex work into a WorkArtifact instance.</p>
<p>Args:
work: Raw OpenAlex work payload.
pdf_dir: Directory where PDFs should be stored.
html_dir: Directory where HTML resources should be stored.</p>
<p>Returns:
WorkArtifact describing the work and candidate URLs.</p>
<p>Raises:
KeyError: If required identifiers are missing from the work payload.</p>
</section>
<section id="download-candidate-session-artifact-url-referer-timeout-context-head-precheck-passed">
<h3><code class="docutils literal notranslate"><span class="pre">download_candidate(session,</span> <span class="pre">artifact,</span> <span class="pre">url,</span> <span class="pre">referer,</span> <span class="pre">timeout,</span> <span class="pre">context,</span> <span class="pre">head_precheck_passed)</span></code><a class="headerlink" href="#download-candidate-session-artifact-url-referer-timeout-context-head-precheck-passed" title="Link to this heading"></a></h3>
<p>Download a single candidate URL and classify the payload.</p>
<p>Args:
session: HTTP session capable of issuing retried requests via the
centralised :func:<code class="docutils literal notranslate"><span class="pre">request_with_retries</span></code> helper.
artifact: Work metadata and output directory handles for the current record.
url: Candidate download URL discovered by a resolver.
referer: Optional referer header override provided by the resolver.
timeout: Per-request timeout in seconds.
context: Execution context containing <code class="docutils literal notranslate"><span class="pre">dry_run</span></code>, <code class="docutils literal notranslate"><span class="pre">extract_html_text</span></code>,
and <code class="docutils literal notranslate"><span class="pre">previous</span></code> manifest lookup data.</p>
<p>Returns:
DownloadOutcome describing the result of the download attempt including
streaming hash metadata when available.</p>
<p>Notes:
A lightweight HEAD preflight is issued when the caller has not already
validated the URL. This mirrors the resolver pipeline behaviour and
keeps dry-run tests deterministic.</p>
<p>Raises:
OSError: If writing the downloaded payload to disk fails.
TypeError: If conditional response parsing returns unexpected objects.</p>
</section>
<section id="read-resolver-config-path">
<h3><code class="docutils literal notranslate"><span class="pre">read_resolver_config(path)</span></code><a class="headerlink" href="#read-resolver-config-path" title="Link to this heading"></a></h3>
<p>Read resolver configuration from JSON or YAML files.</p>
<p>Args:
path: Path to the configuration file.</p>
<p>Returns:
Parsed configuration mapping.</p>
<p>Raises:
RuntimeError: If YAML parsing is requested but PyYAML is unavailable.</p>
</section>
<section id="seed-resolver-toggle-defaults-config-resolver-names">
<h3><code class="docutils literal notranslate"><span class="pre">_seed_resolver_toggle_defaults(config,</span> <span class="pre">resolver_names)</span></code><a class="headerlink" href="#seed-resolver-toggle-defaults-config-resolver-names" title="Link to this heading"></a></h3>
<p>Ensure resolver toggles include defaults for every known resolver.</p>
</section>
<section id="apply-config-overrides-config-data-resolver-names">
<h3><code class="docutils literal notranslate"><span class="pre">apply_config_overrides(config,</span> <span class="pre">data,</span> <span class="pre">resolver_names)</span></code><a class="headerlink" href="#apply-config-overrides-config-data-resolver-names" title="Link to this heading"></a></h3>
<p>Apply overrides from configuration data onto a ResolverConfig.</p>
<p>Args:
config: Resolver configuration object to mutate.
data: Mapping loaded from a configuration file.
resolver_names: Known resolver names. Defaults are applied after overrides.</p>
<p>Returns:
None</p>
</section>
<section id="load-resolver-config-args-resolver-names-resolver-order-override">
<h3><code class="docutils literal notranslate"><span class="pre">load_resolver_config(args,</span> <span class="pre">resolver_names,</span> <span class="pre">resolver_order_override)</span></code><a class="headerlink" href="#load-resolver-config-args-resolver-names-resolver-order-override" title="Link to this heading"></a></h3>
<p>Construct resolver configuration combining CLI, config files, and env vars.</p>
<p>Args:
args: Parsed CLI arguments.
resolver_names: Sequence of resolver names supported by the pipeline.
resolver_order_override: Optional override list for resolver order.</p>
<p>Returns:
Populated ResolverConfig instance.</p>
<p>Raises:
FileNotFoundError: If the resolver configuration file does not exist.
RuntimeError: If YAML parsing is requested but PyYAML is unavailable.</p>
</section>
<section id="iterate-openalex-query-per-page-max-results">
<h3><code class="docutils literal notranslate"><span class="pre">iterate_openalex(query,</span> <span class="pre">per_page,</span> <span class="pre">max_results)</span></code><a class="headerlink" href="#iterate-openalex-query-per-page-max-results" title="Link to this heading"></a></h3>
<p>Iterate over OpenAlex works respecting pagination and limits.</p>
<p>Args:
query: Configured Works query instance.
per_page: Number of results to request per page.
max_results: Optional maximum number of works to yield.</p>
<p>Yields:
Work payload dictionaries returned by the OpenAlex API.</p>
<p>Returns:
Iterable yielding the same work payload dictionaries for convenience.</p>
</section>
<section id="process-one-work-work-session-pdf-dir-html-dir-pipeline-logger-metrics">
<h3><code class="docutils literal notranslate"><span class="pre">process_one_work(work,</span> <span class="pre">session,</span> <span class="pre">pdf_dir,</span> <span class="pre">html_dir,</span> <span class="pre">pipeline,</span> <span class="pre">logger,</span> <span class="pre">metrics)</span></code><a class="headerlink" href="#process-one-work-work-session-pdf-dir-html-dir-pipeline-logger-metrics" title="Link to this heading"></a></h3>
<p>Process a single OpenAlex work through the resolver pipeline.</p>
<p>Args:
work: OpenAlex work payload from :func:<code class="docutils literal notranslate"><span class="pre">iterate_openalex</span></code>.
session: Requests session configured for resolver usage.
pdf_dir: Directory where PDF artefacts are written.
html_dir: Directory where HTML artefacts are written.
pipeline: Resolver pipeline orchestrating downstream resolvers.
logger: Structured attempt logger capturing manifest records.
metrics: Resolver metrics collector.
dry_run: When True, simulate downloads without writing files.
extract_html_text: Whether to extract plaintext from HTML artefacts.
previous_lookup: Mapping of work_id/URL to prior manifest entries.
resume_completed: Set of work IDs already processed in resume mode.</p>
<p>Returns:
Dictionary summarizing the outcome (saved/html_only/skipped flags).</p>
<p>Raises:
requests.RequestException: Propagated if resolver HTTP requests fail
unexpectedly outside guarded sections.
Exception: Bubbling from resolver pipeline internals when not handled.</p>
</section>
<section id="main">
<h3><code class="docutils literal notranslate"><span class="pre">main()</span></code><a class="headerlink" href="#main" title="Link to this heading"></a></h3>
<p>Parse CLI arguments, configure resolvers, and execute downloads.</p>
<p>The entrypoint wires together argument parsing, resolver configuration,
logging setup, and the resolver pipeline orchestration documented in the
modular content download specification. It is exposed both as the module’s
<code class="docutils literal notranslate"><span class="pre">__main__</span></code> handler and via <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span></code>.</p>
<p>Args:
None</p>
<p>Returns:
None</p>
</section>
<section id="log-attempt-self-record">
<h3><code class="docutils literal notranslate"><span class="pre">log_attempt(self,</span> <span class="pre">record)</span></code><a class="headerlink" href="#log-attempt-self-record" title="Link to this heading"></a></h3>
<p>Log a resolver attempt.</p>
<p>Args:
record: Structured attempt telemetry emitted by a resolver.
timestamp: Optional ISO8601 timestamp override for deterministic runs.</p>
<p>Returns:
None</p>
</section>
<section id="log-manifest-self-entry">
<h3><code class="docutils literal notranslate"><span class="pre">log_manifest(self,</span> <span class="pre">entry)</span></code><a class="headerlink" href="#log-manifest-self-entry" title="Link to this heading"></a></h3>
<p>Persist a manifest entry.</p>
<p>Args:
entry: Manifest record describing the resolved document.</p>
<p>Returns:
None</p>
</section>
<section id="log-summary-self-summary">
<h3><code class="docutils literal notranslate"><span class="pre">log_summary(self,</span> <span class="pre">summary)</span></code><a class="headerlink" href="#log-summary-self-summary" title="Link to this heading"></a></h3>
<p>Record summary metrics for the run.</p>
<p>Args:
summary: Mapping containing aggregated counters and timings.</p>
<p>Returns:
None</p>
</section>
<section id="close-self">
<h3><code class="docutils literal notranslate"><span class="pre">close(self)</span></code><a class="headerlink" href="#close-self" title="Link to this heading"></a></h3>
<p>Release any underlying resources.</p>
<p>Args:
None</p>
<p>Returns:
None</p>
</section>
<section id="write-self-payload">
<h3><code class="docutils literal notranslate"><span class="pre">_write(self,</span> <span class="pre">payload)</span></code><a class="headerlink" href="#write-self-payload" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="id1">
<h3><code class="docutils literal notranslate"><span class="pre">log_attempt(self,</span> <span class="pre">record)</span></code><a class="headerlink" href="#id1" title="Link to this heading"></a></h3>
<p>Persist a resolver attempt record to the JSONL file.</p>
<p>Args:
record: Attempt metadata describing the resolver execution outcome.
timestamp: Optional override timestamp applied to the JSONL payload.</p>
<p>Returns:
None</p>
</section>
<section id="id2">
<h3><code class="docutils literal notranslate"><span class="pre">log_manifest(self,</span> <span class="pre">entry)</span></code><a class="headerlink" href="#id2" title="Link to this heading"></a></h3>
<p>Persist a manifest entry describing a resolved document.</p>
<p>Args:
entry: Manifest metadata to append to the JSONL log.</p>
<p>Returns:
None</p>
</section>
<section id="id3">
<h3><code class="docutils literal notranslate"><span class="pre">log_summary(self,</span> <span class="pre">summary)</span></code><a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<p>Persist aggregated run metrics to the JSONL file.</p>
<p>Args:
summary: Dictionary of summary statistics such as totals and timings.</p>
<p>Returns:
None</p>
</section>
<section id="id4">
<h3><code class="docutils literal notranslate"><span class="pre">close(self)</span></code><a class="headerlink" href="#id4" title="Link to this heading"></a></h3>
<p>Flush and close the underlying JSONL file handle.</p>
<p>Args:
None</p>
<p>Returns:
None</p>
</section>
<section id="enter-self">
<h3><code class="docutils literal notranslate"><span class="pre">__enter__(self)</span></code><a class="headerlink" href="#enter-self" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="exit-self-exc-type-exc-tb">
<h3><code class="docutils literal notranslate"><span class="pre">__exit__(self,</span> <span class="pre">exc_type,</span> <span class="pre">exc,</span> <span class="pre">tb)</span></code><a class="headerlink" href="#exit-self-exc-type-exc-tb" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="id5">
<h3><code class="docutils literal notranslate"><span class="pre">log_attempt(self,</span> <span class="pre">record)</span></code><a class="headerlink" href="#id5" title="Link to this heading"></a></h3>
<p>Append a resolver attempt row to the CSV file.</p>
<p>Args:
record: Attempt metadata describing the resolver execution.
timestamp: Optional override timestamp applied to the CSV row.</p>
<p>Returns:
None</p>
</section>
<section id="id6">
<h3><code class="docutils literal notranslate"><span class="pre">log_manifest(self,</span> <span class="pre">entry)</span></code><a class="headerlink" href="#id6" title="Link to this heading"></a></h3>
<p>Ignore manifest entries; CSV sink only records attempt rows.</p>
<p>Args:
entry: Manifest metadata supplied by the pipeline.</p>
<p>Returns:
None</p>
</section>
<section id="id7">
<h3><code class="docutils literal notranslate"><span class="pre">log_summary(self,</span> <span class="pre">summary)</span></code><a class="headerlink" href="#id7" title="Link to this heading"></a></h3>
<p>Ignore summary metrics; CSV sink only records attempt rows.</p>
<p>Args:
summary: Mapping of summary metrics (unused).</p>
<p>Returns:
None</p>
</section>
<section id="id8">
<h3><code class="docutils literal notranslate"><span class="pre">close(self)</span></code><a class="headerlink" href="#id8" title="Link to this heading"></a></h3>
<p>Flush and close the CSV file handle.</p>
<p>Args:
None</p>
<p>Returns:
None</p>
</section>
<section id="id9">
<h3><code class="docutils literal notranslate"><span class="pre">__enter__(self)</span></code><a class="headerlink" href="#id9" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="id10">
<h3><code class="docutils literal notranslate"><span class="pre">__exit__(self,</span> <span class="pre">exc_type,</span> <span class="pre">exc,</span> <span class="pre">tb)</span></code><a class="headerlink" href="#id10" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="id11">
<h3><code class="docutils literal notranslate"><span class="pre">log_attempt(self,</span> <span class="pre">record)</span></code><a class="headerlink" href="#id11" title="Link to this heading"></a></h3>
<p>Send the attempt to both the base logger and the CSV sink.</p>
<p>Args:
record: Attempt record to mirror to both sinks.
timestamp: Optional timestamp to apply to the mirrored record.</p>
<p>Returns:
None</p>
</section>
<section id="id12">
<h3><code class="docutils literal notranslate"><span class="pre">log_manifest(self,</span> <span class="pre">entry)</span></code><a class="headerlink" href="#id12" title="Link to this heading"></a></h3>
<p>Forward manifest entries to both the base logger and CSV sink.</p>
<p>Args:
entry: Manifest record describing the resolved document.</p>
<p>Returns:
None</p>
</section>
<section id="id13">
<h3><code class="docutils literal notranslate"><span class="pre">log_summary(self,</span> <span class="pre">summary)</span></code><a class="headerlink" href="#id13" title="Link to this heading"></a></h3>
<p>Forward summary telemetry to both adapters.</p>
<p>Args:
summary: Mapping of summary metrics to forward.</p>
<p>Returns:
None</p>
</section>
<section id="id14">
<h3><code class="docutils literal notranslate"><span class="pre">close(self)</span></code><a class="headerlink" href="#id14" title="Link to this heading"></a></h3>
<p>Close the base logger and CSV sink, propagating base errors.</p>
<p>Args:
None</p>
<p>Returns:
None</p>
<p>Raises:
BaseException: Re-raises any error encountered when closing the base logger.</p>
</section>
<section id="id15">
<h3><code class="docutils literal notranslate"><span class="pre">log_attempt(self,</span> <span class="pre">record)</span></code><a class="headerlink" href="#id15" title="Link to this heading"></a></h3>
<p>Forward a resolver attempt to all registered sinks.</p>
<p>Args:
record: Attempt metadata to broadcast.
timestamp: Optional shared timestamp passed to each sink.</p>
<p>Returns:
None</p>
</section>
<section id="id16">
<h3><code class="docutils literal notranslate"><span class="pre">log_manifest(self,</span> <span class="pre">entry)</span></code><a class="headerlink" href="#id16" title="Link to this heading"></a></h3>
<p>Forward a manifest entry to all registered sinks.</p>
<p>Args:
entry: Manifest record to broadcast.</p>
<p>Returns:
None</p>
</section>
<section id="id17">
<h3><code class="docutils literal notranslate"><span class="pre">log_summary(self,</span> <span class="pre">summary)</span></code><a class="headerlink" href="#id17" title="Link to this heading"></a></h3>
<p>Forward summary telemetry to all registered sinks.</p>
<p>Args:
summary: Mapping of aggregated metrics to broadcast.</p>
<p>Returns:
None</p>
</section>
<section id="id18">
<h3><code class="docutils literal notranslate"><span class="pre">close(self)</span></code><a class="headerlink" href="#id18" title="Link to this heading"></a></h3>
<p>Close all sinks, propagating the first raised exception.</p>
<p>Args:
None</p>
<p>Returns:
None</p>
<p>Raises:
BaseException: Re-raises the first error encountered when closing delegates.</p>
</section>
<section id="id19">
<h3><code class="docutils literal notranslate"><span class="pre">__enter__(self)</span></code><a class="headerlink" href="#id19" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="id20">
<h3><code class="docutils literal notranslate"><span class="pre">__exit__(self,</span> <span class="pre">exc_type,</span> <span class="pre">exc,</span> <span class="pre">tb)</span></code><a class="headerlink" href="#id20" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="id21">
<h3><code class="docutils literal notranslate"><span class="pre">log_attempt(self,</span> <span class="pre">record)</span></code><a class="headerlink" href="#id21" title="Link to this heading"></a></h3>
<p>Ignore attempt telemetry; only manifests are indexed.</p>
<p>Args:
record: Attempt record supplied by the pipeline.
timestamp: Optional timestamp provided by the caller.</p>
<p>Returns:
None</p>
</section>
<section id="id22">
<h3><code class="docutils literal notranslate"><span class="pre">log_manifest(self,</span> <span class="pre">entry)</span></code><a class="headerlink" href="#id22" title="Link to this heading"></a></h3>
<p>Persist manifest metadata for inclusion in the JSON index.</p>
<p>Newly received manifest entries replace any existing payload stored under
the same <code class="docutils literal notranslate"><span class="pre">work_id</span></code> so downstream tools can rely on deterministic output.</p>
<p>Args:
entry: Manifest record describing a resolved document.</p>
<p>Returns:
None</p>
</section>
<section id="id23">
<h3><code class="docutils literal notranslate"><span class="pre">log_summary(self,</span> <span class="pre">summary)</span></code><a class="headerlink" href="#id23" title="Link to this heading"></a></h3>
<p>Ignore summary telemetry; manifests only are indexed.</p>
<p>Args:
summary: Mapping of summary metrics supplied by the pipeline.</p>
<p>Returns:
None</p>
</section>
<section id="id24">
<h3><code class="docutils literal notranslate"><span class="pre">close(self)</span></code><a class="headerlink" href="#id24" title="Link to this heading"></a></h3>
<p>Write the manifest index to disk if not already closed.</p>
<p>Args:
None</p>
<p>Returns:
None</p>
</section>
<section id="id25">
<h3><code class="docutils literal notranslate"><span class="pre">__enter__(self)</span></code><a class="headerlink" href="#id25" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="id26">
<h3><code class="docutils literal notranslate"><span class="pre">__exit__(self,</span> <span class="pre">exc_type,</span> <span class="pre">exc,</span> <span class="pre">tb)</span></code><a class="headerlink" href="#id26" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="id27">
<h3><code class="docutils literal notranslate"><span class="pre">log_attempt(self,</span> <span class="pre">record)</span></code><a class="headerlink" href="#id27" title="Link to this heading"></a></h3>
<p>Ignore attempt telemetry; only manifest rows are retained.</p>
<p>Args:
record: Attempt record supplied by the pipeline.
timestamp: Optional timestamp associated with the attempt.</p>
<p>Returns:
None</p>
</section>
<section id="id28">
<h3><code class="docutils literal notranslate"><span class="pre">log_manifest(self,</span> <span class="pre">entry)</span></code><a class="headerlink" href="#id28" title="Link to this heading"></a></h3>
<p>Record the manifest entry so the latest attempt is written at close.</p>
<p>The sink keeps only the most recent entry for each <code class="docutils literal notranslate"><span class="pre">work_id</span></code> so that
duplicate retries collapse into a single CSV row.</p>
<p>Args:
entry: Manifest record describing the resolved document.</p>
<p>Returns:
None</p>
</section>
<section id="id29">
<h3><code class="docutils literal notranslate"><span class="pre">log_summary(self,</span> <span class="pre">summary)</span></code><a class="headerlink" href="#id29" title="Link to this heading"></a></h3>
<p>Ignore summary telemetry; output only includes manifest rows.</p>
<p>Args:
summary: Mapping of summary metrics supplied by the pipeline.</p>
<p>Returns:
None</p>
</section>
<section id="id30">
<h3><code class="docutils literal notranslate"><span class="pre">close(self)</span></code><a class="headerlink" href="#id30" title="Link to this heading"></a></h3>
<p>Write the consolidated manifest CSV to disk when invoked.</p>
<p>Args:
None</p>
<p>Returns:
None</p>
</section>
<section id="id31">
<h3><code class="docutils literal notranslate"><span class="pre">__enter__(self)</span></code><a class="headerlink" href="#id31" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="id32">
<h3><code class="docutils literal notranslate"><span class="pre">__exit__(self,</span> <span class="pre">exc_type,</span> <span class="pre">exc,</span> <span class="pre">tb)</span></code><a class="headerlink" href="#id32" title="Link to this heading"></a></h3>
<p><em>No documentation available.</em></p>
</section>
<section id="post-init-self">
<h3><code class="docutils literal notranslate"><span class="pre">__post_init__(self)</span></code><a class="headerlink" href="#post-init-self" title="Link to this heading"></a></h3>
<p>Define namespace mappings for output artefact directories.</p>
<p>Args:
self: Instance whose namespace mapping is being initialised.</p>
<p>Returns:
None</p>
</section>
<section id="append-location-loc">
<h3><code class="docutils literal notranslate"><span class="pre">_append_location(loc)</span></code><a class="headerlink" href="#append-location-loc" title="Link to this heading"></a></h3>
<p>Accumulate location URLs from a single OpenAlex location record.</p>
<p>Args:
loc: Location dictionary as returned by OpenAlex (may be None).</p>
</section>
<section id="session-factory">
<h3><code class="docutils literal notranslate"><span class="pre">_session_factory()</span></code><a class="headerlink" href="#session-factory" title="Link to this heading"></a></h3>
<p>Return a new :class:<code class="docutils literal notranslate"><span class="pre">requests.Session</span></code> using the run’s polite headers.</p>
<p>The factory is invoked by worker threads to obtain an isolated session
that inherits the resolver configuration’s polite identification
headers. Creating sessions through this helper ensures each worker
reuses the shared retry configuration while keeping connection pools
thread-local.</p>
</section>
<section id="record-result-res">
<h3><code class="docutils literal notranslate"><span class="pre">_record_result(res)</span></code><a class="headerlink" href="#record-result-res" title="Link to this heading"></a></h3>
<p>Update aggregate counters based on a single work result.</p>
</section>
<section id="submit-work-work-item">
<h3><code class="docutils literal notranslate"><span class="pre">_submit_work(work_item)</span></code><a class="headerlink" href="#submit-work-work-item" title="Link to this heading"></a></h3>
<p>Submit a work item to the executor for asynchronous processing.</p>
</section>
<section id="runner">
<h3><code class="docutils literal notranslate"><span class="pre">_runner()</span></code><a class="headerlink" href="#runner" title="Link to this heading"></a></h3>
<p>Process a single work item within a worker-managed session.</p>
</section>
</section>
<section id="classes">
<h2>3. Classes<a class="headerlink" href="#classes" title="Link to this heading"></a></h2>
<section id="manifestentry">
<h3><code class="docutils literal notranslate"><span class="pre">ManifestEntry</span></code><a class="headerlink" href="#manifestentry" title="Link to this heading"></a></h3>
<p>Structured record capturing the outcome of a resolver attempt.</p>
<p>Attributes:
timestamp: ISO timestamp when the manifest entry was created.
work_id: OpenAlex work identifier associated with the download.
title: Human-readable work title.
publication_year: Publication year when available.
resolver: Name of the resolver that produced the asset.
url: Source URL of the downloaded artifact.
path: Local filesystem path to the stored artifact.
classification: Classification label describing the outcome (e.g., ‘pdf’).
content_type: MIME type reported by the server.
reason: Failure or status reason for non-successful attempts.
html_paths: Paths to any captured HTML artifacts.
sha256: SHA-256 digest of the downloaded content.
content_length: Size of the artifact in bytes.
etag: HTTP ETag header value if provided.
last_modified: HTTP Last-Modified timestamp.
extracted_text_path: Optional path to extracted text content.
dry_run: Flag indicating whether the download was simulated.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>ManifestEntry(
…     timestamp=”2024-01-01T00:00:00Z”,
…     work_id=”W123”,
…     title=”Sample Work”,
…     publication_year=2024,
…     resolver=”unpaywall”,
…     url=”https://example.org/sample.pdf”,
…     path=”pdfs/sample.pdf”,
…     classification=”pdf”,
…     content_type=”application/pdf”,
…     reason=None,
…     dry_run=False,
… )</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="attemptsink">
<h3><code class="docutils literal notranslate"><span class="pre">AttemptSink</span></code><a class="headerlink" href="#attemptsink" title="Link to this heading"></a></h3>
<p>Protocol implemented by logging sinks that consume download telemetry.</p>
<p>Attributes:
log_attempt: Callable accepting an :class:<code class="docutils literal notranslate"><span class="pre">AttemptRecord</span></code> plus optional timestamp.
log_manifest: Callable that receives :class:<code class="docutils literal notranslate"><span class="pre">ManifestEntry</span></code> objects for storage.
log_summary: Callable that ingests aggregate metrics collected during a run.
close: Callable that finalises resources owned by the sink.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>class Collector:
…     def log_attempt(self, record, *, timestamp=None):
…         …  # doctest: +SKIP
…     def log_manifest(self, entry):
…         …  # doctest: +SKIP
…     def log_summary(self, summary):
…         …  # doctest: +SKIP
…     def close(self):
…         …  # doctest: +SKIP
isinstance(Collector(), AttemptSink)  # doctest: +SKIP
True</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="jsonlsink">
<h3><code class="docutils literal notranslate"><span class="pre">JsonlSink</span></code><a class="headerlink" href="#jsonlsink" title="Link to this heading"></a></h3>
<p>Thread-safe sink that streams attempt, manifest, and summary events to JSONL files.</p>
<p>Attributes:
_path: Destination JSONL file path.
_file: Lazily opened file handle pointing at <code class="docutils literal notranslate"><span class="pre">_path</span></code>.
_lock: Mutex used to serialize concurrent writes.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>sink = JsonlSink(Path(‘/tmp/attempts.jsonl’))  # doctest: +SKIP
sink.log_summary({‘attempts’: 1})  # doctest: +SKIP
sink.close()  # doctest: +SKIP</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="csvsink">
<h3><code class="docutils literal notranslate"><span class="pre">CsvSink</span></code><a class="headerlink" href="#csvsink" title="Link to this heading"></a></h3>
<p>Lightweight sink that mirrors attempt records into a CSV for spreadsheet review.</p>
<p>Attributes:
_file: Open CSV file handle for appending attempts.
_writer: :class:<code class="docutils literal notranslate"><span class="pre">csv.DictWriter</span></code> configured with attempt headers.
_lock: Mutex guarding concurrent writes.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>sink = CsvSink(Path(‘/tmp/attempts.csv’))  # doctest: +SKIP
sink.log_summary({‘attempts’: 1})  # doctest: +SKIP
sink.close()  # doctest: +SKIP</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="csvattemptloggeradapter">
<h3><code class="docutils literal notranslate"><span class="pre">CsvAttemptLoggerAdapter</span></code><a class="headerlink" href="#csvattemptloggeradapter" title="Link to this heading"></a></h3>
<p>Adapter that mirrors JSONL logging into a CSV sink for compatibility.</p>
<p>Attributes:
_base_logger: Primary sink that receives mirrored logging calls.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>adapter = CsvAttemptLoggerAdapter(JsonlSink(Path(‘/tmp/a.jsonl’)), Path(‘/tmp/a.csv’))  # doctest: +SKIP
adapter.close()  # doctest: +SKIP</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="multisink">
<h3><code class="docutils literal notranslate"><span class="pre">MultiSink</span></code><a class="headerlink" href="#multisink" title="Link to this heading"></a></h3>
<p>Composite sink that fans out logging calls to multiple sinks.</p>
<p>Attributes:
_sinks: Sequence of sink instances that receive mirrored events.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>sink = MultiSink([JsonlSink(Path(‘/tmp/a.jsonl’))])  # doctest: +SKIP
sink.close()  # doctest: +SKIP</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="manifestindexsink">
<h3><code class="docutils literal notranslate"><span class="pre">ManifestIndexSink</span></code><a class="headerlink" href="#manifestindexsink" title="Link to this heading"></a></h3>
<p>Sink that accumulates manifest entries into a JSON index.</p>
<p>Attributes:
_path: Filesystem destination for the generated JSON index.
_index: In-memory mapping from work IDs to manifest payloads.
_closed: Flag guarding idempotent close operations.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>sink = ManifestIndexSink(Path(‘/tmp/manifests.json’))  # doctest: +SKIP
sink.close()  # doctest: +SKIP</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="lastattemptcsvsink">
<h3><code class="docutils literal notranslate"><span class="pre">LastAttemptCsvSink</span></code><a class="headerlink" href="#lastattemptcsvsink" title="Link to this heading"></a></h3>
<p>Sink that writes one manifest row per work to a CSV on close.</p>
<p>Attributes:
_path: Filesystem destination for the aggregated CSV.
_entries: Mapping of work IDs to their most recent manifest entry.
_closed: Flag guarding idempotent close operations.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>sink = LastAttemptCsvSink(Path(‘/tmp/last_attempt.csv’))  # doctest: +SKIP
sink.close()  # doctest: +SKIP</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="workartifact">
<h3><code class="docutils literal notranslate"><span class="pre">WorkArtifact</span></code><a class="headerlink" href="#workartifact" title="Link to this heading"></a></h3>
<p>Normalized artifact describing an OpenAlex work to process.</p>
<p>Attributes:
work_id: OpenAlex work identifier.
title: Work title suitable for logging.
publication_year: Publication year or None.
doi: Canonical DOI string.
pmid: PubMed identifier (normalized).
pmcid: PubMed Central identifier (normalized).
arxiv_id: Normalized arXiv identifier.
landing_urls: Candidate landing page URLs.
pdf_urls: Candidate PDF download URLs.
open_access_url: Open access URL provided by OpenAlex.
source_display_names: Source names for provenance.
base_stem: Base filename stem for local artefacts.
pdf_dir: Directory where PDFs are stored.
html_dir: Directory where HTML assets are stored.
failed_pdf_urls: URLs that failed during resolution.
metadata: Arbitrary metadata collected during processing.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>artifact = WorkArtifact(
…     work_id=”W123”,
…     title=”Sample Work”,
…     publication_year=2024,
…     doi=”10.1234/example”,
…     pmid=None,
…     pmcid=None,
…     arxiv_id=None,
…     landing_urls=[“https://example.org”],
…     pdf_urls=[],
…     open_access_url=None,
…     source_display_names=[“Example Source”],
…     base_stem=”2024__Sample_Work__W123”,
…     pdf_dir=Path(“pdfs”),
…     html_dir=Path(“html”),
… )</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
<section id="downloadstate">
<h3><code class="docutils literal notranslate"><span class="pre">DownloadState</span></code><a class="headerlink" href="#downloadstate" title="Link to this heading"></a></h3>
<p>State machine for streaming downloads.</p>
<p>Attributes:
PENDING: Payload type is being sniffed.
WRITING: Payload bytes are being streamed to disk.</p>
<p>Examples:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>DownloadState.PENDING is DownloadState.WRITING
False</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, DocsToKG Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>