

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADDED Requirements &mdash; DocsToKG 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/css/custom.css" />

  
      <script src="../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../index.html" class="icon icon-home">
            DocsToKG
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../01-overview/index.html">1. Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../02-setup/index.html">1. Setup Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../03-architecture/index.html">1. Architecture Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../04-api/index.html">1. API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../05-development/index.html">1. Development Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../06-operations/index.html">1. Operations Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../07-reference/index.html">1. Technical Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../index.html">DocsToKG</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">ADDED Requirements</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../_sources/openspec/changes/archive/2025-10-14-add-ontology-downloader/specs/ontology-downloader/spec.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="added-requirements">
<h1>ADDED Requirements<a class="headerlink" href="#added-requirements" title="Link to this heading"></a></h1>
<section id="requirement-source-agnostic-resolver-registry">
<h2>Requirement: Source-Agnostic Resolver Registry<a class="headerlink" href="#requirement-source-agnostic-resolver-registry" title="Link to this heading"></a></h2>
<p>The system SHALL provide a resolver registry that maps ontology source identifiers (OBO, OLS, BioPortal, SKOS, XBRL) to concrete resolver implementations that can locate downloadable artifacts.</p>
<section id="scenario-resolve-obo-foundry-ontology-by-prefix">
<h3>Scenario: Resolve OBO Foundry ontology by prefix<a class="headerlink" href="#scenario-resolve-obo-foundry-ontology-by-prefix" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a FetchSpec with resolver=”obo” and id=”hp” is provided</p></li>
<li><p><strong>THEN</strong> the OBOResolver uses Bioregistry functions to return a FetchPlan with the PURL for hp.owl or hp.obo based on target_formats preference</p></li>
</ul>
</section>
<section id="scenario-resolve-ontology-from-ols4">
<h3>Scenario: Resolve ontology from OLS4<a class="headerlink" href="#scenario-resolve-ontology-from-ols4" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a FetchSpec with resolver=”ols” and id=”efo” is provided</p></li>
<li><p><strong>THEN</strong> the OLSResolver queries the OLS4 API via ols-client and returns a FetchPlan with the canonical OWL download URL and version metadata</p></li>
</ul>
</section>
<section id="scenario-resolve-ontology-from-bioportal-with-api-key">
<h3>Scenario: Resolve ontology from BioPortal with API key<a class="headerlink" href="#scenario-resolve-ontology-from-bioportal-with-api-key" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a FetchSpec with resolver=”bioportal” and extras containing acronym=”NCIT” is provided</p></li>
<li><p><strong>THEN</strong> the BioPortalResolver uses ontoportal-client to fetch the latest submission and returns a FetchPlan with the download URL and Authorization header containing the API key from pystow</p></li>
</ul>
</section>
<section id="scenario-resolve-skos-thesaurus-from-direct-url">
<h3>Scenario: Resolve SKOS thesaurus from direct URL<a class="headerlink" href="#scenario-resolve-skos-thesaurus-from-direct-url" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a FetchSpec with resolver=”skos” and extras containing a direct URL is provided</p></li>
<li><p><strong>THEN</strong> the SKOSResolver returns a FetchPlan with the provided URL and appropriate headers for RDF content negotiation</p></li>
</ul>
</section>
<section id="scenario-resolve-xbrl-taxonomy-package">
<h3>Scenario: Resolve XBRL taxonomy package<a class="headerlink" href="#scenario-resolve-xbrl-taxonomy-package" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a FetchSpec with resolver=”xbrl” and extras containing a taxonomy ZIP URL is provided</p></li>
<li><p><strong>THEN</strong> the XBRLResolver returns a FetchPlan with the ZIP URL for subsequent download and Arelle validation</p></li>
</ul>
</section>
</section>
<section id="requirement-robust-http-download-with-caching">
<h2>Requirement: Robust HTTP Download with Caching<a class="headerlink" href="#requirement-robust-http-download-with-caching" title="Link to this heading"></a></h2>
<p>The system SHALL implement robust HTTP download logic with conditional requests, resume support, checksums, retry, and rate limiting using pooch as the underlying cache and fetch mechanism.</p>
<section id="scenario-conditional-get-with-etag-returns-304-not-modified">
<h3>Scenario: Conditional GET with ETag returns 304 Not Modified<a class="headerlink" href="#scenario-conditional-get-with-etag-returns-304-not-modified" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a previous manifest exists with an ETag and the server responds with HTTP 304</p></li>
<li><p><strong>THEN</strong> the download manager returns a FetchResult with status=’cached’ and the existing local_path without re-downloading</p></li>
</ul>
</section>
<section id="scenario-resume-partial-download-with-range-header">
<h3>Scenario: Resume partial download with Range header<a class="headerlink" href="#scenario-resume-partial-download-with-range-header" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a .part file exists from an interrupted download and the server supports Range requests</p></li>
<li><p><strong>THEN</strong> the download manager sends a Range header starting from the partial file size and appends the remaining bytes</p></li>
</ul>
</section>
<section id="scenario-sha-256-verification-after-complete-download">
<h3>Scenario: SHA-256 verification after complete download<a class="headerlink" href="#scenario-sha-256-verification-after-complete-download" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a file download completes successfully</p></li>
<li><p><strong>THEN</strong> the download manager computes the SHA-256 hash and records it in the FetchResult</p></li>
</ul>
</section>
<section id="scenario-exponential-backoff-retry-on-transient-failure">
<h3>Scenario: Exponential backoff retry on transient failure<a class="headerlink" href="#scenario-exponential-backoff-retry-on-transient-failure" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> the server responds with HTTP 503 or a network timeout occurs</p></li>
<li><p><strong>THEN</strong> the download manager retries up to 5 times with exponential backoff (0.5s base factor)</p></li>
</ul>
</section>
<section id="scenario-per-host-rate-limiting-enforces-4-requests-per-second">
<h3>Scenario: Per-host rate limiting enforces 4 requests per second<a class="headerlink" href="#scenario-per-host-rate-limiting-enforces-4-requests-per-second" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> multiple downloads are requested from the same host</p></li>
<li><p><strong>THEN</strong> the download manager enforces a token bucket rate limit (default 4 req/sec) to avoid overwhelming the server</p></li>
</ul>
</section>
</section>
<section id="requirement-multi-parser-validation-pipeline">
<h2>Requirement: Multi-Parser Validation Pipeline<a class="headerlink" href="#requirement-multi-parser-validation-pipeline" title="Link to this heading"></a></h2>
<p>The system SHALL validate downloaded ontologies using multiple parsers appropriate to their format (RDFLib for RDF/OWL/SKOS, Pronto for OBO/OWL, Owlready2 for OWL reasoning, ROBOT for conversions/QC, Arelle for XBRL) and record validation results in structured JSON files.</p>
<section id="scenario-rdflib-parses-turtle-ontology-successfully">
<h3>Scenario: RDFLib parses Turtle ontology successfully<a class="headerlink" href="#scenario-rdflib-parses-turtle-ontology-successfully" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a Turtle file is downloaded and RDFLib validation runs</p></li>
<li><p><strong>THEN</strong> the validator writes validation/rdflib_parse.json with {“ok”: true, “triples”: N} where N is the triple count</p></li>
</ul>
</section>
<section id="scenario-rdflib-fails-to-parse-malformed-rdf">
<h3>Scenario: RDFLib fails to parse malformed RDF<a class="headerlink" href="#scenario-rdflib-fails-to-parse-malformed-rdf" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a downloaded file claims to be RDF but contains syntax errors</p></li>
<li><p><strong>THEN</strong> the validator writes validation/rdflib_parse.json with {“ok”: false, “error”: “<message>”}</p></li>
</ul>
</section>
<section id="scenario-pronto-parses-obo-file-and-counts-terms">
<h3>Scenario: Pronto parses OBO file and counts terms<a class="headerlink" href="#scenario-pronto-parses-obo-file-and-counts-terms" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> an OBO file is downloaded and Pronto validation runs</p></li>
<li><p><strong>THEN</strong> the validator writes validation/pronto_parse.json with {“ok”: true, “terms”: N} where N is the number of terms</p></li>
</ul>
</section>
<section id="scenario-robot-integration-skipped-when-not-installed">
<h3>Scenario: ROBOT integration skipped when not installed<a class="headerlink" href="#scenario-robot-integration-skipped-when-not-installed" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> ROBOT validation is requested but <code class="docutils literal notranslate"><span class="pre">robot</span></code> command is not found via shutil.which()</p></li>
<li><p><strong>THEN</strong> the validator logs a warning and skips ROBOT steps without failing the entire validation</p></li>
</ul>
</section>
<section id="scenario-arelle-validates-xbrl-taxonomy-package">
<h3>Scenario: Arelle validates XBRL taxonomy package<a class="headerlink" href="#scenario-arelle-validates-xbrl-taxonomy-package" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> an XBRL ZIP file is downloaded and Arelle validation runs</p></li>
<li><p><strong>THEN</strong> the validator extracts the taxonomy, runs Arelle validation, and writes validation/arelle_validation.json with validation results</p></li>
</ul>
</section>
</section>
<section id="requirement-normalized-format-generation">
<h2>Requirement: Normalized Format Generation<a class="headerlink" href="#requirement-normalized-format-generation" title="Link to this heading"></a></h2>
<p>The system SHALL optionally generate normalized formats (Turtle from RDF/OWL via RDFLib, OBO Graph JSON from OBO/OWL via Pronto) and store them in the normalized/ subdirectory while preserving original files in original/.</p>
<section id="scenario-rdflib-serializes-owl-to-normalized-turtle">
<h3>Scenario: RDFLib serializes OWL to normalized Turtle<a class="headerlink" href="#scenario-rdflib-serializes-owl-to-normalized-turtle" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> an OWL file parses successfully with RDFLib and normalize_to includes “ttl”</p></li>
<li><p><strong>THEN</strong> RDFLib serializes the graph to normalized/<filename>.ttl in canonical Turtle format</p></li>
</ul>
</section>
<section id="scenario-pronto-exports-obo-graph-json">
<h3>Scenario: Pronto exports OBO Graph JSON<a class="headerlink" href="#scenario-pronto-exports-obo-graph-json" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> an OBO file parses successfully with Pronto and normalize_to includes “obographs”</p></li>
<li><p><strong>THEN</strong> Pronto exports the ontology to normalized/<filename>.json in OBO Graph JSON format</p></li>
</ul>
</section>
<section id="scenario-original-file-preserved-bit-exact">
<h3>Scenario: Original file preserved bit-exact<a class="headerlink" href="#scenario-original-file-preserved-bit-exact" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> any ontology is downloaded</p></li>
<li><p><strong>THEN</strong> the exact downloaded bytes are saved in original/<filename> without modification</p></li>
</ul>
</section>
</section>
<section id="requirement-comprehensive-provenance-manifests">
<h2>Requirement: Comprehensive Provenance Manifests<a class="headerlink" href="#requirement-comprehensive-provenance-manifests" title="Link to this heading"></a></h2>
<p>The system SHALL record comprehensive provenance metadata for each downloaded ontology in a manifest.json file including source URL, resolver, version, license, ETag, Last-Modified, SHA-256, timestamps, and validation status.</p>
<section id="scenario-manifest-records-all-provenance-fields">
<h3>Scenario: Manifest records all provenance fields<a class="headerlink" href="#scenario-manifest-records-all-provenance-fields" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> an ontology is successfully downloaded and validated</p></li>
<li><p><strong>THEN</strong> manifest.json contains fields: id, resolver, url, filename, version, license, status, sha256, etag, last_modified, downloaded_at, target_formats</p></li>
</ul>
</section>
<section id="scenario-manifest-used-for-cache-invalidation-decision">
<h3>Scenario: Manifest used for cache invalidation decision<a class="headerlink" href="#scenario-manifest-used-for-cache-invalidation-decision" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a subsequent download request occurs for the same ontology</p></li>
<li><p><strong>THEN</strong> the system reads the previous manifest.json and uses etag/last_modified values in conditional request headers</p></li>
</ul>
</section>
<section id="scenario-manifest-records-validation-outcomes">
<h3>Scenario: Manifest records validation outcomes<a class="headerlink" href="#scenario-manifest-records-validation-outcomes" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> validation pipeline runs on a downloaded ontology</p></li>
<li><p><strong>THEN</strong> manifest.json includes references or summaries of validation results from validation/ directory</p></li>
</ul>
</section>
</section>
<section id="requirement-declarative-yaml-configuration">
<h2>Requirement: Declarative YAML Configuration<a class="headerlink" href="#requirement-declarative-yaml-configuration" title="Link to this heading"></a></h2>
<p>The system SHALL support configuration via sources.yaml with a defaults section for global settings (license allowlists, format preferences, HTTP parameters) and per-ontology specifications (id, resolver, target formats, resolver-specific extras).</p>
<section id="scenario-parse-defaults-section-with-license-allowlist">
<h3>Scenario: Parse defaults section with license allowlist<a class="headerlink" href="#scenario-parse-defaults-section-with-license-allowlist" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> sources.yaml contains defaults.accept_licenses=[“CC-BY-4.0”, “CC0-1.0”]</p></li>
<li><p><strong>THEN</strong> the system loads these licenses into a global allowlist used for all ontologies unless overridden</p></li>
</ul>
</section>
<section id="scenario-parse-ontology-list-into-fetchspec-objects">
<h3>Scenario: Parse ontology list into FetchSpec objects<a class="headerlink" href="#scenario-parse-ontology-list-into-fetchspec-objects" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> sources.yaml contains an ontologies list with id, resolver, and target_formats per entry</p></li>
<li><p><strong>THEN</strong> the configuration parser creates a FetchSpec object for each ontology with merged defaults</p></li>
</ul>
</section>
<section id="scenario-per-ontology-resolver-override">
<h3>Scenario: Per-ontology resolver override<a class="headerlink" href="#scenario-per-ontology-resolver-override" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> an ontology specifies resolver=”bioportal” and extras.acronym=”NCIT”</p></li>
<li><p><strong>THEN</strong> the FetchSpec includes these resolver-specific parameters for BioPortalResolver</p></li>
</ul>
</section>
<section id="scenario-configuration-validation-detects-invalid-yaml">
<h3>Scenario: Configuration validation detects invalid YAML<a class="headerlink" href="#scenario-configuration-validation-detects-invalid-yaml" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> sources.yaml contains syntax errors or missing required fields</p></li>
<li><p><strong>THEN</strong> the configuration loader raises a validation error with clear message indicating the issue</p></li>
</ul>
</section>
</section>
<section id="requirement-license-compliance-enforcement">
<h2>Requirement: License Compliance Enforcement<a class="headerlink" href="#requirement-license-compliance-enforcement" title="Link to this heading"></a></h2>
<p>The system SHALL check ontology licenses against a configurable allowlist and fail closed (refuse to download) when encountering restricted licenses without explicit acceptance.</p>
<section id="scenario-license-allowlist-permits-download">
<h3>Scenario: License allowlist permits download<a class="headerlink" href="#scenario-license-allowlist-permits-download" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> an ontology has license=”CC0-1.0” and defaults.accept_licenses includes “CC0-1.0”</p></li>
<li><p><strong>THEN</strong> the download proceeds normally</p></li>
</ul>
</section>
<section id="scenario-license-not-in-allowlist-blocks-download">
<h3>Scenario: License not in allowlist blocks download<a class="headerlink" href="#scenario-license-not-in-allowlist-blocks-download" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> an ontology has license=”Proprietary” and it is not in defaults.accept_licenses</p></li>
<li><p><strong>THEN</strong> the system logs an error and skips the download with clear message indicating license restriction</p></li>
</ul>
</section>
<section id="scenario-missing-license-treated-as-restricted">
<h3>Scenario: Missing license treated as restricted<a class="headerlink" href="#scenario-missing-license-treated-as-restricted" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> an ontology resolver returns license=None</p></li>
<li><p><strong>THEN</strong> the system logs a warning and treats it as restricted unless a bypass flag is configured</p></li>
</ul>
</section>
</section>
<section id="requirement-pystow-based-storage-management">
<h2>Requirement: pystow-Based Storage Management<a class="headerlink" href="#requirement-pystow-based-storage-management" title="Link to this heading"></a></h2>
<p>The system SHALL use pystow to manage data directories at ~/.data/ontology-fetcher (or overridden via env vars) with subdirectories for configs/, cache/, logs/, and ontologies/<id>/<version>/{original,normalized,validation}.</p>
<section id="scenario-pystow-creates-directory-structure-on-first-run">
<h3>Scenario: pystow creates directory structure on first run<a class="headerlink" href="#scenario-pystow-creates-directory-structure-on-first-run" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> ontofetch is invoked for the first time</p></li>
<li><p><strong>THEN</strong> pystow.join(‘ontology-fetcher’) creates ~/.data/ontology-fetcher with necessary subdirectories</p></li>
</ul>
</section>
<section id="scenario-version-specific-subdirectory-created">
<h3>Scenario: Version-specific subdirectory created<a class="headerlink" href="#scenario-version-specific-subdirectory-created" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> an ontology with id=”hp” and version=”2024-10-31” is downloaded</p></li>
<li><p><strong>THEN</strong> the system creates ontologies/hp/2024-10-31/{original,normalized,validation}</p></li>
</ul>
</section>
<section id="scenario-pystow-env-var-overrides-base-path">
<h3>Scenario: pystow env var overrides base path<a class="headerlink" href="#scenario-pystow-env-var-overrides-base-path" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> environment variable PYSTOW_HOME is set to /custom/path</p></li>
<li><p><strong>THEN</strong> ontology data is stored under /custom/path/ontology-fetcher instead of ~/.data</p></li>
</ul>
</section>
</section>
<section id="requirement-cli-with-pull-show-validate-operations">
<h2>Requirement: CLI with Pull/Show/Validate Operations<a class="headerlink" href="#requirement-cli-with-pull-show-validate-operations" title="Link to this heading"></a></h2>
<p>The system SHALL provide a command-line interface (ontofetch) with subcommands for downloading (pull), inspecting (show), and validating (validate) ontologies with both batch and single-ontology modes.</p>
<section id="scenario-pull-ontologies-from-sources-yaml">
<h3>Scenario: Pull ontologies from sources.yaml<a class="headerlink" href="#scenario-pull-ontologies-from-sources-yaml" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">pull</span> <span class="pre">--spec</span> <span class="pre">sources.yaml</span></code></p></li>
<li><p><strong>THEN</strong> the CLI reads sources.yaml, iterates through ontology list, and downloads each one with progress reporting</p></li>
</ul>
</section>
<section id="scenario-pull-single-ontology-by-id">
<h3>Scenario: Pull single ontology by ID<a class="headerlink" href="#scenario-pull-single-ontology-by-id" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">pull</span> <span class="pre">hp</span> <span class="pre">--resolver</span> <span class="pre">obo</span> <span class="pre">--target-formats</span> <span class="pre">owl,obo</span></code></p></li>
<li><p><strong>THEN</strong> the CLI constructs a FetchSpec for HP and downloads it using OBOResolver with format fallback</p></li>
</ul>
</section>
<section id="scenario-force-refresh-bypasses-cache">
<h3>Scenario: Force refresh bypasses cache<a class="headerlink" href="#scenario-force-refresh-bypasses-cache" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">pull</span> <span class="pre">hp</span> <span class="pre">--force</span></code></p></li>
<li><p><strong>THEN</strong> the CLI ignores ETag/Last-Modified from previous manifest and forces a fresh download</p></li>
</ul>
</section>
<section id="scenario-show-ontology-manifest">
<h3>Scenario: Show ontology manifest<a class="headerlink" href="#scenario-show-ontology-manifest" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">show</span> <span class="pre">hp</span></code></p></li>
<li><p><strong>THEN</strong> the CLI reads ontologies/hp/<latest-version>/manifest.json and displays provenance fields in human-readable format</p></li>
</ul>
</section>
<section id="scenario-list-all-versions-of-ontology">
<h3>Scenario: List all versions of ontology<a class="headerlink" href="#scenario-list-all-versions-of-ontology" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">show</span> <span class="pre">hp</span> <span class="pre">--versions</span></code></p></li>
<li><p><strong>THEN</strong> the CLI lists all version directories under ontologies/hp/ with timestamps and sizes</p></li>
</ul>
</section>
<section id="scenario-re-run-validation-on-existing-ontology">
<h3>Scenario: Re-run validation on existing ontology<a class="headerlink" href="#scenario-re-run-validation-on-existing-ontology" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">validate</span> <span class="pre">hp&#64;2024-10-31</span> <span class="pre">--rdflib</span> <span class="pre">--pronto</span></code></p></li>
<li><p><strong>THEN</strong> the CLI locates ontologies/hp/2024-10-31/original/<file> and re-runs RDFLib and Pronto validators, updating validation/ outputs</p></li>
</ul>
</section>
<section id="scenario-machine-readable-json-output">
<h3>Scenario: Machine-readable JSON output<a class="headerlink" href="#scenario-machine-readable-json-output" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">show</span> <span class="pre">hp</span> <span class="pre">--json</span></code></p></li>
<li><p><strong>THEN</strong> the CLI outputs the complete manifest.json content as valid JSON to stdout</p></li>
</ul>
</section>
</section>
<section id="requirement-structured-logging-for-observability">
<h2>Requirement: Structured Logging for Observability<a class="headerlink" href="#requirement-structured-logging-for-observability" title="Link to this heading"></a></h2>
<p>The system SHALL emit structured JSON logs capturing resolver actions, HTTP operations, validation outcomes, and aggregate metrics with fields for source, status, timing, errors, and retry counts.</p>
<section id="scenario-log-resolver-plan-with-timing">
<h3>Scenario: Log resolver plan with timing<a class="headerlink" href="#scenario-log-resolver-plan-with-timing" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a resolver generates a FetchPlan</p></li>
<li><p><strong>THEN</strong> a log entry is written with fields: timestamp, level=”info”, stage=”resolver”, id, resolver_type, plan_url, planning_time_ms</p></li>
</ul>
</section>
<section id="scenario-log-http-download-with-status-and-timing">
<h3>Scenario: Log HTTP download with status and timing<a class="headerlink" href="#scenario-log-http-download-with-status-and-timing" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a download completes</p></li>
<li><p><strong>THEN</strong> a log entry is written with fields: timestamp, level=”info”, stage=”download”, url, status_code, etag, sha256, elapsed_time_ms, retries, cache_hit</p></li>
</ul>
</section>
<section id="scenario-log-validation-outcome">
<h3>Scenario: Log validation outcome<a class="headerlink" href="#scenario-log-validation-outcome" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a validator runs</p></li>
<li><p><strong>THEN</strong> a log entry is written with fields: timestamp, level=”info”|”error”, stage=”validation”, parser, outcome=”success”|”failure”, error_message, metrics (triples, terms)</p></li>
</ul>
</section>
<section id="scenario-log-batch-summary-on-completion">
<h3>Scenario: Log batch summary on completion<a class="headerlink" href="#scenario-log-batch-summary-on-completion" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a batch pull operation completes</p></li>
<li><p><strong>THEN</strong> a log entry is written with fields: timestamp, level=”info”, stage=”summary”, total_ontologies, success_count, cached_count, failure_count, total_bandwidth_bytes, total_elapsed_time_ms</p></li>
</ul>
</section>
</section>
<section id="requirement-safe-zip-extraction-for-xbrl">
<h2>Requirement: Safe ZIP Extraction for XBRL<a class="headerlink" href="#requirement-safe-zip-extraction-for-xbrl" title="Link to this heading"></a></h2>
<p>The system SHALL safely extract XBRL taxonomy ZIP files with path validation to prevent zip-slip attacks, ensuring extracted files remain within the target directory.</p>
<section id="scenario-extract-xbrl-zip-with-valid-paths">
<h3>Scenario: Extract XBRL ZIP with valid paths<a class="headerlink" href="#scenario-extract-xbrl-zip-with-valid-paths" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> an XBRL ZIP file contains taxonomy files with paths like “schemas/ifrs.xsd”</p></li>
<li><p><strong>THEN</strong> the system extracts them to ontologies/<id>/<version>/original/schemas/ifrs.xsd within the designated directory</p></li>
</ul>
</section>
<section id="scenario-reject-zip-with-path-traversal-attack">
<h3>Scenario: Reject ZIP with path traversal attack<a class="headerlink" href="#scenario-reject-zip-with-path-traversal-attack" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> an XBRL ZIP file contains a member with path “../../etc/passwd”</p></li>
<li><p><strong>THEN</strong> the system detects the path traversal, logs an error, and refuses to extract the file</p></li>
</ul>
</section>
<section id="scenario-validate-zip-before-extraction">
<h3>Scenario: Validate ZIP before extraction<a class="headerlink" href="#scenario-validate-zip-before-extraction" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a downloaded XBRL file is claimed to be a ZIP</p></li>
<li><p><strong>THEN</strong> the system calls zipfile.is_zipfile() before extraction and fails safely if not a valid ZIP</p></li>
</ul>
</section>
</section>
<section id="requirement-batch-operation-with-graceful-failure-handling">
<h2>Requirement: Batch Operation with Graceful Failure Handling<a class="headerlink" href="#requirement-batch-operation-with-graceful-failure-handling" title="Link to this heading"></a></h2>
<p>The system SHALL support batch operations over multiple ontologies with graceful failure handling that continues processing remaining items and records failures in structured logs without aborting the entire batch.</p>
<section id="scenario-batch-download-continues-after-single-failure">
<h3>Scenario: Batch download continues after single failure<a class="headerlink" href="#scenario-batch-download-continues-after-single-failure" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a batch pull includes 5 ontologies and ontology #2 fails due to network error</p></li>
<li><p><strong>THEN</strong> the system logs the failure for #2, continues with #3-5, and reports aggregate success/failure counts at completion</p></li>
</ul>
</section>
<section id="scenario-failed-items-reported-in-summary">
<h3>Scenario: Failed items reported in summary<a class="headerlink" href="#scenario-failed-items-reported-in-summary" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a batch pull completes with some failures</p></li>
<li><p><strong>THEN</strong> the CLI summary output lists failed ontology IDs with error reasons</p></li>
</ul>
</section>
<section id="scenario-partial-results-usable-despite-failures">
<h3>Scenario: Partial results usable despite failures<a class="headerlink" href="#scenario-partial-results-usable-despite-failures" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> some ontologies in a batch download successfully while others fail</p></li>
<li><p><strong>THEN</strong> manifests and validation outputs are written for successful items and can be used independently</p></li>
</ul>
</section>
</section>
<section id="requirement-optional-robot-integration-for-conversions-and-qc">
<h2>Requirement: Optional ROBOT Integration for Conversions and QC<a class="headerlink" href="#requirement-optional-robot-integration-for-conversions-and-qc" title="Link to this heading"></a></h2>
<p>The system SHALL optionally integrate ROBOT (when installed and detected via runtime check) for ontology format conversions and SPARQL-based quality control reports without requiring ROBOT as a hard dependency.</p>
<section id="scenario-robot-detected-and-used-for-conversion">
<h3>Scenario: ROBOT detected and used for conversion<a class="headerlink" href="#scenario-robot-detected-and-used-for-conversion" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> ROBOT is installed and <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">validate</span> <span class="pre">hp</span> <span class="pre">--robot</span></code> is run</p></li>
<li><p><strong>THEN</strong> the system calls <code class="docutils literal notranslate"><span class="pre">robot</span> <span class="pre">convert</span> <span class="pre">-i</span> <span class="pre">hp.owl</span> <span class="pre">-o</span> <span class="pre">hp.obo</span></code> via subprocess and stores output in normalized/</p></li>
</ul>
</section>
<section id="scenario-robot-used-for-qc-report">
<h3>Scenario: ROBOT used for QC report<a class="headerlink" href="#scenario-robot-used-for-qc-report" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> ROBOT is installed and <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">validate</span> <span class="pre">hp</span> <span class="pre">--robot</span></code> is run</p></li>
<li><p><strong>THEN</strong> the system calls <code class="docutils literal notranslate"><span class="pre">robot</span> <span class="pre">report</span> <span class="pre">-i</span> <span class="pre">hp.owl</span> <span class="pre">-o</span> <span class="pre">validation/robot_report.tsv</span></code> and captures SPARQL check results</p></li>
</ul>
</section>
<section id="scenario-robot-not-installed-validation-continues">
<h3>Scenario: ROBOT not installed, validation continues<a class="headerlink" href="#scenario-robot-not-installed-validation-continues" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> ROBOT is not found via shutil.which(‘robot’) and <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">validate</span> <span class="pre">hp</span> <span class="pre">--robot</span></code> is run</p></li>
<li><p><strong>THEN</strong> the system logs “ROBOT not found, skipping conversion/QC steps” and proceeds with other validators without error</p></li>
</ul>
</section>
<section id="scenario-robot-subprocess-error-captured">
<h3>Scenario: ROBOT subprocess error captured<a class="headerlink" href="#scenario-robot-subprocess-error-captured" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> ROBOT command fails with non-zero exit code</p></li>
<li><p><strong>THEN</strong> the system captures stdout/stderr, logs the error, and writes validation/robot_error.txt without crashing</p></li>
</ul>
</section>
</section>
<section id="requirement-comprehensive-error-handling-and-recovery">
<h2>Requirement: Comprehensive Error Handling and Recovery<a class="headerlink" href="#requirement-comprehensive-error-handling-and-recovery" title="Link to this heading"></a></h2>
<p>The system SHALL handle all failure scenarios gracefully with clear error messages, appropriate retries, and recovery mechanisms that preserve partial progress and enable resumption.</p>
<section id="scenario-network-failure-during-download-with-retry">
<h3>Scenario: Network failure during download with retry<a class="headerlink" href="#scenario-network-failure-during-download-with-retry" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a network connection drops mid-download causing ConnectionError or Timeout</p></li>
<li><p><strong>THEN</strong> the download manager logs the error, waits according to exponential backoff schedule, and retries up to max_retries times before failing</p></li>
</ul>
</section>
<section id="scenario-invalid-credentials-for-restricted-ontology">
<h3>Scenario: Invalid credentials for restricted ontology<a class="headerlink" href="#scenario-invalid-credentials-for-restricted-ontology" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> BioPortal API returns HTTP 401 Unauthorized due to missing or invalid API key</p></li>
<li><p><strong>THEN</strong> the system logs error “BioPortal API key invalid or missing. Configure via PYSTOW_HOME/ontology-fetcher/bioportal_api_key.txt”, skips the ontology, and continues batch processing</p></li>
</ul>
</section>
<section id="scenario-resolver-api-unavailable">
<h3>Scenario: Resolver API unavailable<a class="headerlink" href="#scenario-resolver-api-unavailable" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> OLS API returns HTTP 503 Service Unavailable</p></li>
<li><p><strong>THEN</strong> the system retries with exponential backoff, and if all retries fail, logs error “OLS service unavailable after 5 attempts”, skips ontology, and continues</p></li>
</ul>
</section>
<section id="scenario-disk-space-exhausted-during-download">
<h3>Scenario: Disk space exhausted during download<a class="headerlink" href="#scenario-disk-space-exhausted-during-download" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> disk write fails with OSError “No space left on device”</p></li>
<li><p><strong>THEN</strong> the system catches the exception, logs error with required space estimate, cleans up .part file, and aborts batch with exit code 1</p></li>
</ul>
</section>
<section id="scenario-corrupted-download-detected-via-checksum">
<h3>Scenario: Corrupted download detected via checksum<a class="headerlink" href="#scenario-corrupted-download-detected-via-checksum" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> downloaded file SHA-256 does not match expected hash from manifest or registry</p></li>
<li><p><strong>THEN</strong> the system logs error with expected vs actual hashes, deletes corrupted file, and retries download as if cache miss</p></li>
</ul>
</section>
<section id="scenario-parser-fails-with-syntax-error">
<h3>Scenario: Parser fails with syntax error<a class="headerlink" href="#scenario-parser-fails-with-syntax-error" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> RDFLib raises rdflib.exceptions.ParserError on malformed RDF</p></li>
<li><p><strong>THEN</strong> the validator writes {“ok”: false, “error”: “ParserError: <details>”} to validation/rdflib_parse.json, logs at WARNING level, and continues with other validators</p></li>
</ul>
</section>
<section id="scenario-configuration-file-not-found">
<h3>Scenario: Configuration file not found<a class="headerlink" href="#scenario-configuration-file-not-found" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> ontofetch pull –spec nonexistent.yaml is run</p></li>
<li><p><strong>THEN</strong> the CLI exits with code 2 and stderr message “Configuration file not found: nonexistent.yaml”</p></li>
</ul>
</section>
<section id="scenario-permission-denied-writing-to-cache-directory">
<h3>Scenario: Permission denied writing to cache directory<a class="headerlink" href="#scenario-permission-denied-writing-to-cache-directory" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> pystow cannot create ~/.data/ontology-fetcher due to permission error</p></li>
<li><p><strong>THEN</strong> the system logs error “Permission denied writing to ~/.data/ontology-fetcher. Set PYSTOW_HOME to writable directory”, exits with code 1</p></li>
</ul>
</section>
<section id="scenario-timeout-on-slow-resolver-api">
<h3>Scenario: Timeout on slow resolver API<a class="headerlink" href="#scenario-timeout-on-slow-resolver-api" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> BioPortal API request exceeds 30-second timeout</p></li>
<li><p><strong>THEN</strong> the request raises requests.Timeout, system logs “BioPortal API timeout after 30s”, retries with backoff</p></li>
</ul>
</section>
<section id="scenario-memory-limit-exceeded-during-large-ontology-parsing">
<h3>Scenario: Memory limit exceeded during large ontology parsing<a class="headerlink" href="#scenario-memory-limit-exceeded-during-large-ontology-parsing" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> Owlready2 loading large ontology (&gt;2GB) raises MemoryError</p></li>
<li><p><strong>THEN</strong> the validator logs “Memory limit exceeded parsing <id>. Consider skipping reasoning for large ontologies”, writes {“ok”: false, “error”: “MemoryError”} to validation/owlready2_parse.json</p></li>
</ul>
</section>
</section>
<section id="requirement-security-and-integrity-validation">
<h2>Requirement: Security and Integrity Validation<a class="headerlink" href="#requirement-security-and-integrity-validation" title="Link to this heading"></a></h2>
<p>The system SHALL enforce security best practices including HTTPS-only downloads, certificate verification, URL validation to prevent SSRF, credential protection, and malicious content detection.</p>
<section id="scenario-https-enforced-for-all-downloads">
<h3>Scenario: HTTPS enforced for all downloads<a class="headerlink" href="#scenario-https-enforced-for-all-downloads" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a FetchPlan contains url with http:// scheme (not https://)</p></li>
<li><p><strong>THEN</strong> the download manager logs warning “Insecure HTTP URL detected: <url>. Upgrading to HTTPS” and attempts HTTPS before falling back</p></li>
</ul>
</section>
<section id="scenario-tls-certificate-verification-enabled">
<h3>Scenario: TLS certificate verification enabled<a class="headerlink" href="#scenario-tls-certificate-verification-enabled" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> pooch/requests downloads from HTTPS URL</p></li>
<li><p><strong>THEN</strong> the system enables verify=True for certificate validation and fails on invalid/expired/self-signed certificates with clear error message</p></li>
</ul>
</section>
<section id="scenario-url-validation-prevents-ssrf-to-private-ips">
<h3>Scenario: URL validation prevents SSRF to private IPs<a class="headerlink" href="#scenario-url-validation-prevents-ssrf-to-private-ips" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a resolver returns FetchPlan with url pointing to private IP range (127.0.0.0/8, 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)</p></li>
<li><p><strong>THEN</strong> the download manager rejects the URL, logs error “Rejected download from private IP address: <ip>”, and skips ontology</p></li>
</ul>
</section>
<section id="scenario-api-keys-masked-in-logs">
<h3>Scenario: API keys masked in logs<a class="headerlink" href="#scenario-api-keys-masked-in-logs" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> logging BioPortal request with Authorization header containing API key</p></li>
<li><p><strong>THEN</strong> the log entry shows “Authorization: apikey <em><strong>masked</strong></em>” instead of plaintext key</p></li>
</ul>
</section>
<section id="scenario-safe-file-path-sanitization">
<h3>Scenario: Safe file path sanitization<a class="headerlink" href="#scenario-safe-file-path-sanitization" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> ontology filename from Content-Disposition header contains path separators or special chars (e.g., “../evil.owl”)</p></li>
<li><p><strong>THEN</strong> the system sanitizes filename to safe basename, logs warning “Sanitized unsafe filename: <original> -&gt; <safe>”</p></li>
</ul>
</section>
<section id="scenario-maximum-file-size-limit-enforced">
<h3>Scenario: Maximum file size limit enforced<a class="headerlink" href="#scenario-maximum-file-size-limit-enforced" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> Content-Length header indicates file &gt;5GB (configurable max_download_size)</p></li>
<li><p><strong>THEN</strong> the download manager logs error “File exceeds max_download_size: <size> &gt; 5GB”, skips download</p></li>
</ul>
</section>
<section id="scenario-zip-bomb-detection-for-xbrl">
<h3>Scenario: ZIP bomb detection for XBRL<a class="headerlink" href="#scenario-zip-bomb-detection-for-xbrl" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> extracting XBRL ZIP with uncompressed size &gt;10x compressed size (configurable ratio threshold)</p></li>
<li><p><strong>THEN</strong> the system detects potential ZIP bomb, logs error, and aborts extraction</p></li>
</ul>
</section>
</section>
<section id="requirement-performance-constraints-and-resource-management">
<h2>Requirement: Performance Constraints and Resource Management<a class="headerlink" href="#requirement-performance-constraints-and-resource-management" title="Link to this heading"></a></h2>
<p>The system SHALL enforce configurable performance limits including timeouts, memory constraints, concurrent operation limits, and provide mechanisms to handle large files efficiently.</p>
<section id="scenario-http-request-timeout-enforced">
<h3>Scenario: HTTP request timeout enforced<a class="headerlink" href="#scenario-http-request-timeout-enforced" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> any HTTP request (resolver API or download) exceeds configured timeout (default 30s for API, 300s for download)</p></li>
<li><p><strong>THEN</strong> requests library raises Timeout exception, system retries with backoff</p></li>
</ul>
</section>
<section id="scenario-concurrent-download-limit-enforced">
<h3>Scenario: Concurrent download limit enforced<a class="headerlink" href="#scenario-concurrent-download-limit-enforced" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> batch pull with &gt;10 ontologies and concurrent_downloads=3 config</p></li>
<li><p><strong>THEN</strong> the system uses asyncio semaphore or ThreadPoolExecutor with max_workers=3 to limit parallel downloads</p></li>
</ul>
</section>
<section id="scenario-memory-limit-configuration-respected">
<h3>Scenario: Memory limit configuration respected<a class="headerlink" href="#scenario-memory-limit-configuration-respected" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> config specifies max_memory_mb=2048 for parser operations</p></li>
<li><p><strong>THEN</strong> validators skip memory-intensive operations (Owlready2 reasoning) for files exceeding threshold and log skip reason</p></li>
</ul>
</section>
<section id="scenario-streaming-download-for-large-files">
<h3>Scenario: Streaming download for large files<a class="headerlink" href="#scenario-streaming-download-for-large-files" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> downloading file &gt;100MB</p></li>
<li><p><strong>THEN</strong> the download manager uses requests.iter_content() with chunk_size=1MB and progress reporting every 10%</p></li>
</ul>
</section>
<section id="scenario-parser-timeout-prevents-hanging">
<h3>Scenario: Parser timeout prevents hanging<a class="headerlink" href="#scenario-parser-timeout-prevents-hanging" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> RDFLib parse operation exceeds parser_timeout=60s config</p></li>
<li><p><strong>THEN</strong> the system uses signal.alarm() (Unix) or threading.Timer (Windows) to interrupt, logs timeout error</p></li>
</ul>
</section>
</section>
<section id="requirement-comprehensive-configuration-schema">
<h2>Requirement: Comprehensive Configuration Schema<a class="headerlink" href="#requirement-comprehensive-configuration-schema" title="Link to this heading"></a></h2>
<p>The system SHALL support all configurable parameters via sources.yaml with explicit defaults, validation rules, and environment variable overrides for operational flexibility.</p>
<section id="scenario-all-http-parameters-configurable">
<h3>Scenario: All HTTP parameters configurable<a class="headerlink" href="#scenario-all-http-parameters-configurable" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> sources.yaml specifies defaults.http with max_retries=3, timeout_sec=60, backoff_factor=1.0, per_host_rate_limit=”2/second”</p></li>
<li><p><strong>THEN</strong> the download manager applies these settings to all HTTP operations</p></li>
</ul>
</section>
<section id="scenario-default-values-used-when-parameters-missing">
<h3>Scenario: Default values used when parameters missing<a class="headerlink" href="#scenario-default-values-used-when-parameters-missing" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> sources.yaml omits defaults.http section entirely</p></li>
<li><p><strong>THEN</strong> the system applies built-in defaults: max_retries=5, timeout_sec=30, backoff_factor=0.5, per_host_rate_limit=”4/second”</p></li>
</ul>
</section>
<section id="scenario-environment-variables-override-config-file">
<h3>Scenario: Environment variables override config file<a class="headerlink" href="#scenario-environment-variables-override-config-file" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> ONTOFETCH_MAX_RETRIES=10 env var is set and sources.yaml has defaults.http.max_retries=5</p></li>
<li><p><strong>THEN</strong> the system uses max_retries=10 from environment and logs “Config overridden by env var: max_retries=10”</p></li>
</ul>
</section>
<section id="scenario-per-ontology-timeout-override">
<h3>Scenario: Per-ontology timeout override<a class="headerlink" href="#scenario-per-ontology-timeout-override" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> ontology entry has extras.timeout_sec=120 and defaults.http.timeout_sec=30</p></li>
<li><p><strong>THEN</strong> the system uses 120s timeout for that specific ontology only</p></li>
</ul>
</section>
<section id="scenario-invalid-configuration-value-rejected">
<h3>Scenario: Invalid configuration value rejected<a class="headerlink" href="#scenario-invalid-configuration-value-rejected" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> sources.yaml has defaults.http.max_retries=”many” (non-integer)</p></li>
<li><p><strong>THEN</strong> the config loader raises ValueError with message “Invalid max_retries: expected int, got str”</p></li>
</ul>
</section>
<section id="scenario-required-resolver-parameters-validated">
<h3>Scenario: Required resolver parameters validated<a class="headerlink" href="#scenario-required-resolver-parameters-validated" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> ontology specifies resolver=”bioportal” but omits extras.acronym</p></li>
<li><p><strong>THEN</strong> the config validator raises error “BioPortal resolver requires extras.acronym field”</p></li>
</ul>
</section>
</section>
<section id="requirement-enhanced-logging-with-levels-and-sensitive-data-protection">
<h2>Requirement: Enhanced Logging with Levels and Sensitive Data Protection<a class="headerlink" href="#requirement-enhanced-logging-with-levels-and-sensitive-data-protection" title="Link to this heading"></a></h2>
<p>The system SHALL implement multi-level logging (DEBUG, INFO, WARNING, ERROR) with configurable outputs, log rotation, sensitive data masking, and correlation IDs for batch operations.</p>
<section id="scenario-log-level-controls-verbosity">
<h3>Scenario: Log level controls verbosity<a class="headerlink" href="#scenario-log-level-controls-verbosity" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> CLI runs with –log-level DEBUG</p></li>
<li><p><strong>THEN</strong> all DEBUG messages (HTTP request/response details, cache hits) are written to logs/</p></li>
</ul>
</section>
<section id="scenario-default-info-level-production-logs">
<h3>Scenario: Default INFO level production logs<a class="headerlink" href="#scenario-default-info-level-production-logs" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> CLI runs without –log-level flag</p></li>
<li><p><strong>THEN</strong> only INFO and above (WARNING, ERROR) are written to console, all levels to logs/ontofetch_<timestamp>.jsonl</p></li>
</ul>
</section>
<section id="scenario-sensitive-data-masked-in-all-log-levels">
<h3>Scenario: Sensitive data masked in all log levels<a class="headerlink" href="#scenario-sensitive-data-masked-in-all-log-levels" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> logging at any level with API keys, Authorization headers, or credential paths</p></li>
<li><p><strong>THEN</strong> the log formatter replaces sensitive values with “<em><strong>masked</strong></em>” before writing</p></li>
</ul>
</section>
<section id="scenario-correlation-id-tracks-batch-operations">
<h3>Scenario: Correlation ID tracks batch operations<a class="headerlink" href="#scenario-correlation-id-tracks-batch-operations" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> batch pull processes 10 ontologies</p></li>
<li><p><strong>THEN</strong> all log entries for that batch include same correlation_id field allowing grep-based filtering</p></li>
</ul>
</section>
<section id="scenario-log-rotation-prevents-disk-exhaustion">
<h3>Scenario: Log rotation prevents disk exhaustion<a class="headerlink" href="#scenario-log-rotation-prevents-disk-exhaustion" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> logs/ directory exceeds configured max_log_size_mb=100</p></li>
<li><p><strong>THEN</strong> the system rotates to new file, compresses old logs, and deletes logs older than retention_days=30</p></li>
</ul>
</section>
<section id="scenario-structured-log-fields-parseable-by-log-aggregators">
<h3>Scenario: Structured log fields parseable by log aggregators<a class="headerlink" href="#scenario-structured-log-fields-parseable-by-log-aggregators" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> any log entry is written</p></li>
<li><p><strong>THEN</strong> it contains JSON with fields: timestamp (ISO8601), level, stage, correlation_id, ontology_id, message, and stage-specific fields</p></li>
</ul>
</section>
</section>
<section id="requirement-cross-platform-compatibility">
<h2>Requirement: Cross-Platform Compatibility<a class="headerlink" href="#requirement-cross-platform-compatibility" title="Link to this heading"></a></h2>
<p>The system SHALL operate correctly on Linux, macOS, and Windows with Python 3.9+ and handle platform-specific differences in paths, permissions, and subprocess execution.</p>
<section id="scenario-path-separators-platform-agnostic">
<h3>Scenario: Path separators platform-agnostic<a class="headerlink" href="#scenario-path-separators-platform-agnostic" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> constructing paths for ontologies/<id>/<version>/original/</p></li>
<li><p><strong>THEN</strong> the system uses pathlib.Path which handles Windows backslashes and Unix forward slashes correctly</p></li>
</ul>
</section>
<section id="scenario-signal-based-timeout-on-unix-platforms">
<h3>Scenario: Signal-based timeout on Unix platforms<a class="headerlink" href="#scenario-signal-based-timeout-on-unix-platforms" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> running on Linux or macOS and parser timeout needed</p></li>
<li><p><strong>THEN</strong> the system uses signal.alarm() for timeout enforcement</p></li>
</ul>
</section>
<section id="scenario-thread-based-timeout-on-windows">
<h3>Scenario: Thread-based timeout on Windows<a class="headerlink" href="#scenario-thread-based-timeout-on-windows" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> running on Windows (where signal.alarm() unavailable) and parser timeout needed</p></li>
<li><p><strong>THEN</strong> the system uses threading.Timer as alternative timeout mechanism</p></li>
</ul>
</section>
<section id="scenario-python-version-compatibility-checked">
<h3>Scenario: Python version compatibility checked<a class="headerlink" href="#scenario-python-version-compatibility-checked" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> ontofetch CLI starts</p></li>
<li><p><strong>THEN</strong> the system checks sys.version_info &gt;= (3, 9) and exits with error “Python 3.9+ required” if older</p></li>
</ul>
</section>
<section id="scenario-dependency-version-constraints-enforced">
<h3>Scenario: Dependency version constraints enforced<a class="headerlink" href="#scenario-dependency-version-constraints-enforced" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> installing via pip from requirements.txt</p></li>
<li><p><strong>THEN</strong> dependencies specify minimum versions: rdflib&gt;=7.0.0, pronto&gt;=2.5.0, pystow&gt;=0.5.0, pooch&gt;=1.7.0</p></li>
</ul>
</section>
</section>
<section id="requirement-user-documentation-and-help">
<h2>Requirement: User Documentation and Help<a class="headerlink" href="#requirement-user-documentation-and-help" title="Link to this heading"></a></h2>
<p>The system SHALL provide comprehensive inline help, error messages with remediation guidance, example configurations, and troubleshooting documentation.</p>
<section id="scenario-cli-help-text-shows-all-options">
<h3>Scenario: CLI help text shows all options<a class="headerlink" href="#scenario-cli-help-text-shows-all-options" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">--help</span></code></p></li>
<li><p><strong>THEN</strong> the output shows synopsis, subcommands (pull, show, validate), global options, and examples</p></li>
</ul>
</section>
<section id="scenario-subcommand-specific-help-available">
<h3>Scenario: Subcommand-specific help available<a class="headerlink" href="#scenario-subcommand-specific-help-available" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">pull</span> <span class="pre">--help</span></code></p></li>
<li><p><strong>THEN</strong> the output shows pull-specific options (–spec, –force, –resolver, –target-formats) with descriptions and examples</p></li>
</ul>
</section>
<section id="scenario-error-messages-include-remediation-steps">
<h3>Scenario: Error messages include remediation steps<a class="headerlink" href="#scenario-error-messages-include-remediation-steps" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> BioPortal API key missing error occurs</p></li>
<li><p><strong>THEN</strong> the error message includes “To configure: echo ‘YOUR_API_KEY’ &gt; ~/.config/pystow/ontology-fetcher/bioportal_api_key.txt”</p></li>
</ul>
</section>
<section id="scenario-example-sources-yaml-with-inline-comments">
<h3>Scenario: Example sources.yaml with inline comments<a class="headerlink" href="#scenario-example-sources-yaml-with-inline-comments" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">init</span></code> to create default config</p></li>
<li><p><strong>THEN</strong> the generated sources.yaml contains commented examples for each resolver type and all configurable parameters</p></li>
</ul>
</section>
<section id="scenario-validation-error-messages-cite-line-numbers">
<h3>Scenario: Validation error messages cite line numbers<a class="headerlink" href="#scenario-validation-error-messages-cite-line-numbers" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> YAML parse error or schema validation fails</p></li>
<li><p><strong>THEN</strong> the error message includes “Error in sources.yaml line 42: missing required field ‘id’”</p></li>
</ul>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, DocsToKG Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>