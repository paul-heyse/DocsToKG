

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADDED Requirements &mdash; DocsToKG 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/css/custom.css" />

  
      <script src="../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../index.html" class="icon icon-home">
            DocsToKG
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../01-overview/index.html">1. Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../02-setup/index.html">1. Setup Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../03-architecture/index.html">1. Architecture Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../04-api/index.html">1. API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../05-development/index.html">1. Development Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../06-operations/index.html">1. Operations Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../07-reference/index.html">1. Technical Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../index.html">DocsToKG</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">ADDED Requirements</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../_sources/openspec/changes/archive/2025-10-15-refactor-content-download-pipeline/specs/content-download/spec.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="added-requirements">
<h1>ADDED Requirements<a class="headerlink" href="#added-requirements" title="Link to this heading"></a></h1>
<section id="requirement-automatic-retry-on-transient-http-errors">
<h2>Requirement: Automatic Retry on Transient HTTP Errors<a class="headerlink" href="#requirement-automatic-retry-on-transient-http-errors" title="Link to this heading"></a></h2>
<p>The system SHALL automatically retry HTTP requests that fail due to transient errors (429, 502, 503, 504) using exponential backoff with Retry-After header support, up to a configured maximum of 5 attempts, to eliminate misses from temporary network issues.</p>
<section id="scenario-503-service-unavailable-retried-successfully">
<h3>Scenario: 503 Service Unavailable retried successfully<a class="headerlink" href="#scenario-503-service-unavailable-retried-successfully" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a resolver API returns HTTP 503 on first attempt</p></li>
<li><p><strong>THEN</strong> the system waits backoff_factor * 2^attempt seconds, retries, and succeeds on second attempt without logging permanent failure</p></li>
</ul>
</section>
<section id="scenario-429-rate-limit-with-retry-after-honored">
<h3>Scenario: 429 Rate Limit with Retry-After honored<a class="headerlink" href="#scenario-429-rate-limit-with-retry-after-honored" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a resolver returns 429 with Retry-After: 5 header</p></li>
<li><p><strong>THEN</strong> the system waits at least 5 seconds before retry, respects the server’s guidance</p></li>
</ul>
</section>
<section id="scenario-404-not-found-fails-immediately-without-retry">
<h3>Scenario: 404 Not Found fails immediately without retry<a class="headerlink" href="#scenario-404-not-found-fails-immediately-without-retry" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a download URL returns 404</p></li>
<li><p><strong>THEN</strong> the system logs permanent failure immediately, does not retry, moves to next candidate</p></li>
</ul>
</section>
<section id="scenario-maximum-retry-budget-exhausted">
<h3>Scenario: Maximum retry budget exhausted<a class="headerlink" href="#scenario-maximum-retry-budget-exhausted" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a URL returns 503 on all 5 retry attempts</p></li>
<li><p><strong>THEN</strong> the system logs final failure with reason “max-retries-exhausted” and moves to next resolver</p></li>
</ul>
</section>
</section>
<section id="requirement-atomic-file-writes-with-integrity-verification">
<h2>Requirement: Atomic File Writes with Integrity Verification<a class="headerlink" href="#requirement-atomic-file-writes-with-integrity-verification" title="Link to this heading"></a></h2>
<p>The system SHALL write downloaded files to temporary .part files, compute SHA-256 digests and content length, then atomically rename to final paths to prevent partial file corruption and enable deduplication.</p>
<section id="scenario-successful-download-with-atomic-rename">
<h3>Scenario: Successful download with atomic rename<a class="headerlink" href="#scenario-successful-download-with-atomic-rename" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a PDF downloads completely</p></li>
<li><p><strong>THEN</strong> the system writes to *.part, computes SHA-256, performs os.replace() to final path, logs digest and size</p></li>
</ul>
</section>
<section id="scenario-download-interrupted-mid-stream">
<h3>Scenario: Download interrupted mid-stream<a class="headerlink" href="#scenario-download-interrupted-mid-stream" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> download is killed via SIGKILL while writing</p></li>
<li><p><strong>THEN</strong> only *.part file exists, final path does not exist, no corrupted PDF in storage</p></li>
</ul>
</section>
<section id="scenario-digest-enables-deduplication">
<h3>Scenario: Digest enables deduplication<a class="headerlink" href="#scenario-digest-enables-deduplication" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> two works have same PDF at different URLs</p></li>
<li><p><strong>THEN</strong> manifest records show identical SHA-256, allowing downstream dedup by digest</p></li>
</ul>
</section>
</section>
<section id="requirement-unambiguous-rate-limit-configuration">
<h2>Requirement: Unambiguous Rate Limit Configuration<a class="headerlink" href="#requirement-unambiguous-rate-limit-configuration" title="Link to this heading"></a></h2>
<p>The system SHALL use explicit <code class="docutils literal notranslate"><span class="pre">resolver_min_interval_s</span></code> configuration field to specify minimum seconds between calls per resolver, replacing ambiguous <code class="docutils literal notranslate"><span class="pre">resolver_rate_limits</span></code>, with deprecation warning and auto-migration for old configs.</p>
<section id="scenario-config-specifies-min-interval-s">
<h3>Scenario: Config specifies min_interval_s<a class="headerlink" href="#scenario-config-specifies-min-interval-s" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> config contains <code class="docutils literal notranslate"><span class="pre">resolver_min_interval_s:</span> <span class="pre">{&quot;unpaywall&quot;:</span> <span class="pre">1.0}</span></code></p></li>
<li><p><strong>THEN</strong> system enforces minimum 1.0 seconds between Unpaywall calls (max ~1 QPS)</p></li>
</ul>
</section>
<section id="scenario-legacy-resolver-rate-limits-config-auto-migrates">
<h3>Scenario: Legacy resolver_rate_limits config auto-migrates<a class="headerlink" href="#scenario-legacy-resolver-rate-limits-config-auto-migrates" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> config contains deprecated <code class="docutils literal notranslate"><span class="pre">resolver_rate_limits:</span> <span class="pre">{&quot;unpaywall&quot;:</span> <span class="pre">1.0}</span></code></p></li>
<li><p><strong>THEN</strong> system logs deprecation warning, auto-migrates value to min_interval_s, continues normally</p></li>
</ul>
</section>
<section id="scenario-misconfiguration-with-both-fields-present">
<h3>Scenario: Misconfiguration with both fields present<a class="headerlink" href="#scenario-misconfiguration-with-both-fields-present" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> config contains both resolver_rate_limits and resolver_min_interval_s</p></li>
<li><p><strong>THEN</strong> system logs error “Conflicting rate limit fields” and fails gracefully with clear remediation message</p></li>
</ul>
</section>
</section>
<section id="requirement-lru-cache-for-resolver-api-responses">
<h2>Requirement: LRU Cache for Resolver API Responses<a class="headerlink" href="#requirement-lru-cache-for-resolver-api-responses" title="Link to this heading"></a></h2>
<p>The system SHALL cache resolver API responses (Unpaywall, Crossref, Semantic Scholar) in-memory using LRU cache (maxsize=1000) keyed by (resolver_name, identifier) to eliminate redundant API calls within batch runs.</p>
<section id="scenario-same-doi-queried-twice-uses-cache">
<h3>Scenario: Same DOI queried twice uses cache<a class="headerlink" href="#scenario-same-doi-queried-twice-uses-cache" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> two works share the same DOI and Unpaywall resolver is invoked for both</p></li>
<li><p><strong>THEN</strong> only one HTTP request is made to Unpaywall API, second lookup served from cache</p></li>
</ul>
</section>
<section id="scenario-cache-cleared-on-resume">
<h3>Scenario: Cache cleared on resume<a class="headerlink" href="#scenario-cache-cleared-on-resume" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> –resume-from flag is used to restart a batch</p></li>
<li><p><strong>THEN</strong> resolver caches are cleared before processing to force fresh API lookups</p></li>
</ul>
</section>
<section id="scenario-cache-hit-logged-in-metrics">
<h3>Scenario: Cache hit logged in metrics<a class="headerlink" href="#scenario-cache-hit-logged-in-metrics" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a resolver API response is served from cache</p></li>
<li><p><strong>THEN</strong> metrics show cache_hit=true in resolver metadata, elapsed_ms near zero</p></li>
</ul>
</section>
</section>
<section id="requirement-conditional-request-support-for-idempotent-re-runs">
<h2>Requirement: Conditional Request Support for Idempotent Re-runs<a class="headerlink" href="#requirement-conditional-request-support-for-idempotent-re-runs" title="Link to this heading"></a></h2>
<p>The system SHALL support HTTP conditional requests using If-None-Match (ETag) and If-Modified-Since (Last-Modified) headers to enable fast 304 responses on unchanged resources when re-running batches.</p>
<section id="scenario-etag-match-returns-304-cached">
<h3>Scenario: ETag match returns 304 cached<a class="headerlink" href="#scenario-etag-match-returns-304-cached" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> manifest records previous ETag for a URL and re-run fetches same URL</p></li>
<li><p><strong>THEN</strong> system sends If-None-Match with ETag, receives 304, returns DownloadOutcome(classification=’cached’, path=existing_path) without re-downloading</p></li>
</ul>
</section>
<section id="scenario-last-modified-unchanged-returns-304">
<h3>Scenario: Last-Modified unchanged returns 304<a class="headerlink" href="#scenario-last-modified-unchanged-returns-304" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> manifest records Last-Modified and resource unchanged</p></li>
<li><p><strong>THEN</strong> system sends If-Modified-Since, receives 304, skips download</p></li>
</ul>
</section>
<section id="scenario-resource-updated-returns-200-with-new-content">
<h3>Scenario: Resource updated returns 200 with new content<a class="headerlink" href="#scenario-resource-updated-returns-200-with-new-content" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> ETag sent but resource changed since last fetch</p></li>
<li><p><strong>THEN</strong> system receives 200, downloads new version, updates manifest with new ETag and SHA-256</p></li>
</ul>
</section>
</section>
<section id="requirement-unified-jsonl-logging">
<h2>Requirement: Unified JSONL Logging<a class="headerlink" href="#requirement-unified-jsonl-logging" title="Link to this heading"></a></h2>
<p>The system SHALL log all resolver attempts and work summaries to a single JSONL file with structured records (timestamp, record_type, work_id, resolver_name, status, http_status, sha256, content_length, elapsed_ms) replacing separate CSV and manifest files, with CSV export script provided for backward compatibility.</p>
<section id="scenario-attempt-logged-as-jsonl-record">
<h3>Scenario: Attempt logged as JSONL record<a class="headerlink" href="#scenario-attempt-logged-as-jsonl-record" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a resolver attempts a URL</p></li>
<li><p><strong>THEN</strong> logger writes JSON line: <code class="docutils literal notranslate"><span class="pre">{&quot;timestamp&quot;:</span> <span class="pre">&quot;ISO8601&quot;,</span> <span class="pre">&quot;record_type&quot;:</span> <span class="pre">&quot;attempt&quot;,</span> <span class="pre">&quot;work_id&quot;:</span> <span class="pre">&quot;W123&quot;,</span> <span class="pre">&quot;resolver_name&quot;:</span> <span class="pre">&quot;unpaywall&quot;,</span> <span class="pre">&quot;url&quot;:</span> <span class="pre">&quot;...&quot;,</span> <span class="pre">&quot;status&quot;:</span> <span class="pre">&quot;pdf&quot;,</span> <span class="pre">&quot;http_status&quot;:</span> <span class="pre">200,</span> <span class="pre">&quot;sha256&quot;:</span> <span class="pre">&quot;abc...&quot;,</span> <span class="pre">&quot;content_length&quot;:</span> <span class="pre">123456,</span> <span class="pre">&quot;elapsed_ms&quot;:</span> <span class="pre">1234.5}</span></code></p></li>
</ul>
</section>
<section id="scenario-work-summary-logged-as-jsonl-record">
<h3>Scenario: Work summary logged as JSONL record<a class="headerlink" href="#scenario-work-summary-logged-as-jsonl-record" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> a work completes processing (success or failure)</p></li>
<li><p><strong>THEN</strong> logger writes JSON line with record_type=”summary” containing total_attempts, resolvers_used, final_status, html_paths</p></li>
</ul>
</section>
<section id="scenario-csv-export-from-jsonl">
<h3>Scenario: CSV export from JSONL<a class="headerlink" href="#scenario-csv-export-from-jsonl" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> operator runs <code class="docutils literal notranslate"><span class="pre">scripts/export_attempts_csv.py</span> <span class="pre">attempts.jsonl</span></code></p></li>
<li><p><strong>THEN</strong> script outputs CSV with columns matching legacy CsvAttemptLogger format for backward compatibility</p></li>
</ul>
</section>
<section id="scenario-machine-readable-queries-on-jsonl">
<h3>Scenario: Machine-readable queries on JSONL<a class="headerlink" href="#scenario-machine-readable-queries-on-jsonl" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> operator runs <code class="docutils literal notranslate"><span class="pre">jq</span> <span class="pre">'.resolver_name</span> <span class="pre">==</span> <span class="pre">&quot;unpaywall&quot;</span> <span class="pre">and</span> <span class="pre">.status</span> <span class="pre">==</span> <span class="pre">&quot;pdf&quot;'</span> <span class="pre">attempts.jsonl</span></code></p></li>
<li><p><strong>THEN</strong> structured JSONL enables efficient filtering without parsing CSV</p></li>
</ul>
</section>
</section>
<section id="requirement-bounded-parallel-execution">
<h2>Requirement: Bounded Parallel Execution<a class="headerlink" href="#requirement-bounded-parallel-execution" title="Link to this heading"></a></h2>
<p>The system SHALL support bounded parallelism via –workers N flag using ThreadPoolExecutor to process multiple works concurrently (2-5x throughput) while maintaining per-work sequential pipeline and thread-safe per-resolver rate limiting.</p>
<section id="scenario-parallel-processing-with-workers-3">
<h3>Scenario: Parallel processing with –workers=3<a class="headerlink" href="#scenario-parallel-processing-with-workers-3" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> batch run invoked with –workers=3</p></li>
<li><p><strong>THEN</strong> up to 3 works are processed concurrently via ThreadPoolExecutor, each with own session</p></li>
</ul>
</section>
<section id="scenario-rate-limiting-enforced-across-parallel-workers">
<h3>Scenario: Rate limiting enforced across parallel workers<a class="headerlink" href="#scenario-rate-limiting-enforced-across-parallel-workers" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> multiple workers call same resolver (e.g., Unpaywall) concurrently</p></li>
<li><p><strong>THEN</strong> shared <code class="docutils literal notranslate"><span class="pre">_last_invocation</span></code> dict with threading.Lock enforces global min_interval_s, preventing rate limit violations</p></li>
</ul>
</section>
<section id="scenario-sequential-mode-backward-compatible">
<h3>Scenario: Sequential mode backward compatible<a class="headerlink" href="#scenario-sequential-mode-backward-compatible" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> –workers=1 (default) used</p></li>
<li><p><strong>THEN</strong> system processes works sequentially as before, no threading overhead</p></li>
</ul>
</section>
<section id="scenario-worker-failure-isolated">
<h3>Scenario: Worker failure isolated<a class="headerlink" href="#scenario-worker-failure-isolated" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> one worker encounters exception during work processing</p></li>
<li><p><strong>THEN</strong> other workers continue normally, failed work logged with traceback, batch completes</p></li>
</ul>
</section>
</section>
<section id="requirement-dry-run-mode-for-coverage-measurement">
<h2>Requirement: Dry Run Mode for Coverage Measurement<a class="headerlink" href="#requirement-dry-run-mode-for-coverage-measurement" title="Link to this heading"></a></h2>
<p>The system SHALL support –dry-run flag that measures resolver coverage and logs attempts without writing files to enable quick testing and coverage analysis.</p>
<section id="scenario-dry-run-logs-attempts-without-files">
<h3>Scenario: Dry run logs attempts without files<a class="headerlink" href="#scenario-dry-run-logs-attempts-without-files" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> batch run with –dry-run flag</p></li>
<li><p><strong>THEN</strong> all resolver attempts logged with classifications (pdf/html/miss), no files written to disk, summary shows coverage percentages</p></li>
</ul>
</section>
<section id="scenario-dry-run-metadata-includes-flag">
<h3>Scenario: Dry run metadata includes flag<a class="headerlink" href="#scenario-dry-run-metadata-includes-flag" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> dry run completes</p></li>
<li><p><strong>THEN</strong> all JSONL records include <code class="docutils literal notranslate"><span class="pre">dry_run:</span> <span class="pre">true</span></code> field, final summary includes “DRY RUN: no files written”</p></li>
</ul>
</section>
</section>
<section id="requirement-resume-from-manifest">
<h2>Requirement: Resume from Manifest<a class="headerlink" href="#requirement-resume-from-manifest" title="Link to this heading"></a></h2>
<p>The system SHALL support –resume-from manifest.jsonl flag to skip works already successfully processed, enabling efficient idempotent re-runs after interruptions.</p>
<section id="scenario-completed-works-skipped-on-resume">
<h3>Scenario: Completed works skipped on resume<a class="headerlink" href="#scenario-completed-works-skipped-on-resume" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> –resume-from manifest.jsonl used and manifest contains work W123 with status ‘success’</p></li>
<li><p><strong>THEN</strong> system skips W123 during iteration, logs “Skipping W123 (already completed)”, processes only missed works</p></li>
</ul>
</section>
<section id="scenario-failed-works-retried-on-resume">
<h3>Scenario: Failed works retried on resume<a class="headerlink" href="#scenario-failed-works-retried-on-resume" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> manifest contains work W456 with status ‘miss’</p></li>
<li><p><strong>THEN</strong> system re-attempts W456 with full resolver pipeline</p></li>
</ul>
</section>
</section>
<section id="requirement-html-text-extraction">
<h2>Requirement: HTML Text Extraction<a class="headerlink" href="#requirement-html-text-extraction" title="Link to this heading"></a></h2>
<p>The system SHALL optionally extract plaintext from HTML fallbacks using trafilatura when –extract-html-text flag is set, saving *.html.txt files alongside raw HTML for downstream parsers.</p>
<section id="scenario-html-text-extracted-with-trafilatura">
<h3>Scenario: HTML text extracted with trafilatura<a class="headerlink" href="#scenario-html-text-extracted-with-trafilatura" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> resolver returns HTML and –extract-html-text flag set</p></li>
<li><p><strong>THEN</strong> system saves raw HTML to <em>.html, extracts plaintext with trafilatura, saves to</em>.html.txt, logs extracted_text_path in manifest</p></li>
</ul>
</section>
<section id="scenario-trafilatura-missing-logs-warning">
<h3>Scenario: Trafilatura missing logs warning<a class="headerlink" href="#scenario-trafilatura-missing-logs-warning" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> –extract-html-text set but trafilatura not installed</p></li>
<li><p><strong>THEN</strong> system logs warning “trafilatura not available, skipping text extraction”, continues with raw HTML only</p></li>
</ul>
</section>
</section>
<section id="requirement-extended-resolver-coverage">
<h2>Requirement: Extended Resolver Coverage<a class="headerlink" href="#requirement-extended-resolver-coverage" title="Link to this heading"></a></h2>
<p>The system SHALL support optional OpenAIRE, HAL, and OSF Preprints resolvers (disabled by default) to expand EU OA and preprint coverage beyond existing 10 resolvers.</p>
<section id="scenario-openaire-resolver-enabled">
<h3>Scenario: OpenAIRE resolver enabled<a class="headerlink" href="#scenario-openaire-resolver-enabled" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> config sets <code class="docutils literal notranslate"><span class="pre">resolver_toggles:</span> <span class="pre">{&quot;openaire&quot;:</span> <span class="pre">true}</span></code> and work has DOI</p></li>
<li><p><strong>THEN</strong> OpenAIRE resolver queries <a class="reference external" href="https://api.openaire.eu/search/publications?doi=">https://api.openaire.eu/search/publications?doi=</a>… and yields PDF links from instances</p></li>
</ul>
</section>
<section id="scenario-hal-resolver-for-french-oa">
<h3>Scenario: HAL resolver for French OA<a class="headerlink" href="#scenario-hal-resolver-for-french-oa" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> HAL resolver enabled and work has DOI</p></li>
<li><p><strong>THEN</strong> resolver queries <a class="reference external" href="https://api.archives-ouvertes.fr/search/?q=doiId_s">https://api.archives-ouvertes.fr/search/?q=doiId_s</a>:… and yields file_s PDF URLs</p></li>
</ul>
</section>
<section id="scenario-osf-preprints-resolver">
<h3>Scenario: OSF Preprints resolver<a class="headerlink" href="#scenario-osf-preprints-resolver" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> OSF resolver enabled and work has DOI</p></li>
<li><p><strong>THEN</strong> resolver queries <a class="reference external" href="https://api.osf.io/v2/preprints/?filter%5Bdoi%5D=">https://api.osf.io/v2/preprints/?filter[doi]=</a>… and yields links.download URLs</p></li>
</ul>
</section>
<section id="scenario-new-resolvers-disabled-by-default">
<h3>Scenario: New resolvers disabled by default<a class="headerlink" href="#scenario-new-resolvers-disabled-by-default" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> config does not explicitly enable openaire/hal/osf</p></li>
<li><p><strong>THEN</strong> these resolvers are skipped, no API calls made, no impact on default runs</p></li>
</ul>
</section>
</section>
</section>
<section id="modified-requirements">
<h1>MODIFIED Requirements<a class="headerlink" href="#modified-requirements" title="Link to this heading"></a></h1>
<section id="requirement-enhanced-user-agent-for-crossref-compliance">
<h2>Requirement: Enhanced User-Agent for Crossref Compliance<a class="headerlink" href="#requirement-enhanced-user-agent-for-crossref-compliance" title="Link to this heading"></a></h2>
<p>The system SHALL include mailto address directly in User-Agent string for Crossref API requests (in addition to separate header) following Crossref best practices: <code class="docutils literal notranslate"><span class="pre">DocsToKGDownloader/1.0</span> <span class="pre">(+mailto:user&#64;example.com)</span></code>.</p>
<section id="scenario-user-agent-includes-mailto">
<h3>Scenario: User-Agent includes mailto<a class="headerlink" href="#scenario-user-agent-includes-mailto" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> Crossref resolver makes API request with config.mailto set</p></li>
<li><p><strong>THEN</strong> User-Agent header is <code class="docutils literal notranslate"><span class="pre">DocsToKGDownloader/1.0</span> <span class="pre">(+mailto:user&#64;example.com;</span> <span class="pre">mailto:user&#64;example.com)</span></code></p></li>
</ul>
</section>
<section id="scenario-crossref-polite-pool-access">
<h3>Scenario: Crossref polite pool access<a class="headerlink" href="#scenario-crossref-polite-pool-access" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> properly formatted User-Agent with mailto sent to Crossref API</p></li>
<li><p><strong>THEN</strong> requests are processed via Crossref polite pool with higher rate limits and priority</p></li>
</ul>
</section>
</section>
<section id="requirement-refactored-download-state-machine">
<h2>Requirement: Refactored Download State Machine<a class="headerlink" href="#requirement-refactored-download-state-machine" title="Link to this heading"></a></h2>
<p>The system SHALL use explicit DownloadState enum (PENDING/WRITING) in <code class="docutils literal notranslate"><span class="pre">download_candidate()</span></code> with single outcome-building function to improve readability and testability while preserving all existing validation (EOF check, sniff logic).</p>
<section id="scenario-state-transitions-from-pending-to-writing">
<h3>Scenario: State transitions from PENDING to WRITING<a class="headerlink" href="#scenario-state-transitions-from-pending-to-writing" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> streaming download and payload classification completes (detected = ‘pdf’)</p></li>
<li><p><strong>THEN</strong> state transitions from DownloadState.PENDING to DownloadState.WRITING, file handle opened</p></li>
</ul>
</section>
<section id="scenario-single-outcome-builder-invoked">
<h3>Scenario: Single outcome builder invoked<a class="headerlink" href="#scenario-single-outcome-builder-invoked" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> download completes or errors</p></li>
<li><p><strong>THEN</strong> <code class="docutils literal notranslate"><span class="pre">_build_download_outcome()</span></code> function constructs DownloadOutcome with consistent fields (classification, path, http_status, sha256, content_length, elapsed_ms)</p></li>
</ul>
</section>
<section id="scenario-existing-validations-preserved">
<h3>Scenario: Existing validations preserved<a class="headerlink" href="#scenario-existing-validations-preserved" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> PDF downloaded</p></li>
<li><p><strong>THEN</strong> EOF check (<code class="docutils literal notranslate"><span class="pre">%%EOF</span></code> in tail bytes) still executed, corrupt PDFs detected and rejected as before</p></li>
</ul>
</section>
</section>
<section id="requirement-shared-utility-functions">
<h2>Requirement: Shared Utility Functions<a class="headerlink" href="#requirement-shared-utility-functions" title="Link to this heading"></a></h2>
<p>The system SHALL extract duplicated normalization utilities (<code class="docutils literal notranslate"><span class="pre">normalize_doi</span></code>, <code class="docutils literal notranslate"><span class="pre">normalize_pmcid</span></code>, <code class="docutils literal notranslate"><span class="pre">strip_prefix</span></code>, <code class="docutils literal notranslate"><span class="pre">dedupe</span></code>) from <code class="docutils literal notranslate"><span class="pre">download_pyalex_pdfs.py</span></code> and <code class="docutils literal notranslate"><span class="pre">resolvers/__init__.py</span></code> into <code class="docutils literal notranslate"><span class="pre">ContentDownload/utils.py</span></code> to reduce code duplication by ~15% and improve maintainability.</p>
<section id="scenario-doi-normalization-reused">
<h3>Scenario: DOI normalization reused<a class="headerlink" href="#scenario-doi-normalization-reused" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> both main module and resolvers need to normalize DOI</p></li>
<li><p><strong>THEN</strong> both import <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">ContentDownload.utils</span> <span class="pre">import</span> <span class="pre">normalize_doi</span></code> and use same implementation</p></li>
</ul>
</section>
<section id="scenario-dedupe-preserves-order">
<h3>Scenario: Dedupe preserves order<a class="headerlink" href="#scenario-dedupe-preserves-order" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>WHEN</strong> <code class="docutils literal notranslate"><span class="pre">utils.dedupe(['b',</span> <span class="pre">'a',</span> <span class="pre">'b',</span> <span class="pre">'c'])</span></code> called</p></li>
<li><p><strong>THEN</strong> returns <code class="docutils literal notranslate"><span class="pre">['b',</span> <span class="pre">'a',</span> <span class="pre">'c']</span></code> preserving first occurrence order</p></li>
</ul>
</section>
</section>
</section>
<section id="removed-requirements">
<h1>REMOVED Requirements<a class="headerlink" href="#removed-requirements" title="Link to this heading"></a></h1>
<p>None. All existing requirements remain, only enhanced with additional capabilities.</p>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, DocsToKG Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>