

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ontology Downloader Enhancement Specification &mdash; DocsToKG 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/css/custom.css" />


      <script src="../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
</head>

<body class="wy-body-for-nav">
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >



          <a href="../../../../../index.html" class="icon icon-home">
            DocsToKG
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../01-overview/index.html">1. Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../02-setup/index.html">1. Setup Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../03-architecture/index.html">1. Architecture Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../04-api/index.html">1. API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../05-development/index.html">1. Development Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../06-operations/index.html">1. Operations Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../07-reference/index.html">1. Technical Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">DocsToKG</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Ontology Downloader Enhancement Specification</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../_sources/openspec/changes/enhance-ontology-downloader-robustness/specs/ontology-downloader/spec.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">

  <section id="ontology-downloader-enhancement-specification">
<h1>Ontology Downloader Enhancement Specification<a class="headerlink" href="#ontology-downloader-enhancement-specification" title="Link to this heading"></a></h1>
<section id="added-requirements">
<h2>ADDED Requirements<a class="headerlink" href="#added-requirements" title="Link to this heading"></a></h2>
<section id="requirement-centralized-optional-dependency-management">
<h3>Requirement: Centralized Optional Dependency Management<a class="headerlink" href="#requirement-centralized-optional-dependency-management" title="Link to this heading"></a></h3>
<p>The system SHALL provide a centralized module for managing optional dependencies with consistent fallback behavior across all components.</p>
<section id="scenario-import-pystow-via-optdeps-when-available">
<h4>Scenario: Import pystow via optdeps when available<a class="headerlink" href="#scenario-import-pystow-via-optdeps-when-available" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> a module imports pystow via <code class="docutils literal notranslate"><span class="pre">optdeps.get_pystow()</span></code> and pystow is installed</p></li>
<li><p><strong>THEN</strong> the function returns the real pystow module with full functionality</p></li>
</ul>
</section>
<section id="scenario-use-pystow-fallback-stub-when-not-installed">
<h4>Scenario: Use pystow fallback stub when not installed<a class="headerlink" href="#scenario-use-pystow-fallback-stub-when-not-installed" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> a module imports pystow via <code class="docutils literal notranslate"><span class="pre">optdeps.get_pystow()</span></code> and pystow is not installed</p></li>
<li><p><strong>THEN</strong> the function returns a lightweight stub that provides Path-based fallback using PYSTOW_HOME environment variable</p></li>
</ul>
</section>
<section id="scenario-import-rdflib-via-optdeps-with-stub-fallback">
<h4>Scenario: Import rdflib via optdeps with stub fallback<a class="headerlink" href="#scenario-import-rdflib-via-optdeps-with-stub-fallback" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> validators import rdflib via <code class="docutils literal notranslate"><span class="pre">optdeps.get_rdflib()</span></code> and rdflib is not installed</p></li>
<li><p><strong>THEN</strong> the function returns a stub with Graph class that records parse source and serializes to destination</p></li>
</ul>
</section>
<section id="scenario-import-pronto-via-optdeps-with-stub-fallback">
<h4>Scenario: Import pronto via optdeps with stub fallback<a class="headerlink" href="#scenario-import-pronto-via-optdeps-with-stub-fallback" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> validators import pronto via <code class="docutils literal notranslate"><span class="pre">optdeps.get_pronto()</span></code> and pronto is not installed</p></li>
<li><p><strong>THEN</strong> the function returns a stub with Ontology class that provides placeholder terms and minimal dump functionality</p></li>
</ul>
</section>
<section id="scenario-import-owlready2-via-optdeps-with-stub-fallback">
<h4>Scenario: Import owlready2 via optdeps with stub fallback<a class="headerlink" href="#scenario-import-owlready2-via-optdeps-with-stub-fallback" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> validators import owlready2 via <code class="docutils literal notranslate"><span class="pre">optdeps.get_owlready2()</span></code> and owlready2 is not installed</p></li>
<li><p><strong>THEN</strong> the function returns a stub with get_ontology function returning placeholder loaded ontology</p></li>
</ul>
</section>
<section id="scenario-single-source-of-truth-for-all-modules">
<h4>Scenario: Single source of truth for all modules<a class="headerlink" href="#scenario-single-source-of-truth-for-all-modules" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> core.py, resolvers.py, and validators.py all need pystow</p></li>
<li><p><strong>THEN</strong> all modules import from optdeps.get_pystow() without local stub duplication</p></li>
</ul>
</section>
</section>
<section id="requirement-cli-formatting-utility-module">
<h3>Requirement: CLI Formatting Utility Module<a class="headerlink" href="#requirement-cli-formatting-utility-module" title="Link to this heading"></a></h3>
<p>The system SHALL provide reusable CLI formatting utilities for consistent table and summary output across all subcommands.</p>
<section id="scenario-format-table-with-headers-and-rows">
<h4>Scenario: Format table with headers and rows<a class="headerlink" href="#scenario-format-table-with-headers-and-rows" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> CLI needs to display tabular data with headers [“id”, “status”] and rows [[“hp”, “success”], [“efo”, “cached”]]</p></li>
<li><p><strong>THEN</strong> cli_utils.format_table() returns properly aligned table with column separators and header underline</p></li>
</ul>
</section>
<section id="scenario-format-validation-summary-with-status-indicators">
<h4>Scenario: Format validation summary with status indicators<a class="headerlink" href="#scenario-format-validation-summary-with-status-indicators" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> CLI needs to display validation results {“rdflib”: {“ok”: true}, “pronto”: {“ok”: false, “error”: “timeout”}}</p></li>
<li><p><strong>THEN</strong> cli_utils.format_validation_summary() returns table with validator, status, and details columns</p></li>
</ul>
</section>
<section id="scenario-reuse-formatting-across-multiple-subcommands">
<h4>Scenario: Reuse formatting across multiple subcommands<a class="headerlink" href="#scenario-reuse-formatting-across-multiple-subcommands" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> show, validate, and pull subcommands all need table formatting</p></li>
<li><p><strong>THEN</strong> all subcommands import and use cli_utils functions without duplication</p></li>
</ul>
</section>
</section>
<section id="requirement-pydantic-v2-configuration-models">
<h3>Requirement: Pydantic v2 Configuration Models<a class="headerlink" href="#requirement-pydantic-v2-configuration-models" title="Link to this heading"></a></h3>
<p>The system SHALL use Pydantic v2 BaseModel classes for all configuration parsing with built-in validation, environment variable merging, and JSON Schema generation.</p>
<section id="scenario-parse-configuration-with-pydantic-validation">
<h4>Scenario: Parse configuration with Pydantic validation<a class="headerlink" href="#scenario-parse-configuration-with-pydantic-validation" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> sources.yaml contains defaults.http.max_retries=-1 (invalid negative value)</p></li>
<li><p><strong>THEN</strong> Pydantic field validator raises ValidationError with clear message “max_retries must be &gt;= 0”</p></li>
</ul>
</section>
<section id="scenario-apply-default-values-via-pydantic-field-definitions">
<h4>Scenario: Apply default values via Pydantic Field definitions<a class="headerlink" href="#scenario-apply-default-values-via-pydantic-field-definitions" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> sources.yaml omits defaults.http.timeout_sec field</p></li>
<li><p><strong>THEN</strong> Pydantic model applies default value of 30 from Field(default=30) definition</p></li>
</ul>
</section>
<section id="scenario-validate-rate-limit-format-with-pydantic-pattern">
<h4>Scenario: Validate rate limit format with Pydantic pattern<a class="headerlink" href="#scenario-validate-rate-limit-format-with-pydantic-pattern" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> sources.yaml contains defaults.http.per_host_rate_limit=”invalid”</p></li>
<li><p><strong>THEN</strong> Pydantic pattern validator raises ValidationError with expected format message</p></li>
</ul>
</section>
<section id="scenario-environment-variable-override-via-pydantic-settings">
<h4>Scenario: Environment variable override via Pydantic settings<a class="headerlink" href="#scenario-environment-variable-override-via-pydantic-settings" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> ONTOFETCH_MAX_RETRIES=10 environment variable is set</p></li>
<li><p><strong>THEN</strong> Pydantic settings merge applies env value overriding config file value</p></li>
</ul>
</section>
<section id="scenario-generate-json-schema-from-pydantic-models">
<h4>Scenario: Generate JSON Schema from Pydantic models<a class="headerlink" href="#scenario-generate-json-schema-from-pydantic-models" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> documentation generator requests configuration schema</p></li>
<li><p><strong>THEN</strong> Pydantic model.model_json_schema() returns complete JSON Schema with types, defaults, and descriptions</p></li>
</ul>
</section>
<section id="scenario-nested-model-validation-for-http-configuration">
<h4>Scenario: Nested model validation for HTTP configuration<a class="headerlink" href="#scenario-nested-model-validation-for-http-configuration" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> sources.yaml contains defaults.http section with nested fields</p></li>
<li><p><strong>THEN</strong> Pydantic parses into nested DownloadConfiguration model with independent field validation</p></li>
</ul>
</section>
</section>
<section id="requirement-per-service-rate-limiting">
<h3>Requirement: Per-Service Rate Limiting<a class="headerlink" href="#requirement-per-service-rate-limiting" title="Link to this heading"></a></h3>
<p>The system SHALL enforce rate limits per service identifier (obo, ols, bioportal) in addition to per-host limits to prevent service-specific throttling.</p>
<section id="scenario-apply-service-specific-rate-limit-for-ols">
<h4>Scenario: Apply service-specific rate limit for OLS<a class="headerlink" href="#scenario-apply-service-specific-rate-limit-for-ols" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> downloading from OLS API with rate_limits.ols=”5/second” configured</p></li>
<li><p><strong>THEN</strong> token bucket enforces 5 requests per second for all OLS API calls regardless of host</p></li>
</ul>
</section>
<section id="scenario-apply-service-specific-rate-limit-for-bioportal">
<h4>Scenario: Apply service-specific rate limit for BioPortal<a class="headerlink" href="#scenario-apply-service-specific-rate-limit-for-bioportal" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> downloading from BioPortal with rate_limits.bioportal=”1/second” configured</p></li>
<li><p><strong>THEN</strong> token bucket enforces 1 request per second for all BioPortal API calls</p></li>
</ul>
</section>
<section id="scenario-fall-back-to-per-host-limit-when-service-not-configured">
<h4>Scenario: Fall back to per-host limit when service not configured<a class="headerlink" href="#scenario-fall-back-to-per-host-limit-when-service-not-configured" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> downloading from service without specific rate_limits entry</p></li>
<li><p><strong>THEN</strong> token bucket uses per_host_rate_limit default of 4 requests per second</p></li>
</ul>
</section>
<section id="scenario-independent-buckets-for-different-services-on-same-host">
<h4>Scenario: Independent buckets for different services on same host<a class="headerlink" href="#scenario-independent-buckets-for-different-services-on-same-host" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> OLS and BioPortal both resolve to same host but have different service rate limits</p></li>
<li><p><strong>THEN</strong> system maintains separate token buckets with keys “ols:host” and “bioportal:host”</p></li>
</ul>
</section>
<section id="scenario-parse-rate-limit-with-per-minute-unit">
<h4>Scenario: Parse rate limit with per-minute unit<a class="headerlink" href="#scenario-parse-rate-limit-with-per-minute-unit" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> rate_limits.ols=”60/min” is configured</p></li>
<li><p><strong>THEN</strong> rate limit parser converts to 1.0 requests per second for token bucket</p></li>
</ul>
</section>
<section id="scenario-parse-rate-limit-with-per-hour-unit">
<h4>Scenario: Parse rate limit with per-hour unit<a class="headerlink" href="#scenario-parse-rate-limit-with-per-hour-unit" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> rate_limits.bioportal=”100/hour” is configured</p></li>
<li><p><strong>THEN</strong> rate limit parser converts to approximately 0.0278 requests per second</p></li>
</ul>
</section>
</section>
<section id="requirement-head-request-with-media-type-validation">
<h3>Requirement: HEAD Request with Media Type Validation<a class="headerlink" href="#requirement-head-request-with-media-type-validation" title="Link to this heading"></a></h3>
<p>The system SHALL perform preliminary HEAD request before GET to validate Content-Type and Content-Length against plan expectations.</p>
<section id="scenario-head-request-confirms-media-type-matches-plan">
<h4>Scenario: HEAD request confirms media type matches plan<a class="headerlink" href="#scenario-head-request-confirms-media-type-matches-plan" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> FetchPlan specifies media_type=”application/rdf+xml” and HEAD response returns Content-Type “application/rdf+xml”</p></li>
<li><p><strong>THEN</strong> system proceeds with full GET request without warning</p></li>
</ul>
</section>
<section id="scenario-head-request-detects-media-type-mismatch">
<h4>Scenario: HEAD request detects media type mismatch<a class="headerlink" href="#scenario-head-request-detects-media-type-mismatch" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> FetchPlan specifies media_type=”application/rdf+xml” but HEAD response returns Content-Type “text/html”</p></li>
<li><p><strong>THEN</strong> system logs warning “Expected media type application/rdf+xml but received text/html” and proceeds with GET if override enabled</p></li>
</ul>
</section>
<section id="scenario-head-request-retrieves-content-length-early">
<h4>Scenario: HEAD request retrieves Content-Length early<a class="headerlink" href="#scenario-head-request-retrieves-content-length-early" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> HEAD request returns Content-Length: 6442450944 (6GB)</p></li>
<li><p><strong>THEN</strong> system detects file exceeds max_download_size_gb=5 and aborts before full GET request</p></li>
</ul>
</section>
<section id="scenario-head-request-failure-does-not-block-download">
<h4>Scenario: HEAD request failure does not block download<a class="headerlink" href="#scenario-head-request-failure-does-not-block-download" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> HEAD request times out or returns 405 Method Not Allowed</p></li>
<li><p><strong>THEN</strong> system logs warning and proceeds with GET request without HEAD validation</p></li>
</ul>
</section>
<section id="scenario-configuration-flag-disables-media-type-validation">
<h4>Scenario: Configuration flag disables media type validation<a class="headerlink" href="#scenario-configuration-flag-disables-media-type-validation" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> config contains http.validate_media_type=false</p></li>
<li><p><strong>THEN</strong> system skips HEAD request media type check and proceeds directly to GET</p></li>
</ul>
</section>
</section>
<section id="requirement-hardened-url-validation-with-host-allowlist-and-idn-support">
<h3>Requirement: Hardened URL Validation with Host Allowlist and IDN Support<a class="headerlink" href="#requirement-hardened-url-validation-with-host-allowlist-and-idn-support" title="Link to this heading"></a></h3>
<p>The system SHALL validate URLs against optional host allowlist and normalize Internationalized Domain Names to prevent SSRF attacks in multi-tenant scenarios.</p>
<section id="scenario-punycode-normalization-for-idn-domain">
<h4>Scenario: Punycode normalization for IDN domain<a class="headerlink" href="#scenario-punycode-normalization-for-idn-domain" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> resolver returns URL with IDN host “münchen.example.org”</p></li>
<li><p><strong>THEN</strong> validate_url_security normalizes to punycode “xn–mnchen-3ya.example.org” before DNS resolution</p></li>
</ul>
</section>
<section id="scenario-host-allowlist-permits-approved-domain">
<h4>Scenario: Host allowlist permits approved domain<a class="headerlink" href="#scenario-host-allowlist-permits-approved-domain" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> config contains http.allowed_hosts=[“example.org”, “purl.obolibrary.org”] and URL host is “purl.obolibrary.org”</p></li>
<li><p><strong>THEN</strong> validate_url_security accepts URL and proceeds with download</p></li>
</ul>
</section>
<section id="scenario-host-allowlist-rejects-unapproved-domain">
<h4>Scenario: Host allowlist rejects unapproved domain<a class="headerlink" href="#scenario-host-allowlist-rejects-unapproved-domain" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> config contains http.allowed_hosts=[“example.org”] and URL host is “malicious.com”</p></li>
<li><p><strong>THEN</strong> validate_url_security raises ConfigError “Host malicious.com not in allowlist”</p></li>
</ul>
</section>
<section id="scenario-no-allowlist-allows-any-non-private-host">
<h4>Scenario: No allowlist allows any non-private host<a class="headerlink" href="#scenario-no-allowlist-allows-any-non-private-host" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> config does not specify http.allowed_hosts</p></li>
<li><p><strong>THEN</strong> validate_url_security accepts any HTTPS URL that resolves to public IP address</p></li>
</ul>
</section>
<section id="scenario-idn-normalization-prevents-homograph-attack">
<h4>Scenario: IDN normalization prevents homograph attack<a class="headerlink" href="#scenario-idn-normalization-prevents-homograph-attack" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> resolver returns URL with visually similar but different Unicode domain</p></li>
<li><p><strong>THEN</strong> punycode normalization detects and rejects suspicious patterns</p></li>
</ul>
</section>
</section>
<section id="requirement-safe-tar-archive-extraction">
<h3>Requirement: Safe Tar Archive Extraction<a class="headerlink" href="#requirement-safe-tar-archive-extraction" title="Link to this heading"></a></h3>
<p>The system SHALL safely extract tar.gz and tar.xz archives with path validation to prevent tar-slip attacks and compression bomb detection.</p>
<section id="scenario-extract-tar-gz-with-valid-paths">
<h4>Scenario: Extract tar.gz with valid paths<a class="headerlink" href="#scenario-extract-tar-gz-with-valid-paths" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> tar.gz archive contains members with paths “schemas/core.xsd” and “taxonomies/base.xml”</p></li>
<li><p><strong>THEN</strong> extract_tar_safe extracts files to destination/schemas/core.xsd and destination/taxonomies/base.xml</p></li>
</ul>
</section>
<section id="scenario-reject-tar-member-with-path-traversal">
<h4>Scenario: Reject tar member with path traversal<a class="headerlink" href="#scenario-reject-tar-member-with-path-traversal" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> tar.gz archive contains member with path “../../etc/shadow”</p></li>
<li><p><strong>THEN</strong> extract_tar_safe detects traversal, raises ConfigError, and aborts extraction</p></li>
</ul>
</section>
<section id="scenario-detect-tar-compression-bomb">
<h4>Scenario: Detect tar compression bomb<a class="headerlink" href="#scenario-detect-tar-compression-bomb" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> tar.gz archive has compressed size 1MB but uncompressed size 10GB (ratio &gt;10:1)</p></li>
<li><p><strong>THEN</strong> extract_tar_safe detects potential bomb, logs error, and aborts extraction</p></li>
</ul>
</section>
<section id="scenario-extract-tar-xz-with-valid-paths">
<h4>Scenario: Extract tar.xz with valid paths<a class="headerlink" href="#scenario-extract-tar-xz-with-valid-paths" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> tar.xz archive contains taxonomy files</p></li>
<li><p><strong>THEN</strong> extract_tar_safe handles xz compression and extracts safely with same path validation as tar.gz</p></li>
</ul>
</section>
<section id="scenario-handle-absolute-paths-in-tar-members">
<h4>Scenario: Handle absolute paths in tar members<a class="headerlink" href="#scenario-handle-absolute-paths-in-tar-members" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> tar.gz contains member with absolute path “/tmp/file.xml”</p></li>
<li><p><strong>THEN</strong> extract_tar_safe detects absolute path, rejects it, and aborts extraction</p></li>
</ul>
</section>
</section>
<section id="requirement-deterministic-ttl-normalization-with-canonical-hashing">
<h3>Requirement: Deterministic TTL Normalization with Canonical Hashing<a class="headerlink" href="#requirement-deterministic-ttl-normalization-with-canonical-hashing" title="Link to this heading"></a></h3>
<p>The system SHALL canonicalize Turtle output by sorting prefixes and triples before serialization and compute stable hash of canonical form.</p>
<section id="scenario-sort-prefixes-alphabetically">
<h4>Scenario: Sort prefixes alphabetically<a class="headerlink" href="#scenario-sort-prefixes-alphabetically" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> RDFLib graph contains prefixes &#64;prefix rdf, &#64;prefix owl, &#64;prefix rdfs in arbitrary order</p></li>
<li><p><strong>THEN</strong> canonicalize_ttl sorts to &#64;prefix owl, &#64;prefix rdf, &#64;prefix rdfs in output</p></li>
</ul>
</section>
<section id="scenario-sort-triples-by-subject-predicate-object">
<h4>Scenario: Sort triples by subject, predicate, object<a class="headerlink" href="#scenario-sort-triples-by-subject-predicate-object" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> RDFLib graph contains triples in arbitrary insertion order</p></li>
<li><p><strong>THEN</strong> canonicalize_ttl sorts triples lexicographically by (subject, predicate, object) tuple</p></li>
</ul>
</section>
<section id="scenario-compute-stable-hash-of-canonical-ttl">
<h4>Scenario: Compute stable hash of canonical TTL<a class="headerlink" href="#scenario-compute-stable-hash-of-canonical-ttl" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> same ontology is downloaded twice and canonicalized</p></li>
<li><p><strong>THEN</strong> SHA-256 hash of canonical TTL is identical both times</p></li>
</ul>
</section>
<section id="scenario-different-parse-orders-yield-same-normalized-hash">
<h4>Scenario: Different parse orders yield same normalized hash<a class="headerlink" href="#scenario-different-parse-orders-yield-same-normalized-hash" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> same ontology is parsed with different RDF parsers producing different triple orders</p></li>
<li><p><strong>THEN</strong> canonicalize_ttl produces identical normalized output and hash</p></li>
</ul>
</section>
<section id="scenario-store-normalized-hash-in-manifest">
<h4>Scenario: Store normalized hash in manifest<a class="headerlink" href="#scenario-store-normalized-hash-in-manifest" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> validation completes and normalized TTL is written</p></li>
<li><p><strong>THEN</strong> manifest.json includes normalized_sha256 field with canonical hash</p></li>
</ul>
</section>
</section>
<section id="requirement-subprocess-isolation-for-memory-intensive-validators">
<h3>Requirement: Subprocess Isolation for Memory-Intensive Validators<a class="headerlink" href="#requirement-subprocess-isolation-for-memory-intensive-validators" title="Link to this heading"></a></h3>
<p>The system SHALL execute pronto and owlready2 validators in short-lived subprocesses to prevent memory fragmentation in long-running batch operations.</p>
<section id="scenario-execute-pronto-validation-in-subprocess">
<h4>Scenario: Execute pronto validation in subprocess<a class="headerlink" href="#scenario-execute-pronto-validation-in-subprocess" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> validate_pronto is called with large OBO file</p></li>
<li><p><strong>THEN</strong> system spawns subprocess with Python interpreter, executes pronto parsing, writes results to JSON, and subprocess terminates</p></li>
</ul>
</section>
<section id="scenario-read-validation-results-from-subprocess">
<h4>Scenario: Read validation results from subprocess<a class="headerlink" href="#scenario-read-validation-results-from-subprocess" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> pronto subprocess completes successfully and writes validation/pronto_result.json</p></li>
<li><p><strong>THEN</strong> parent process reads JSON, parses results, and returns ValidationResult</p></li>
</ul>
</section>
<section id="scenario-subprocess-timeout-enforcement">
<h4>Scenario: Subprocess timeout enforcement<a class="headerlink" href="#scenario-subprocess-timeout-enforcement" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> pronto subprocess exceeds parser_timeout_sec=60 configuration</p></li>
<li><p><strong>THEN</strong> parent process terminates subprocess and records timeout in ValidationResult</p></li>
</ul>
</section>
<section id="scenario-execute-owlready2-validation-in-subprocess">
<h4>Scenario: Execute owlready2 validation in subprocess<a class="headerlink" href="#scenario-execute-owlready2-validation-in-subprocess" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> validate_owlready2 is called with OWL file</p></li>
<li><p><strong>THEN</strong> system spawns subprocess for owlready2 loading, captures entity counts, and terminates subprocess</p></li>
</ul>
</section>
<section id="scenario-memory-isolation-prevents-parent-process-leak">
<h4>Scenario: Memory isolation prevents parent process leak<a class="headerlink" href="#scenario-memory-isolation-prevents-parent-process-leak" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> batch pull processes 100 ontologies with pronto validation</p></li>
<li><p><strong>THEN</strong> parent process memory usage remains stable because each subprocess releases memory on termination</p></li>
</ul>
</section>
<section id="scenario-subprocess-error-captured-and-logged">
<h4>Scenario: Subprocess error captured and logged<a class="headerlink" href="#scenario-subprocess-error-captured-and-logged" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> pronto subprocess raises exception and exits with non-zero code</p></li>
<li><p><strong>THEN</strong> parent process captures stderr, logs error, and returns ValidationResult with ok=false</p></li>
</ul>
</section>
</section>
<section id="requirement-spdx-license-normalization">
<h3>Requirement: SPDX License Normalization<a class="headerlink" href="#requirement-spdx-license-normalization" title="Link to this heading"></a></h3>
<p>The system SHALL normalize resolver-reported licenses to SPDX identifiers before enforcing allowlist to handle common variants and aliases.</p>
<section id="scenario-normalize-cc-by-variant-to-spdx">
<h4>Scenario: Normalize CC-BY variant to SPDX<a class="headerlink" href="#scenario-normalize-cc-by-variant-to-spdx" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> resolver reports license=”CC-BY” or “CC BY 4.0”</p></li>
<li><p><strong>THEN</strong> normalize_license_to_spdx returns “CC-BY-4.0”</p></li>
</ul>
</section>
<section id="scenario-normalize-cc0-variant-to-spdx">
<h4>Scenario: Normalize CC0 variant to SPDX<a class="headerlink" href="#scenario-normalize-cc0-variant-to-spdx" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> resolver reports license=”CC0” or “Public Domain”</p></li>
<li><p><strong>THEN</strong> normalize_license_to_spdx returns “CC0-1.0”</p></li>
</ul>
</section>
<section id="scenario-normalize-apache-variants-to-spdx">
<h4>Scenario: Normalize Apache variants to SPDX<a class="headerlink" href="#scenario-normalize-apache-variants-to-spdx" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> resolver reports license=”Apache” or “Apache License 2.0”</p></li>
<li><p><strong>THEN</strong> normalize_license_to_spdx returns “Apache-2.0”</p></li>
</ul>
</section>
<section id="scenario-compare-normalized-licenses-against-allowlist">
<h4>Scenario: Compare normalized licenses against allowlist<a class="headerlink" href="#scenario-compare-normalized-licenses-against-allowlist" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> accept_licenses=[“CC-BY-4.0”] and resolver reports “CC BY 4.0”</p></li>
<li><p><strong>THEN</strong> _ensure_license_allowed normalizes to “CC-BY-4.0”, finds match in allowlist, and allows download</p></li>
</ul>
</section>
<section id="scenario-unknown-license-returns-original-string">
<h4>Scenario: Unknown license returns original string<a class="headerlink" href="#scenario-unknown-license-returns-original-string" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> resolver reports license=”Proprietary Custom License v1”</p></li>
<li><p><strong>THEN</strong> normalize_license_to_spdx returns original string unchanged for allowlist comparison</p></li>
</ul>
</section>
</section>
<section id="requirement-automatic-multi-resolver-fallback">
<h3>Requirement: Automatic Multi-Resolver Fallback<a class="headerlink" href="#requirement-automatic-multi-resolver-fallback" title="Link to this heading"></a></h3>
<p>The system SHALL automatically try resolvers in prefer_source order when a resolver fails, increasing download success rates without configuration changes.</p>
<section id="scenario-first-resolver-succeeds-without-fallback">
<h4>Scenario: First resolver succeeds without fallback<a class="headerlink" href="#scenario-first-resolver-succeeds-without-fallback" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> FetchSpec uses resolver=”obo” and OBOResolver successfully returns FetchPlan</p></li>
<li><p><strong>THEN</strong> no fallback is attempted and FetchPlan is used for download</p></li>
</ul>
</section>
<section id="scenario-first-resolver-fails-fallback-to-second">
<h4>Scenario: First resolver fails, fallback to second<a class="headerlink" href="#scenario-first-resolver-fails-fallback-to-second" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> prefer_source=[“obo”, “ols”, “bioportal”], OBOResolver raises ResolverError “No download URL found”</p></li>
<li><p><strong>THEN</strong> FallbackResolver logs “OBOResolver failed, trying OLSResolver” and attempts OLS resolution</p></li>
</ul>
</section>
<section id="scenario-second-resolver-succeeds">
<h4>Scenario: Second resolver succeeds<a class="headerlink" href="#scenario-second-resolver-succeeds" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> OBOResolver fails and OLSResolver returns valid FetchPlan</p></li>
<li><p><strong>THEN</strong> FallbackResolver returns OLS FetchPlan and fetch proceeds with OLS source</p></li>
</ul>
</section>
<section id="scenario-all-resolvers-exhausted">
<h4>Scenario: All resolvers exhausted<a class="headerlink" href="#scenario-all-resolvers-exhausted" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> prefer_source=[“obo”, “ols”, “bioportal”] and all three resolvers raise errors</p></li>
<li><p><strong>THEN</strong> FallbackResolver logs all attempts and raises ResolverError “All resolvers exhausted for ontology <id>”</p></li>
</ul>
</section>
<section id="scenario-log-fallback-sequence-for-observability">
<h4>Scenario: Log fallback sequence for observability<a class="headerlink" href="#scenario-log-fallback-sequence-for-observability" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> fallback occurs through multiple resolvers</p></li>
<li><p><strong>THEN</strong> each attempt is logged with fields: resolver_name, attempt_number, outcome, error_message</p></li>
</ul>
</section>
<section id="scenario-configuration-flag-disables-fallback">
<h4>Scenario: Configuration flag disables fallback<a class="headerlink" href="#scenario-configuration-flag-disables-fallback" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> config contains resolver_fallback_enabled=false</p></li>
<li><p><strong>THEN</strong> system uses only the specified resolver without fallback attempts</p></li>
</ul>
</section>
</section>
<section id="requirement-polite-api-headers-for-resolver-requests">
<h3>Requirement: Polite API Headers for Resolver Requests<a class="headerlink" href="#requirement-polite-api-headers-for-resolver-requests" title="Link to this heading"></a></h3>
<p>The system SHALL include polite HTTP headers (User-Agent, From, X-Request-ID) in resolver API requests to reduce throttling and improve reproducibility.</p>
<section id="scenario-include-user-agent-in-ols-api-request">
<h4>Scenario: Include User-Agent in OLS API request<a class="headerlink" href="#scenario-include-user-agent-in-ols-api-request" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> OLSResolver queries OLS API for ontology metadata</p></li>
<li><p><strong>THEN</strong> request includes User-Agent: “DocsToKG-OntologyDownloader/1.0 (<a class="reference external" href="mailto:contact&#37;&#52;&#48;example&#46;org">contact<span>&#64;</span>example<span>&#46;</span>org</a>)”</p></li>
</ul>
</section>
<section id="scenario-include-from-header-in-bioportal-api-request">
<h4>Scenario: Include From header in BioPortal API request<a class="headerlink" href="#scenario-include-from-header-in-bioportal-api-request" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> BioPortalResolver queries BioPortal API</p></li>
<li><p><strong>THEN</strong> request includes From: “<a class="reference external" href="mailto:contact&#37;&#52;&#48;example&#46;org">contact<span>&#64;</span>example<span>&#46;</span>org</a>” header from polite_headers config</p></li>
</ul>
</section>
<section id="scenario-include-x-request-id-for-request-tracing">
<h4>Scenario: Include X-Request-ID for request tracing<a class="headerlink" href="#scenario-include-x-request-id-for-request-tracing" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> any resolver makes API request</p></li>
<li><p><strong>THEN</strong> request includes X-Request-ID: “&lt;correlation_id&gt;-<timestamp>” for distributed tracing</p></li>
</ul>
</section>
<section id="scenario-configure-polite-headers-in-defaults">
<h4>Scenario: Configure polite headers in defaults<a class="headerlink" href="#scenario-configure-polite-headers-in-defaults" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> sources.yaml contains defaults.http.polite_headers with User-Agent and From</p></li>
<li><p><strong>THEN</strong> all resolver API requests use configured headers</p></li>
</ul>
</section>
<section id="scenario-default-polite-headers-when-not-configured">
<h4>Scenario: Default polite headers when not configured<a class="headerlink" href="#scenario-default-polite-headers-when-not-configured" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> sources.yaml omits polite_headers section</p></li>
<li><p><strong>THEN</strong> system uses default headers with generic User-Agent and no From header</p></li>
</ul>
</section>
</section>
<section id="requirement-linked-open-vocabularies-lov-resolver">
<h3>Requirement: Linked Open Vocabularies (LOV) Resolver<a class="headerlink" href="#requirement-linked-open-vocabularies-lov-resolver" title="Link to this heading"></a></h3>
<p>The system SHALL provide LOVResolver for fetching SKOS vocabularies and RDF schemas from Linked Open Vocabularies repository.</p>
<section id="scenario-resolve-vocabulary-from-lov-by-uri">
<h4>Scenario: Resolve vocabulary from LOV by URI<a class="headerlink" href="#scenario-resolve-vocabulary-from-lov-by-uri" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> FetchSpec has resolver=”lov” and extras.uri=”<a class="reference external" href="http://purl.org/vocommons/voaf">http://purl.org/vocommons/voaf</a>”</p></li>
<li><p><strong>THEN</strong> LOVResolver queries LOV API, retrieves vocabulary metadata, and returns FetchPlan with Turtle download URL</p></li>
</ul>
</section>
<section id="scenario-lov-resolver-sets-appropriate-media-type">
<h4>Scenario: LOV resolver sets appropriate media type<a class="headerlink" href="#scenario-lov-resolver-sets-appropriate-media-type" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> LOVResolver constructs FetchPlan for SKOS vocabulary</p></li>
<li><p><strong>THEN</strong> FetchPlan includes media_type=”text/turtle” for content negotiation</p></li>
</ul>
</section>
<section id="scenario-lov-api-unavailable-fallback">
<h4>Scenario: LOV API unavailable fallback<a class="headerlink" href="#scenario-lov-api-unavailable-fallback" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> LOV API returns HTTP 503 Service Unavailable</p></li>
<li><p><strong>THEN</strong> LOVResolver raises ResolverError allowing fallback to other resolvers</p></li>
</ul>
</section>
<section id="scenario-lov-vocabulary-metadata-included-in-plan">
<h4>Scenario: LOV vocabulary metadata included in plan<a class="headerlink" href="#scenario-lov-vocabulary-metadata-included-in-plan" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> LOV API returns vocabulary version and license</p></li>
<li><p><strong>THEN</strong> FetchPlan includes version and license fields for provenance</p></li>
</ul>
</section>
</section>
<section id="requirement-ontobee-purl-resolver">
<h3>Requirement: Ontobee PURL Resolver<a class="headerlink" href="#requirement-ontobee-purl-resolver" title="Link to this heading"></a></h3>
<p>The system SHALL provide OntobeeResolver for constructing PURLs for OBO Foundry ontologies when primary resolvers are unavailable.</p>
<section id="scenario-construct-ontobee-purl-for-obo-ontology">
<h4>Scenario: Construct Ontobee PURL for OBO ontology<a class="headerlink" href="#scenario-construct-ontobee-purl-for-obo-ontology" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> FetchSpec has resolver=”ontobee” and id=”hp”</p></li>
<li><p><strong>THEN</strong> OntobeeResolver returns FetchPlan with url=”<a class="reference external" href="http://purl.obolibrary.org/obo/hp.owl">http://purl.obolibrary.org/obo/hp.owl</a>”</p></li>
</ul>
</section>
<section id="scenario-support-multiple-obo-format-variants">
<h4>Scenario: Support multiple OBO format variants<a class="headerlink" href="#scenario-support-multiple-obo-format-variants" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> FetchSpec has target_formats=[“obo”, “owl”] preference</p></li>
<li><p><strong>THEN</strong> OntobeeResolver constructs PURL for preferred format (hp.obo or hp.owl)</p></li>
</ul>
</section>
<section id="scenario-ontobee-as-fallback-resolver">
<h4>Scenario: Ontobee as fallback resolver<a class="headerlink" href="#scenario-ontobee-as-fallback-resolver" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> prefer_source=[“obo”, “ols”, “ontobee”] and OBO/OLS fail</p></li>
<li><p><strong>THEN</strong> fallback tries Ontobee PURL as last resort</p></li>
</ul>
</section>
<section id="scenario-ontobee-purl-format-validation">
<h4>Scenario: Ontobee PURL format validation<a class="headerlink" href="#scenario-ontobee-purl-format-validation" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> Ontobee constructs PURL for ontology id</p></li>
<li><p><strong>THEN</strong> resolver validates id format matches OBO prefix pattern before returning FetchPlan</p></li>
</ul>
</section>
</section>
<section id="requirement-remote-storage-backend-via-fsspec">
<h3>Requirement: Remote Storage Backend via fsspec<a class="headerlink" href="#requirement-remote-storage-backend-via-fsspec" title="Link to this heading"></a></h3>
<p>The system SHALL support remote storage backends (S3, GCS, Azure, HTTP) via fsspec when ONTOFETCH_STORAGE_URL environment variable is set.</p>
<section id="scenario-use-local-storage-when-no-storage-url-configured">
<h4>Scenario: Use local storage when no storage URL configured<a class="headerlink" href="#scenario-use-local-storage-when-no-storage-url-configured" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> ONTOFETCH_STORAGE_URL environment variable is not set</p></li>
<li><p><strong>THEN</strong> system uses LocalStorageBackend with pystow-based paths</p></li>
</ul>
</section>
<section id="scenario-use-s3-storage-when-s3-url-configured">
<h4>Scenario: Use S3 storage when S3 URL configured<a class="headerlink" href="#scenario-use-s3-storage-when-s3-url-configured" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> ONTOFETCH_STORAGE_URL=”s3://my-bucket/ontologies” is set</p></li>
<li><p><strong>THEN</strong> system uses FsspecStorageBackend with s3fs filesystem for manifest and artifact operations</p></li>
</ul>
</section>
<section id="scenario-read-manifest-from-remote-storage">
<h4>Scenario: Read manifest from remote storage<a class="headerlink" href="#scenario-read-manifest-from-remote-storage" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> using S3 storage and previous manifest exists</p></li>
<li><p><strong>THEN</strong> storage backend reads manifest.json from s3://my-bucket/ontologies/<id>/<version>/manifest.json</p></li>
</ul>
</section>
<section id="scenario-write-artifacts-to-remote-storage">
<h4>Scenario: Write artifacts to remote storage<a class="headerlink" href="#scenario-write-artifacts-to-remote-storage" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> download completes and using remote storage</p></li>
<li><p><strong>THEN</strong> storage backend writes downloaded file to s3://my-bucket/ontologies/<id>/<version>/original/<filename></p></li>
</ul>
</section>
<section id="scenario-missing-fsspec-dependency-with-storage-url">
<h4>Scenario: Missing fsspec dependency with storage URL<a class="headerlink" href="#scenario-missing-fsspec-dependency-with-storage-url" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> ONTOFETCH_STORAGE_URL is set but fsspec not installed</p></li>
<li><p><strong>THEN</strong> system raises ConfigError “fsspec required for remote storage. Install: pip install fsspec s3fs”</p></li>
</ul>
</section>
<section id="scenario-cache-directory-remains-local-with-remote-storage">
<h4>Scenario: Cache directory remains local with remote storage<a class="headerlink" href="#scenario-cache-directory-remains-local-with-remote-storage" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> using remote storage for ontologies</p></li>
<li><p><strong>THEN</strong> pooch cache directory remains local for download performance, only final artifacts stored remotely</p></li>
</ul>
</section>
</section>
<section id="requirement-cli-plan-command-for-download-preview">
<h3>Requirement: CLI Plan Command for Download Preview<a class="headerlink" href="#requirement-cli-plan-command-for-download-preview" title="Link to this heading"></a></h3>
<p>The system SHALL provide <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">plan</span></code> subcommand to preview FetchPlan without executing download for workflow development and debugging.</p>
<section id="scenario-plan-command-resolves-and-displays-fetchplan">
<h4>Scenario: Plan command resolves and displays FetchPlan<a class="headerlink" href="#scenario-plan-command-resolves-and-displays-fetchplan" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">plan</span> <span class="pre">hp</span> <span class="pre">--resolver</span> <span class="pre">obo</span></code></p></li>
<li><p><strong>THEN</strong> CLI resolves FetchPlan for HP ontology and prints JSON with url, headers, version, license, media_type fields</p></li>
</ul>
</section>
<section id="scenario-plan-command-with-human-readable-output">
<h4>Scenario: Plan command with human-readable output<a class="headerlink" href="#scenario-plan-command-with-human-readable-output" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">plan</span> <span class="pre">hp</span></code> without –json flag</p></li>
<li><p><strong>THEN</strong> CLI displays FetchPlan fields in formatted table with field names and values</p></li>
</ul>
</section>
<section id="scenario-plan-command-respects-resolver-fallback">
<h4>Scenario: Plan command respects resolver fallback<a class="headerlink" href="#scenario-plan-command-respects-resolver-fallback" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">plan</span> <span class="pre">hp</span></code> with prefer_source=[“obo”, “ols”] and OBO fails</p></li>
<li><p><strong>THEN</strong> plan command attempts fallback and displays which resolver succeeded</p></li>
</ul>
</section>
<section id="scenario-plan-command-shows-headers-for-debugging">
<h4>Scenario: Plan command shows headers for debugging<a class="headerlink" href="#scenario-plan-command-shows-headers-for-debugging" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> FetchPlan includes Authorization or other headers</p></li>
<li><p><strong>THEN</strong> plan output masks sensitive values but shows header presence for debugging</p></li>
</ul>
</section>
<section id="scenario-plan-command-fails-on-resolver-error">
<h4>Scenario: Plan command fails on resolver error<a class="headerlink" href="#scenario-plan-command-fails-on-resolver-error" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> all resolvers fail for requested ontology</p></li>
<li><p><strong>THEN</strong> plan command exits with code 1 and displays resolver errors</p></li>
</ul>
</section>
</section>
<section id="requirement-cli-doctor-command-for-environment-diagnostics">
<h3>Requirement: CLI Doctor Command for Environment Diagnostics<a class="headerlink" href="#requirement-cli-doctor-command-for-environment-diagnostics" title="Link to this heading"></a></h3>
<p>The system SHALL provide <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">doctor</span></code> subcommand to diagnose environment issues and provide actionable remediation guidance.</p>
<section id="scenario-doctor-checks-filesystem-permissions">
<h4>Scenario: Doctor checks filesystem permissions<a class="headerlink" href="#scenario-doctor-checks-filesystem-permissions" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">doctor</span></code></p></li>
<li><p><strong>THEN</strong> command checks write permissions for data directories (configs, cache, logs, ontologies) and reports status</p></li>
</ul>
</section>
<section id="scenario-doctor-checks-bioportal-api-key">
<h4>Scenario: Doctor checks BioPortal API key<a class="headerlink" href="#scenario-doctor-checks-bioportal-api-key" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> doctor runs and BioPortal API key file exists at expected location</p></li>
<li><p><strong>THEN</strong> command reports “BioPortal API key: configured at <path>” and validates key format</p></li>
</ul>
</section>
<section id="scenario-doctor-checks-ols-api-accessibility">
<h4>Scenario: Doctor checks OLS API accessibility<a class="headerlink" href="#scenario-doctor-checks-ols-api-accessibility" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> doctor runs and attempts to connect to OLS API</p></li>
<li><p><strong>THEN</strong> command reports “OLS API: accessible” or “OLS API: unreachable” with HTTP status</p></li>
</ul>
</section>
<section id="scenario-doctor-checks-disk-space">
<h4>Scenario: Doctor checks disk space<a class="headerlink" href="#scenario-doctor-checks-disk-space" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> doctor runs and queries available disk space</p></li>
<li><p><strong>THEN</strong> command reports free space in data directory and warns if &lt;5GB available</p></li>
</ul>
</section>
<section id="scenario-doctor-provides-remediation-hints">
<h4>Scenario: Doctor provides remediation hints<a class="headerlink" href="#scenario-doctor-provides-remediation-hints" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> doctor detects missing API key</p></li>
<li><p><strong>THEN</strong> output includes “To configure: echo ‘YOUR_API_KEY’ &gt; <path>/bioportal_api_key.txt”</p></li>
</ul>
</section>
<section id="scenario-doctor-checks-optional-dependencies">
<h4>Scenario: Doctor checks optional dependencies<a class="headerlink" href="#scenario-doctor-checks-optional-dependencies" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> doctor runs and checks for rdflib, pronto, owlready2, robot installations</p></li>
<li><p><strong>THEN</strong> command reports which validators are available and which require installation</p></li>
</ul>
</section>
<section id="scenario-doctor-json-output-for-automation">
<h4>Scenario: Doctor JSON output for automation<a class="headerlink" href="#scenario-doctor-json-output-for-automation" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">doctor</span> <span class="pre">--json</span></code></p></li>
<li><p><strong>THEN</strong> command outputs diagnostic results as JSON with boolean status fields for scripting</p></li>
</ul>
</section>
</section>
<section id="requirement-cli-dry-run-mode-for-pull-command">
<h3>Requirement: CLI Dry-Run Mode for Pull Command<a class="headerlink" href="#requirement-cli-dry-run-mode-for-pull-command" title="Link to this heading"></a></h3>
<p>The system SHALL provide <code class="docutils literal notranslate"><span class="pre">--dry-run</span></code> flag for pull subcommand to preview planned actions without executing downloads or validation.</p>
<section id="scenario-dry-run-logs-planned-downloads">
<h4>Scenario: Dry-run logs planned downloads<a class="headerlink" href="#scenario-dry-run-logs-planned-downloads" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">pull</span> <span class="pre">--spec</span> <span class="pre">sources.yaml</span> <span class="pre">--dry-run</span></code></p></li>
<li><p><strong>THEN</strong> CLI resolves all FetchPlans, logs planned downloads, and exits without downloading</p></li>
</ul>
</section>
<section id="scenario-dry-run-shows-which-ontologies-would-be-cached">
<h4>Scenario: Dry-run shows which ontologies would be cached<a class="headerlink" href="#scenario-dry-run-shows-which-ontologies-would-be-cached" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">pull</span> <span class="pre">hp</span> <span class="pre">efo</span> <span class="pre">--dry-run</span></code> and previous manifests exist with ETags</p></li>
<li><p><strong>THEN</strong> CLI indicates “hp: would check cache (ETag present)” and “efo: would download (no cache)”</p></li>
</ul>
</section>
<section id="scenario-dry-run-reports-total-planned-download-size">
<h4>Scenario: Dry-run reports total planned download size<a class="headerlink" href="#scenario-dry-run-reports-total-planned-download-size" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> dry-run resolves all FetchPlans with Content-Length available</p></li>
<li><p><strong>THEN</strong> CLI summary shows “Total download size: 1.2 GB (3 ontologies, 2 cached)”</p></li>
</ul>
</section>
<section id="scenario-dry-run-respects-resolver-fallback">
<h4>Scenario: Dry-run respects resolver fallback<a class="headerlink" href="#scenario-dry-run-respects-resolver-fallback" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> dry-run encounters resolver that would fail</p></li>
<li><p><strong>THEN</strong> CLI shows fallback sequence that would be attempted in real run</p></li>
</ul>
</section>
<section id="scenario-dry-run-validates-configuration">
<h4>Scenario: Dry-run validates configuration<a class="headerlink" href="#scenario-dry-run-validates-configuration" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs pull with –dry-run and sources.yaml has validation errors</p></li>
<li><p><strong>THEN</strong> CLI detects errors and reports them without attempting downloads</p></li>
</ul>
</section>
</section>
</section>
<section id="modified-requirements">
<h2>MODIFIED Requirements<a class="headerlink" href="#modified-requirements" title="Link to this heading"></a></h2>
<section id="requirement-declarative-yaml-configuration-with-pydantic-models">
<h3>Requirement: Declarative YAML Configuration with Pydantic Models<a class="headerlink" href="#requirement-declarative-yaml-configuration-with-pydantic-models" title="Link to this heading"></a></h3>
<p>The system SHALL support configuration via sources.yaml with Pydantic v2 models providing validation, defaults, environment variable merging, and JSON Schema generation.</p>
<section id="scenario-parse-defaults-section-with-pydantic-validation">
<h4>Scenario: Parse defaults section with Pydantic validation<a class="headerlink" href="#scenario-parse-defaults-section-with-pydantic-validation" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> sources.yaml contains defaults.accept_licenses=[“CC-BY-4.0”, “CC0-1.0”]</p></li>
<li><p><strong>THEN</strong> Pydantic DefaultsConfig model parses licenses into validated list with type checking</p></li>
</ul>
</section>
<section id="scenario-parse-ontology-list-into-fetchspec-with-pydantic">
<h4>Scenario: Parse ontology list into FetchSpec with Pydantic<a class="headerlink" href="#scenario-parse-ontology-list-into-fetchspec-with-pydantic" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> sources.yaml contains ontologies list with id, resolver, target_formats per entry</p></li>
<li><p><strong>THEN</strong> Pydantic parser creates validated FetchSpec objects with merged defaults</p></li>
</ul>
</section>
<section id="scenario-pydantic-field-validation-catches-configuration-errors">
<h4>Scenario: Pydantic field validation catches configuration errors<a class="headerlink" href="#scenario-pydantic-field-validation-catches-configuration-errors" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> sources.yaml contains defaults.http.timeout_sec=-10 (invalid negative)</p></li>
<li><p><strong>THEN</strong> Pydantic raises ValidationError with message “timeout_sec must be greater than 0”</p></li>
</ul>
</section>
<section id="scenario-pydantic-provides-clear-error-messages">
<h4>Scenario: Pydantic provides clear error messages<a class="headerlink" href="#scenario-pydantic-provides-clear-error-messages" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> sources.yaml has ontology entry missing required field ‘id’</p></li>
<li><p><strong>THEN</strong> Pydantic error shows “Field required: id at ontologies[2]” with location context</p></li>
</ul>
</section>
<section id="scenario-environment-variables-override-via-pydantic-settings">
<h4>Scenario: Environment variables override via Pydantic settings<a class="headerlink" href="#scenario-environment-variables-override-via-pydantic-settings" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> ONTOFETCH_MAX_RETRIES=10 env var is set and sources.yaml has max_retries=5</p></li>
<li><p><strong>THEN</strong> Pydantic settings merge applies max_retries=10 with priority to environment</p></li>
</ul>
</section>
<section id="id1">
<h4>Scenario: Generate JSON Schema from Pydantic models<a class="headerlink" href="#id1" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> documentation tooling requests configuration schema</p></li>
<li><p><strong>THEN</strong> Pydantic model.model_json_schema() generates complete JSON Schema with all fields, types, constraints, and descriptions</p></li>
</ul>
</section>
<section id="scenario-nested-pydantic-models-for-configuration-sections">
<h4>Scenario: Nested Pydantic models for configuration sections<a class="headerlink" href="#scenario-nested-pydantic-models-for-configuration-sections" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> sources.yaml has defaults.http, defaults.validation, defaults.logging sections</p></li>
<li><p><strong>THEN</strong> Pydantic parses into nested DownloadConfiguration, ValidationConfig, LoggingConfiguration models with independent validation</p></li>
</ul>
</section>
</section>
<section id="requirement-robust-http-download-with-caching-head-validation-and-service-rate-limits">
<h3>Requirement: Robust HTTP Download with Caching, HEAD Validation, and Service Rate Limits<a class="headerlink" href="#requirement-robust-http-download-with-caching-head-validation-and-service-rate-limits" title="Link to this heading"></a></h3>
<p>The system SHALL implement robust HTTP download logic with conditional requests, resume support, checksums, retry, per-service rate limiting, and preliminary HEAD validation using pooch as the underlying cache mechanism.</p>
<section id="scenario-head-request-validates-media-type-before-get">
<h4>Scenario: HEAD request validates media type before GET<a class="headerlink" href="#scenario-head-request-validates-media-type-before-get" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> FetchPlan specifies media_type and http.validate_media_type=true</p></li>
<li><p><strong>THEN</strong> StreamingDownloader issues HEAD request, validates Content-Type matches expected media type before full GET</p></li>
</ul>
</section>
<section id="scenario-head-request-retrieves-content-length-for-early-size-check">
<h4>Scenario: HEAD request retrieves Content-Length for early size check<a class="headerlink" href="#scenario-head-request-retrieves-content-length-for-early-size-check" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> HEAD request returns Content-Length exceeding max_download_size_gb</p></li>
<li><p><strong>THEN</strong> download manager aborts before full GET with error “File size exceeds limit”</p></li>
</ul>
</section>
<section id="scenario-conditional-get-with-etag-returns-304-not-modified">
<h4>Scenario: Conditional GET with ETag returns 304 Not Modified<a class="headerlink" href="#scenario-conditional-get-with-etag-returns-304-not-modified" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> previous manifest exists with ETag and server responds with HTTP 304</p></li>
<li><p><strong>THEN</strong> download manager returns FetchResult with status=’cached’ without re-downloading</p></li>
</ul>
</section>
<section id="scenario-resume-partial-download-with-range-header">
<h4>Scenario: Resume partial download with Range header<a class="headerlink" href="#scenario-resume-partial-download-with-range-header" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> .part file exists from interrupted download and server supports Range requests</p></li>
<li><p><strong>THEN</strong> download manager sends Range header starting from partial file size and appends remaining bytes</p></li>
</ul>
</section>
<section id="scenario-sha-256-verification-after-complete-download">
<h4>Scenario: SHA-256 verification after complete download<a class="headerlink" href="#scenario-sha-256-verification-after-complete-download" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> file download completes successfully</p></li>
<li><p><strong>THEN</strong> download manager computes SHA-256 hash and records it in FetchResult</p></li>
</ul>
</section>
<section id="scenario-exponential-backoff-retry-on-transient-failure">
<h4>Scenario: Exponential backoff retry on transient failure<a class="headerlink" href="#scenario-exponential-backoff-retry-on-transient-failure" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> server responds with HTTP 503 or network timeout occurs</p></li>
<li><p><strong>THEN</strong> download manager retries up to max_retries times with exponential backoff</p></li>
</ul>
</section>
<section id="scenario-per-service-rate-limiting-enforces-configured-limits">
<h4>Scenario: Per-service rate limiting enforces configured limits<a class="headerlink" href="#scenario-per-service-rate-limiting-enforces-configured-limits" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> multiple downloads from OLS service with rate_limits.ols=”5/second”</p></li>
<li><p><strong>THEN</strong> download manager enforces token bucket limit of 5 req/sec for OLS service</p></li>
</ul>
</section>
<section id="scenario-per-host-rate-limiting-as-fallback">
<h4>Scenario: Per-host rate limiting as fallback<a class="headerlink" href="#scenario-per-host-rate-limiting-as-fallback" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> downloading from service without specific rate_limits entry</p></li>
<li><p><strong>THEN</strong> download manager enforces per_host_rate_limit default of 4 req/sec</p></li>
</ul>
</section>
</section>
<section id="requirement-multi-parser-validation-pipeline-with-subprocess-isolation">
<h3>Requirement: Multi-Parser Validation Pipeline with Subprocess Isolation<a class="headerlink" href="#requirement-multi-parser-validation-pipeline-with-subprocess-isolation" title="Link to this heading"></a></h3>
<p>The system SHALL validate downloaded ontologies using multiple parsers with subprocess isolation for memory-intensive validators (pronto, owlready2) and deterministic normalization for RDFLib output.</p>
<section id="scenario-rdflib-parses-and-produces-canonical-turtle">
<h4>Scenario: RDFLib parses and produces canonical Turtle<a class="headerlink" href="#scenario-rdflib-parses-and-produces-canonical-turtle" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> Turtle file is downloaded and RDFLib validation runs</p></li>
<li><p><strong>THEN</strong> validator parses graph, canonicalizes triples and prefixes, computes normalized SHA-256, writes validation/rdflib_parse.json with {“ok”: true, “triples”: N, “normalized_sha256”: “<hash>”}</p></li>
</ul>
</section>
<section id="scenario-pronto-runs-in-subprocess-for-memory-isolation">
<h4>Scenario: Pronto runs in subprocess for memory isolation<a class="headerlink" href="#scenario-pronto-runs-in-subprocess-for-memory-isolation" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> OBO file validation with Pronto is requested</p></li>
<li><p><strong>THEN</strong> validate_pronto spawns subprocess, executes pronto parsing, writes results to validation/pronto_parse.json, subprocess terminates releasing memory</p></li>
</ul>
</section>
<section id="scenario-owlready2-runs-in-subprocess-for-reasoning">
<h4>Scenario: Owlready2 runs in subprocess for reasoning<a class="headerlink" href="#scenario-owlready2-runs-in-subprocess-for-reasoning" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> OWL file validation with Owlready2 is requested and file size &lt; skip_reasoning_if_size_mb</p></li>
<li><p><strong>THEN</strong> validate_owlready2 spawns subprocess, loads ontology, counts entities, writes results, subprocess terminates</p></li>
</ul>
</section>
<section id="scenario-subprocess-timeout-enforced-for-validators">
<h4>Scenario: Subprocess timeout enforced for validators<a class="headerlink" href="#scenario-subprocess-timeout-enforced-for-validators" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> pronto subprocess exceeds parser_timeout_sec configuration</p></li>
<li><p><strong>THEN</strong> parent process terminates subprocess and writes validation result with timeout error</p></li>
</ul>
</section>
<section id="scenario-rdflib-remains-in-process-for-performance">
<h4>Scenario: RDFLib remains in-process for performance<a class="headerlink" href="#scenario-rdflib-remains-in-process-for-performance" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> RDFLib validation runs on typical OWL/Turtle file</p></li>
<li><p><strong>THEN</strong> validation executes in parent process (not subprocess) for fast execution</p></li>
</ul>
</section>
<section id="scenario-robot-integration-skipped-when-not-installed">
<h4>Scenario: ROBOT integration skipped when not installed<a class="headerlink" href="#scenario-robot-integration-skipped-when-not-installed" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> ROBOT validation requested but <code class="docutils literal notranslate"><span class="pre">robot</span></code> command not found via shutil.which()</p></li>
<li><p><strong>THEN</strong> validator logs warning and skips ROBOT steps without failing entire validation</p></li>
</ul>
</section>
<section id="scenario-arelle-validates-xbrl-taxonomy-package">
<h4>Scenario: Arelle validates XBRL taxonomy package<a class="headerlink" href="#scenario-arelle-validates-xbrl-taxonomy-package" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> XBRL ZIP file downloaded and Arelle validation runs</p></li>
<li><p><strong>THEN</strong> validator extracts taxonomy, runs Arelle validation, writes validation/arelle_validation.json</p></li>
</ul>
</section>
</section>
<section id="requirement-comprehensive-provenance-manifests-with-normalized-hashes">
<h3>Requirement: Comprehensive Provenance Manifests with Normalized Hashes<a class="headerlink" href="#requirement-comprehensive-provenance-manifests-with-normalized-hashes" title="Link to this heading"></a></h3>
<p>The system SHALL record comprehensive provenance metadata for each downloaded ontology in manifest.json including source URL, resolver, version, license, ETag, Last-Modified, SHA-256, normalized SHA-256, fingerprint, timestamps, and validation status.</p>
<section id="scenario-manifest-records-all-standard-provenance-fields">
<h4>Scenario: Manifest records all standard provenance fields<a class="headerlink" href="#scenario-manifest-records-all-standard-provenance-fields" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> ontology successfully downloaded and validated</p></li>
<li><p><strong>THEN</strong> manifest.json contains fields: id, resolver, url, filename, version, license, status, sha256, etag, last_modified, downloaded_at, target_formats</p></li>
</ul>
</section>
<section id="scenario-manifest-includes-normalized-sha-256-hash">
<h4>Scenario: Manifest includes normalized SHA-256 hash<a class="headerlink" href="#scenario-manifest-includes-normalized-sha-256-hash" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> RDFLib validator produces canonical TTL normalization</p></li>
<li><p><strong>THEN</strong> manifest.json includes normalized_sha256 field with SHA-256 hash of canonical TTL content</p></li>
</ul>
</section>
<section id="scenario-manifest-includes-composite-fingerprint">
<h4>Scenario: Manifest includes composite fingerprint<a class="headerlink" href="#scenario-manifest-includes-composite-fingerprint" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> manifest is written after validation completes</p></li>
<li><p><strong>THEN</strong> manifest.json includes fingerprint field combining original SHA-256, normalized SHA-256, and metadata for unique identification</p></li>
</ul>
</section>
<section id="scenario-manifest-used-for-cache-invalidation-decision">
<h4>Scenario: Manifest used for cache invalidation decision<a class="headerlink" href="#scenario-manifest-used-for-cache-invalidation-decision" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> subsequent download request occurs for same ontology</p></li>
<li><p><strong>THEN</strong> system reads previous manifest.json and uses etag/last_modified values in conditional request headers</p></li>
</ul>
</section>
<section id="scenario-manifest-records-validation-outcomes">
<h4>Scenario: Manifest records validation outcomes<a class="headerlink" href="#scenario-manifest-records-validation-outcomes" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> validation pipeline runs on downloaded ontology</p></li>
<li><p><strong>THEN</strong> manifest.json includes validation section with results from all validators</p></li>
</ul>
</section>
<section id="scenario-manifest-validation-enforces-required-fields">
<h4>Scenario: Manifest validation enforces required fields<a class="headerlink" href="#scenario-manifest-validation-enforces-required-fields" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> _write_manifest attempts to write manifest with missing sha256</p></li>
<li><p><strong>THEN</strong> validation raises ConfigurationError “Manifest field ‘sha256’ must be populated”</p></li>
</ul>
</section>
</section>
<section id="requirement-license-compliance-enforcement-with-spdx-normalization">
<h3>Requirement: License Compliance Enforcement with SPDX Normalization<a class="headerlink" href="#requirement-license-compliance-enforcement-with-spdx-normalization" title="Link to this heading"></a></h3>
<p>The system SHALL check ontology licenses against configurable allowlist using SPDX-normalized identifiers and fail closed when encountering restricted licenses without explicit acceptance.</p>
<section id="scenario-normalize-license-before-allowlist-check">
<h4>Scenario: Normalize license before allowlist check<a class="headerlink" href="#scenario-normalize-license-before-allowlist-check" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> resolver reports license=”CC BY 4.0” and accept_licenses=[“CC-BY-4.0”]</p></li>
<li><p><strong>THEN</strong> system normalizes “CC BY 4.0” to “CC-BY-4.0”, finds match in allowlist, allows download</p></li>
</ul>
</section>
<section id="scenario-license-allowlist-permits-download-after-normalization">
<h4>Scenario: License allowlist permits download after normalization<a class="headerlink" href="#scenario-license-allowlist-permits-download-after-normalization" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> ontology has license=”CC0” (normalized to “CC0-1.0”) and accept_licenses includes “CC0-1.0”</p></li>
<li><p><strong>THEN</strong> download proceeds normally</p></li>
</ul>
</section>
<section id="scenario-license-not-in-allowlist-blocks-download">
<h4>Scenario: License not in allowlist blocks download<a class="headerlink" href="#scenario-license-not-in-allowlist-blocks-download" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> ontology has license=”Proprietary” and it is not in accept_licenses</p></li>
<li><p><strong>THEN</strong> system logs error and raises ConfigurationError indicating license restriction</p></li>
</ul>
</section>
<section id="scenario-unknown-license-variant-returns-original">
<h4>Scenario: Unknown license variant returns original<a class="headerlink" href="#scenario-unknown-license-variant-returns-original" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> resolver reports license=”Custom Open License v2”</p></li>
<li><p><strong>THEN</strong> normalize_license_to_spdx returns original string for allowlist comparison</p></li>
</ul>
</section>
<section id="scenario-missing-license-treated-as-restricted">
<h4>Scenario: Missing license treated as restricted<a class="headerlink" href="#scenario-missing-license-treated-as-restricted" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> ontology resolver returns license=None</p></li>
<li><p><strong>THEN</strong> system skips license check if allowlist empty, otherwise treats as restricted unless bypass configured</p></li>
</ul>
</section>
</section>
<section id="requirement-security-and-integrity-validation-with-enhanced-ssrf-protection">
<h3>Requirement: Security and Integrity Validation with Enhanced SSRF Protection<a class="headerlink" href="#requirement-security-and-integrity-validation-with-enhanced-ssrf-protection" title="Link to this heading"></a></h3>
<p>The system SHALL enforce security best practices including HTTPS-only downloads, certificate verification, enhanced URL validation with IDN normalization and optional allowlist, credential protection, safe archive extraction for ZIP and tar formats.</p>
<section id="scenario-https-enforced-for-all-downloads">
<h4>Scenario: HTTPS enforced for all downloads<a class="headerlink" href="#scenario-https-enforced-for-all-downloads" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> FetchPlan contains url with http:// scheme (not https://)</p></li>
<li><p><strong>THEN</strong> validate_url_security logs warning “Upgrading insecure HTTP to HTTPS” and upgrades scheme</p></li>
</ul>
</section>
<section id="scenario-idn-punycode-normalization-prevents-homograph-attacks">
<h4>Scenario: IDN punycode normalization prevents homograph attacks<a class="headerlink" href="#scenario-idn-punycode-normalization-prevents-homograph-attacks" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> URL contains Internationalized Domain Name with Unicode characters</p></li>
<li><p><strong>THEN</strong> validate_url_security converts to punycode before DNS resolution</p></li>
</ul>
</section>
<section id="scenario-host-allowlist-prevents-unauthorized-domains">
<h4>Scenario: Host allowlist prevents unauthorized domains<a class="headerlink" href="#scenario-host-allowlist-prevents-unauthorized-domains" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> http.allowed_hosts is configured and URL host not in allowlist</p></li>
<li><p><strong>THEN</strong> validate_url_security raises ConfigError “Host not in allowlist” before DNS resolution</p></li>
</ul>
</section>
<section id="scenario-url-validation-prevents-ssrf-to-private-ips">
<h4>Scenario: URL validation prevents SSRF to private IPs<a class="headerlink" href="#scenario-url-validation-prevents-ssrf-to-private-ips" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> resolver returns FetchPlan with url pointing to private IP range</p></li>
<li><p><strong>THEN</strong> validate_url_security rejects URL, logs error “Rejected download from private IP address”</p></li>
</ul>
</section>
<section id="scenario-tls-certificate-verification-enabled">
<h4>Scenario: TLS certificate verification enabled<a class="headerlink" href="#scenario-tls-certificate-verification-enabled" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> downloading from HTTPS URL</p></li>
<li><p><strong>THEN</strong> requests library uses verify=True for certificate validation and fails on invalid certificates</p></li>
</ul>
</section>
<section id="scenario-api-keys-masked-in-logs">
<h4>Scenario: API keys masked in logs<a class="headerlink" href="#scenario-api-keys-masked-in-logs" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> logging BioPortal request with Authorization header containing API key</p></li>
<li><p><strong>THEN</strong> log formatter replaces key with “<em><strong>masked</strong></em>” before writing</p></li>
</ul>
</section>
<section id="scenario-safe-filename-sanitization">
<h4>Scenario: Safe filename sanitization<a class="headerlink" href="#scenario-safe-filename-sanitization" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> Content-Disposition header contains path separators (e.g., “../evil.owl”)</p></li>
<li><p><strong>THEN</strong> sanitize_filename removes separators and logs warning</p></li>
</ul>
</section>
<section id="scenario-maximum-file-size-limit-enforced-early">
<h4>Scenario: Maximum file size limit enforced early<a class="headerlink" href="#scenario-maximum-file-size-limit-enforced-early" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> HEAD request Content-Length indicates file &gt;max_download_size_gb</p></li>
<li><p><strong>THEN</strong> download manager aborts before full GET with clear error message</p></li>
</ul>
</section>
<section id="scenario-zip-extraction-prevents-path-traversal">
<h4>Scenario: ZIP extraction prevents path traversal<a class="headerlink" href="#scenario-zip-extraction-prevents-path-traversal" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> extracting XBRL ZIP with member path “../../etc/passwd”</p></li>
<li><p><strong>THEN</strong> extract_zip_safe detects traversal, raises ConfigError, aborts extraction</p></li>
</ul>
</section>
<section id="scenario-tar-extraction-prevents-path-traversal">
<h4>Scenario: Tar extraction prevents path traversal<a class="headerlink" href="#scenario-tar-extraction-prevents-path-traversal" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> extracting tar.gz with member path containing “..” components</p></li>
<li><p><strong>THEN</strong> extract_tar_safe detects traversal, raises ConfigError, aborts extraction</p></li>
</ul>
</section>
<section id="scenario-tar-compression-bomb-detection">
<h4>Scenario: Tar compression bomb detection<a class="headerlink" href="#scenario-tar-compression-bomb-detection" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> tar.gz has compression ratio &gt;10:1 (potential bomb)</p></li>
<li><p><strong>THEN</strong> extract_tar_safe detects threat, logs error, aborts extraction</p></li>
</ul>
</section>
</section>
<section id="requirement-cli-with-pull-show-validate-plan-doctor-operations">
<h3>Requirement: CLI with Pull/Show/Validate/Plan/Doctor Operations<a class="headerlink" href="#requirement-cli-with-pull-show-validate-plan-doctor-operations" title="Link to this heading"></a></h3>
<p>The system SHALL provide command-line interface (ontofetch) with subcommands for downloading (pull), inspecting (show), validating (validate), planning (plan), and diagnosing (doctor) with both batch and single-ontology modes.</p>
<section id="scenario-pull-ontologies-from-sources-yaml">
<h4>Scenario: Pull ontologies from sources.yaml<a class="headerlink" href="#scenario-pull-ontologies-from-sources-yaml" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">pull</span> <span class="pre">--spec</span> <span class="pre">sources.yaml</span></code></p></li>
<li><p><strong>THEN</strong> CLI reads sources.yaml, iterates through ontology list, downloads each with progress reporting</p></li>
</ul>
</section>
<section id="scenario-pull-with-dry-run-shows-planned-actions">
<h4>Scenario: Pull with dry-run shows planned actions<a class="headerlink" href="#scenario-pull-with-dry-run-shows-planned-actions" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">pull</span> <span class="pre">--spec</span> <span class="pre">sources.yaml</span> <span class="pre">--dry-run</span></code></p></li>
<li><p><strong>THEN</strong> CLI resolves all FetchPlans, logs planned downloads with size estimates, exits without downloading</p></li>
</ul>
</section>
<section id="scenario-pull-single-ontology-by-id">
<h4>Scenario: Pull single ontology by ID<a class="headerlink" href="#scenario-pull-single-ontology-by-id" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">pull</span> <span class="pre">hp</span> <span class="pre">--resolver</span> <span class="pre">obo</span> <span class="pre">--target-formats</span> <span class="pre">owl,obo</span></code></p></li>
<li><p><strong>THEN</strong> CLI constructs FetchSpec for HP and downloads using OBOResolver with format fallback</p></li>
</ul>
</section>
<section id="scenario-force-refresh-bypasses-cache">
<h4>Scenario: Force refresh bypasses cache<a class="headerlink" href="#scenario-force-refresh-bypasses-cache" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">pull</span> <span class="pre">hp</span> <span class="pre">--force</span></code></p></li>
<li><p><strong>THEN</strong> CLI ignores ETag/Last-Modified from previous manifest and forces fresh download</p></li>
</ul>
</section>
<section id="scenario-show-ontology-manifest">
<h4>Scenario: Show ontology manifest<a class="headerlink" href="#scenario-show-ontology-manifest" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">show</span> <span class="pre">hp</span></code></p></li>
<li><p><strong>THEN</strong> CLI reads ontologies/hp/<latest-version>/manifest.json and displays provenance fields</p></li>
</ul>
</section>
<section id="scenario-re-run-validation-on-existing-ontology">
<h4>Scenario: Re-run validation on existing ontology<a class="headerlink" href="#scenario-re-run-validation-on-existing-ontology" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">validate</span> <span class="pre">hp&#64;2024-10-31</span> <span class="pre">--rdflib</span> <span class="pre">--pronto</span></code></p></li>
<li><p><strong>THEN</strong> CLI locates original file and re-runs RDFLib and Pronto validators (pronto in subprocess), updates validation outputs</p></li>
</ul>
</section>
<section id="scenario-plan-command-previews-fetchplan">
<h4>Scenario: Plan command previews FetchPlan<a class="headerlink" href="#scenario-plan-command-previews-fetchplan" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">plan</span> <span class="pre">hp</span> <span class="pre">--resolver</span> <span class="pre">obo</span> <span class="pre">--json</span></code></p></li>
<li><p><strong>THEN</strong> CLI resolves FetchPlan and outputs JSON with url, headers, version, license, media_type without downloading</p></li>
</ul>
</section>
<section id="scenario-doctor-diagnoses-environment">
<h4>Scenario: Doctor diagnoses environment<a class="headerlink" href="#scenario-doctor-diagnoses-environment" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">doctor</span></code></p></li>
<li><p><strong>THEN</strong> CLI checks filesystem permissions, API credentials, disk space, network connectivity, and reports status with remediation hints</p></li>
</ul>
</section>
<section id="id2">
<h4>Scenario: Doctor JSON output for automation<a class="headerlink" href="#id2" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">doctor</span> <span class="pre">--json</span></code></p></li>
<li><p><strong>THEN</strong> CLI outputs diagnostic results as JSON with boolean status fields for automated monitoring</p></li>
</ul>
</section>
<section id="scenario-machine-readable-json-output">
<h4>Scenario: Machine-readable JSON output<a class="headerlink" href="#scenario-machine-readable-json-output" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> user runs <code class="docutils literal notranslate"><span class="pre">ontofetch</span> <span class="pre">show</span> <span class="pre">hp</span> <span class="pre">--json</span></code></p></li>
<li><p><strong>THEN</strong> CLI outputs complete manifest.json content as valid JSON to stdout</p></li>
</ul>
</section>
</section>
<section id="requirement-source-agnostic-resolver-registry-with-extended-coverage">
<h3>Requirement: Source-Agnostic Resolver Registry with Extended Coverage<a class="headerlink" href="#requirement-source-agnostic-resolver-registry-with-extended-coverage" title="Link to this heading"></a></h3>
<p>The system SHALL provide resolver registry that maps ontology source identifiers (OBO, OLS, BioPortal, SKOS, XBRL, LOV, Ontobee) to concrete resolver implementations with automatic fallback through preferred source order.</p>
<section id="scenario-resolve-obo-foundry-ontology-by-prefix">
<h4>Scenario: Resolve OBO Foundry ontology by prefix<a class="headerlink" href="#scenario-resolve-obo-foundry-ontology-by-prefix" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> FetchSpec with resolver=”obo” and id=”hp” is provided</p></li>
<li><p><strong>THEN</strong> OBOResolver uses Bioregistry functions to return FetchPlan with PURL for hp.owl or hp.obo</p></li>
</ul>
</section>
<section id="scenario-resolve-ontology-from-ols4">
<h4>Scenario: Resolve ontology from OLS4<a class="headerlink" href="#scenario-resolve-ontology-from-ols4" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> FetchSpec with resolver=”ols” and id=”efo” is provided</p></li>
<li><p><strong>THEN</strong> OLSResolver queries OLS4 API via ols-client and returns FetchPlan with canonical OWL download URL</p></li>
</ul>
</section>
<section id="scenario-resolve-ontology-from-bioportal-with-api-key">
<h4>Scenario: Resolve ontology from BioPortal with API key<a class="headerlink" href="#scenario-resolve-ontology-from-bioportal-with-api-key" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> FetchSpec with resolver=”bioportal” and extras containing acronym=”NCIT” is provided</p></li>
<li><p><strong>THEN</strong> BioPortalResolver uses ontoportal-client to fetch latest submission and returns FetchPlan with Authorization header</p></li>
</ul>
</section>
<section id="scenario-resolve-skos-thesaurus-from-direct-url">
<h4>Scenario: Resolve SKOS thesaurus from direct URL<a class="headerlink" href="#scenario-resolve-skos-thesaurus-from-direct-url" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> FetchSpec with resolver=”skos” and extras containing direct URL is provided</p></li>
<li><p><strong>THEN</strong> SKOSResolver returns FetchPlan with provided URL and RDF content negotiation headers</p></li>
</ul>
</section>
<section id="scenario-resolve-xbrl-taxonomy-package">
<h4>Scenario: Resolve XBRL taxonomy package<a class="headerlink" href="#scenario-resolve-xbrl-taxonomy-package" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> FetchSpec with resolver=”xbrl” and extras containing taxonomy ZIP URL is provided</p></li>
<li><p><strong>THEN</strong> XBRLResolver returns FetchPlan with ZIP URL for download and Arelle validation</p></li>
</ul>
</section>
<section id="scenario-resolve-vocabulary-from-lov">
<h4>Scenario: Resolve vocabulary from LOV<a class="headerlink" href="#scenario-resolve-vocabulary-from-lov" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> FetchSpec with resolver=”lov” and extras.uri is provided</p></li>
<li><p><strong>THEN</strong> LOVResolver queries LOV API and returns FetchPlan with Turtle download URL</p></li>
</ul>
</section>
<section id="scenario-resolve-ontology-from-ontobee-purl">
<h4>Scenario: Resolve ontology from Ontobee PURL<a class="headerlink" href="#scenario-resolve-ontology-from-ontobee-purl" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> FetchSpec with resolver=”ontobee” and id=”hp” is provided</p></li>
<li><p><strong>THEN</strong> OntobeeResolver constructs PURL and returns FetchPlan with purl.obolibrary.org URL</p></li>
</ul>
</section>
<section id="scenario-automatic-fallback-through-prefer-source">
<h4>Scenario: Automatic fallback through prefer_source<a class="headerlink" href="#scenario-automatic-fallback-through-prefer-source" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> prefer_source=[“obo”, “ols”, “ontobee”] and OBOResolver fails</p></li>
<li><p><strong>THEN</strong> FallbackResolver automatically tries OLSResolver, then OntobeeResolver if OLS also fails</p></li>
</ul>
</section>
<section id="scenario-fallback-logging-for-observability">
<h4>Scenario: Fallback logging for observability<a class="headerlink" href="#scenario-fallback-logging-for-observability" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> fallback occurs during resolution</p></li>
<li><p><strong>THEN</strong> each resolver attempt logged with outcome for troubleshooting</p></li>
</ul>
</section>
</section>
<section id="requirement-structured-logging-for-observability-with-sensitive-data-masking">
<h3>Requirement: Structured Logging for Observability with Sensitive Data Masking<a class="headerlink" href="#requirement-structured-logging-for-observability-with-sensitive-data-masking" title="Link to this heading"></a></h3>
<p>The system SHALL emit structured JSON logs capturing resolver actions, HTTP operations, validation outcomes, fallback attempts, and aggregate metrics with automatic masking of sensitive fields.</p>
<section id="scenario-log-resolver-plan-with-timing">
<h4>Scenario: Log resolver plan with timing<a class="headerlink" href="#scenario-log-resolver-plan-with-timing" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> resolver generates FetchPlan</p></li>
<li><p><strong>THEN</strong> log entry written with fields: timestamp, level=”info”, stage=”resolver”, id, resolver_type, plan_url, planning_time_ms</p></li>
</ul>
</section>
<section id="scenario-log-fallback-resolver-attempts">
<h4>Scenario: Log fallback resolver attempts<a class="headerlink" href="#scenario-log-fallback-resolver-attempts" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> FallbackResolver tries multiple resolvers</p></li>
<li><p><strong>THEN</strong> log entries written for each attempt with resolver_name, attempt_number, outcome, error_message</p></li>
</ul>
</section>
<section id="scenario-log-http-download-with-status-and-timing">
<h4>Scenario: Log HTTP download with status and timing<a class="headerlink" href="#scenario-log-http-download-with-status-and-timing" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> download completes</p></li>
<li><p><strong>THEN</strong> log entry written with fields: timestamp, stage=”download”, url, status_code, etag, sha256, elapsed_time_ms, retries, cache_hit, service</p></li>
</ul>
</section>
<section id="scenario-log-head-request-validation">
<h4>Scenario: Log HEAD request validation<a class="headerlink" href="#scenario-log-head-request-validation" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> HEAD request executes before GET</p></li>
<li><p><strong>THEN</strong> log entry written with stage=”head”, media_type_match, content_length, elapsed_time_ms</p></li>
</ul>
</section>
<section id="scenario-log-validation-outcome-with-subprocess-indicator">
<h4>Scenario: Log validation outcome with subprocess indicator<a class="headerlink" href="#scenario-log-validation-outcome-with-subprocess-indicator" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> validator runs (subprocess or in-process)</p></li>
<li><p><strong>THEN</strong> log entry written with fields: stage=”validation”, parser, outcome, error_message, metrics, subprocess=true/false</p></li>
</ul>
</section>
<section id="scenario-log-subprocess-validator-lifecycle">
<h4>Scenario: Log subprocess validator lifecycle<a class="headerlink" href="#scenario-log-subprocess-validator-lifecycle" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> pronto or owlready2 validation spawns subprocess</p></li>
<li><p><strong>THEN</strong> log entries written for subprocess start, completion, and memory isolation benefit</p></li>
</ul>
</section>
<section id="scenario-mask-sensitive-headers-in-logs">
<h4>Scenario: Mask sensitive headers in logs<a class="headerlink" href="#scenario-mask-sensitive-headers-in-logs" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> logging API request with Authorization header</p></li>
<li><p><strong>THEN</strong> log formatter detects sensitive keys and replaces values with “<em><strong>masked</strong></em>”</p></li>
</ul>
</section>
<section id="scenario-log-batch-summary-on-completion">
<h4>Scenario: Log batch summary on completion<a class="headerlink" href="#scenario-log-batch-summary-on-completion" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> batch pull operation completes</p></li>
<li><p><strong>THEN</strong> log entry written with fields: stage=”summary”, total_ontologies, success_count, cached_count, failure_count, fallback_count, total_bandwidth_bytes</p></li>
</ul>
</section>
</section>
<section id="requirement-normalized-format-generation-with-deterministic-output">
<h3>Requirement: Normalized Format Generation with Deterministic Output<a class="headerlink" href="#requirement-normalized-format-generation-with-deterministic-output" title="Link to this heading"></a></h3>
<p>The system SHALL optionally generate normalized formats (canonical Turtle from RDF/OWL via RDFLib, OBO Graph JSON from OBO/OWL via Pronto) with deterministic output and stable hashing for cache correctness.</p>
<section id="scenario-rdflib-serializes-owl-to-canonical-turtle">
<h4>Scenario: RDFLib serializes OWL to canonical Turtle<a class="headerlink" href="#scenario-rdflib-serializes-owl-to-canonical-turtle" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> OWL file parses successfully with RDFLib and normalize_to includes “ttl”</p></li>
<li><p><strong>THEN</strong> RDFLib canonicalizes graph (sorted prefixes and triples), serializes to normalized/<filename>.ttl</p></li>
</ul>
</section>
<section id="scenario-canonical-ttl-produces-deterministic-hash">
<h4>Scenario: Canonical TTL produces deterministic hash<a class="headerlink" href="#scenario-canonical-ttl-produces-deterministic-hash" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> same ontology downloaded twice and normalized</p></li>
<li><p><strong>THEN</strong> both normalized TTL files have identical SHA-256 hash</p></li>
</ul>
</section>
<section id="scenario-pronto-exports-obo-graph-json-via-subprocess">
<h4>Scenario: Pronto exports OBO Graph JSON via subprocess<a class="headerlink" href="#scenario-pronto-exports-obo-graph-json-via-subprocess" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> OBO file parses successfully with Pronto and normalize_to includes “obographs”</p></li>
<li><p><strong>THEN</strong> Pronto subprocess exports ontology to normalized/<filename>.json in OBO Graph JSON format</p></li>
</ul>
</section>
<section id="scenario-original-file-preserved-bit-exact">
<h4>Scenario: Original file preserved bit-exact<a class="headerlink" href="#scenario-original-file-preserved-bit-exact" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> any ontology is downloaded</p></li>
<li><p><strong>THEN</strong> exact downloaded bytes saved in original/<filename> without modification</p></li>
</ul>
</section>
<section id="scenario-normalized-hash-stored-in-manifest">
<h4>Scenario: Normalized hash stored in manifest<a class="headerlink" href="#scenario-normalized-hash-stored-in-manifest" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>WHEN</strong> RDFLib produces canonical TTL and computes hash</p></li>
<li><p><strong>THEN</strong> manifest.json includes normalized_sha256 field for cache validation</p></li>
</ul>
</section>
</section>
</section>
<section id="removed-requirements">
<h2>REMOVED Requirements<a class="headerlink" href="#removed-requirements" title="Link to this heading"></a></h2>
<p>None. All existing requirements are preserved with enhancements.</p>
</section>
<section id="renamed-requirements">
<h2>RENAMED Requirements<a class="headerlink" href="#renamed-requirements" title="Link to this heading"></a></h2>
<p>None. All requirements maintain their original names with “(with <enhancement>)” clarifications in headings where modified.</p>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, DocsToKG Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

</body>
</html>
