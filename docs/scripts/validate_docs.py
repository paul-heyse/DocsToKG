#!/usr/bin/env python3
"""
Documentation Validation Script

This script validates documentation quality by checking:
- Style guide compliance
- Broken links
- Missing required sections
- Proper formatting
- Consistent terminology
"""

import re
import sys
from pathlib import Path
from typing import Dict, List


class DocumentationValidator:
    """Validates documentation quality and consistency."""

    def __init__(self, docs_dir: str = "docs"):
        self.docs_dir = Path(docs_dir)
        self.issues: List[Dict] = []
        self.style_guide = self._load_style_guide()
        self._skip_dirs = {Path("04-api")}

    def _is_autogenerated(self, file_path: Path) -> bool:
        """Return True if the file lives in a directory we skip for style checks."""
        try:
            relative = file_path.relative_to(self.docs_dir)
        except ValueError:
            return False
        return any(relative.parts[0] == skip_dir.as_posix() for skip_dir in self._skip_dirs)

    def _load_style_guide(self) -> Dict:
        """Load style guide rules from the STYLE_GUIDE.md file."""
        style_file = self.docs_dir / "STYLE_GUIDE.md"

        if not style_file.exists():
            print(f"⚠️  Style guide not found: {style_file}")
            return {}

        # For now, return basic rules - in a real implementation,
        # this would parse the style guide file
        return {
            "required_sections": ["Overview", "Prerequisites", "Installation"],
            "forbidden_terms": ["TODO", "FIXME", "XXX"],
            "required_terms": ["DocsToKG"],
            "heading_levels": {"max_depth": 4, "require_numbers": True},
        }

    def validate_file(self, file_path: Path) -> List[Dict]:
        """Validate a single documentation file."""
        issues = []
        file_name = file_path.name

        try:
            with open(file_path, "r", encoding="utf-8") as f:
                content = f.read()
                lines = content.split("\n")
        except Exception as e:
            return [{"type": "error", "message": f"Could not read file: {e}", "file": file_name}]

        # Check for required sections
        issues.extend(self._check_required_sections(content, file_path))

        # Check for forbidden terms
        issues.extend(self._check_forbidden_terms(content, file_name))

        # Check for required terms
        issues.extend(self._check_required_terms(content, file_path, file_name))

        # Check heading structure
        issues.extend(self._check_heading_structure(lines, file_path, file_name))

        # Check for broken internal links
        issues.extend(self._check_internal_links(content, file_path, file_name))

        # Check for consistent formatting
        issues.extend(self._check_formatting(lines, file_path, file_name))

        return issues

    def _check_required_sections(self, content: str, file_path: Path) -> List[Dict]:
        """Check if required sections are present."""
        issues = []
        relative_path = file_path.relative_to(self.docs_dir)
        path_str = str(relative_path).replace("\\", "/").lower()
        stem = file_path.stem.lower()

        should_check = False
        is_autogen = self._is_autogenerated(file_path)
        if path_str == "02-setup/index.md":
            should_check = True
        elif "setup" in stem or "installation" in stem:
            should_check = True

        if not should_check or is_autogen:
            return issues

        missing_sections = []
        for section in self.style_guide.get("required_sections", []):
            heading_pattern = re.compile(
                rf"^(?:##|#)\s+(?:\d+\.\s+)?{re.escape(section)}\b",
                re.IGNORECASE | re.MULTILINE,
            )
            if f"## {section}" not in content and f"# {section}" not in content:
                if heading_pattern.search(content):
                    continue
                missing_sections.append(section)

        if missing_sections:
            issues.append(
                {
                    "type": "warning",
                    "message": f"Missing required sections: {', '.join(missing_sections)}",
                    "file": str(relative_path),
                }
            )

        return issues

    def _check_forbidden_terms(self, content: str, file_name: str) -> List[Dict]:
        """Check for forbidden terms that should not be in documentation."""
        issues = []
        if self._is_autogenerated(Path(file_name)):
            return issues

        for term in self.style_guide.get("forbidden_terms", []):
            pattern = re.compile(rf"\b{re.escape(term)}\b", re.IGNORECASE)
            if pattern.search(content):
                issues.append(
                    {
                        "type": "warning",
                        "message": f"Found forbidden term '{term}' - consider removing or replacing",
                        "file": file_name,
                    }
                )

        return issues

    def _check_required_terms(self, content: str, file_path: Path, file_name: str) -> List[Dict]:
        """Check for required terms that should be mentioned."""
        issues = []
        if self._is_autogenerated(file_path):
            return issues

        for term in self.style_guide.get("required_terms", []):
            if term not in content:
                issues.append(
                    {
                        "type": "info",
                        "message": f"Consider mentioning '{term}' in this documentation",
                        "file": file_name,
                    }
                )

        return issues

    def _check_heading_structure(
        self, lines: List[str], file_path: Path, file_name: str
    ) -> List[Dict]:
        """Check heading structure and numbering."""
        issues = []
        in_code_block = False

        if self._is_autogenerated(file_path):
            return issues

        for i, line in enumerate(lines, 1):
            stripped = line.lstrip()

            if stripped.startswith("```"):
                in_code_block = not in_code_block
                continue

            if in_code_block:
                continue

            if stripped.startswith("#"):
                # Count the number of # symbols
                level = len(stripped) - len(stripped.lstrip("#"))

                if level > self.style_guide.get("heading_levels", {}).get("max_depth", 4):
                    issues.append(
                        {
                            "type": "warning",
                            "message": f"Heading too deep (level {level}) at line {i}",
                            "file": file_name,
                            "line": i,
                        }
                    )

                # Check for proper numbering in numbered sections
                if self.style_guide.get("heading_levels", {}).get("require_numbers", True):
                    if level <= 2 and not re.match(r"^#{1,2}\s+\d+\.", stripped):
                        issues.append(
                            {
                                "type": "info",
                                "message": f"Consider numbering section at line {i}",
                                "file": file_name,
                                "line": i,
                            }
                        )

        return issues

    def _check_internal_links(self, content: str, file_path: Path, file_name: str) -> List[Dict]:
        """Check for broken internal links."""
        issues = []

        # Find all markdown links
        link_pattern = r"\[([^\]]+)\]\(([^)]+)\)"
        matches = re.findall(link_pattern, content)

        for link_text, link_url in matches:
            if link_url.startswith("#"):  # Anchor link
                # Check if anchor exists in the same file
                if not self._check_anchor_exists(content, link_url[1:]):
                    issues.append(
                        {
                            "type": "warning",
                            "message": f"Broken anchor link: {link_url}",
                            "file": file_name,
                        }
                    )

            elif not link_url.startswith("http"):  # Internal relative link
                # Check if the linked file exists
                linked_file = file_path.parent / link_url
                if not linked_file.exists():
                    issues.append(
                        {
                            "type": "warning",
                            "message": f"Broken internal link: {link_url}",
                            "file": file_name,
                        }
                    )

        return issues

    def _check_anchor_exists(self, content: str, anchor: str) -> bool:
        """Check if an anchor exists in the content."""
        # Look for heading with id attribute or direct anchor
        anchor_pattern = f'id="{anchor}"'
        if anchor_pattern in content:
            return True
        markdown_anchor = f"{{#{anchor}}}"
        if markdown_anchor in content:
            return True

        # Also check for implicit anchors from headings
        # This is a simplified check - in practice you'd want more sophisticated parsing
        return False

    def _check_formatting(self, lines: List[str], file_path: Path, file_name: str) -> List[Dict]:
        """Check for consistent formatting."""
        issues = []

        max_len = 200
        if self._is_autogenerated(file_path):
            return issues
        for i, line in enumerate(lines, 1):
            # Check for trailing whitespace
            if line.rstrip() != line:
                issues.append(
                    {
                        "type": "info",
                        "message": f"Trailing whitespace at line {i}",
                        "file": file_name,
                        "line": i,
                    }
                )

            # Check for very long lines
            if len(line) > max_len:
                issues.append(
                    {
                        "type": "info",
                        "message": f"Very long line ({len(line)} chars) at line {i}",
                        "file": file_name,
                        "line": i,
                    }
                )

        return issues

    def validate_all_docs(self) -> List[Dict]:
        """Validate all documentation files."""
        print("🔍 Validating documentation...")

        all_issues = []

        if not self.docs_dir.exists():
            print(f"❌ Documentation directory not found: {self.docs_dir}")
            return [{"type": "error", "message": "Documentation directory not found"}]

        # Find all markdown files
        md_files = list(self.docs_dir.rglob("*.md"))

        if not md_files:
            print("❌ No markdown files found to validate")
            return [{"type": "error", "message": "No markdown files found"}]

        print(f"📁 Found {len(md_files)} markdown files to validate")

        for file_path in md_files:
            issues = self.validate_file(file_path)
            all_issues.extend(issues)

            if issues:
                print(f"⚠️  Found {len(issues)} issues in {file_path.name}")

        return all_issues

    def print_report(self, issues: List[Dict], *, show_all_info: bool = False):
        """Print a formatted validation report."""
        if not issues:
            print("\n✅ No documentation issues found!")
            return

        # Group issues by type
        issues_by_type = {}
        for issue in issues:
            issue_type = issue.get("type", "unknown")
            if issue_type not in issues_by_type:
                issues_by_type[issue_type] = []
            issues_by_type[issue_type].append(issue)

        print("\n📋 Documentation Validation Report")
        print("=" * 50)

        total_issues = len(issues)
        print(f"Total issues found: {total_issues}")

        for issue_type in ["error", "warning", "info"]:
            type_issues = issues_by_type.get(issue_type, [])
            if type_issues:
                print(f"\n{issue_type.upper()} ({len(type_issues)}):")
                limit = None if show_all_info else 10
                display_issues = type_issues if limit is None else type_issues[:limit]
                for issue in display_issues:
                    file_name = issue.get("file", "unknown")
                    message = issue.get("message", "No message")
                    line = issue.get("line", "")
                    line_str = f":{line}" if line else ""
                    print(f"  • {file_name}{line_str} - {message}")

                if limit is not None and len(type_issues) > limit:
                    print(f"  • ... and {len(type_issues) - limit} more {issue_type} issues")

        print(f"\n📊 Summary: {total_issues} total issues")
        print("Run 'python docs/scripts/generate_all_docs.py --validate-only' to see all details")


def main():
    """Main entry point for documentation validation."""
    print("🔍 Starting Documentation Validation")
    print("=" * 50)

    show_all_info = False
    if "--show-all-info" in sys.argv:
        show_all_info = True
        sys.argv.remove("--show-all-info")

    validator = DocumentationValidator()
    issues = validator.validate_all_docs()

    validator.print_report(issues, show_all_info=show_all_info)

    # Exit with error code if there are errors or warnings
    error_count = len([i for i in issues if i.get("type") == "error"])
    warning_count = len([i for i in issues if i.get("type") == "warning"])

    if error_count > 0:
        print(f"\n❌ Validation failed: {error_count} errors, {warning_count} warnings")
        sys.exit(1)
    elif warning_count > 0:
        print(f"\n⚠️  Validation completed with warnings: {warning_count} warnings")
        sys.exit(0)
    else:
        print("\n✅ Validation passed!")
        sys.exit(0)


if __name__ == "__main__":
    main()
